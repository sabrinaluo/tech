<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[RSS Feed]]></title><description><![CDATA[Hiitea's tech blog for web development knowledge sharing]]></description><link>https://hiitea.io</link><generator>GatsbyJS</generator><lastBuildDate>Mon, 24 Oct 2022 09:45:03 GMT</lastBuildDate><item><title><![CDATA[css中使用 object-fit 来控制可替换元素的样式]]></title><description><![CDATA[偷懒很久了，昨天好不容易花点时间做了一下 css 的一些测验，发现自己居然连  object-fit  都不会用，连  replaced element 都没听过，居然也能测出 expert 水平…但有进步总是比什么都不做强一些。 object-fit…]]></description><link>https://hiitea.io/2020/02/20/css-object-fit/</link><guid isPermaLink="false">https://hiitea.io/2020/02/20/css-object-fit/</guid><pubDate>Thu, 20 Feb 2020 15:46:35 GMT</pubDate><content:encoded>&lt;p&gt;偷懒很久了，昨天好不容易花点时间做了一下 css 的一些测验，发现自己居然连 &lt;code&gt;object-fit&lt;/code&gt; 都不会用，连 &lt;code&gt;replaced element&lt;/code&gt;都没听过，居然也能测出 expert 水平…但有进步总是比什么都不做强一些。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;object-fit 是用于控制可替换元素(replaced element&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;)在容器中如何显示的属性&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;可替换元素 replaced element&lt;/h2&gt;&lt;p&gt;可替换元素是独立于 CSS 的外部对象，其展现效果不由所继承的父文档 css 所控制，例如 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 本身有自己的样式，其样式不会受父文档中样式的影响&lt;/p&gt;&lt;h3&gt;典型的可替换元素&lt;/h3&gt;&lt;p&gt;典型可替换元素有以下几种：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;某些元素在特定情况下也被视为可替换元素，例如 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;（这个我都不知道是啥）&lt;/p&gt;&lt;h2&gt;CSS 控制控制可替换元素的样式&lt;/h2&gt;&lt;p&gt;&lt;code&gt;object-fit&lt;/code&gt; 控制可替换元素在容器中如何显示，有以下几种值，以图片做例子进行说明：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;fill&lt;/code&gt; 不按物件本身的宽高比的填充，而是按容器的大小填充，会出现图片变形等情况&lt;/li&gt;&lt;li&gt;&lt;code&gt;cover&lt;/code&gt; 在保持物件本身宽高比，填充整个容器大小&lt;/li&gt;&lt;li&gt;&lt;code&gt;contain&lt;/code&gt; 保持物件宽高比，当容器宽高比与物件宽高比不同时，物件的宽或高只有其中一个与容器相等&lt;/li&gt;&lt;li&gt;&lt;code&gt;none&lt;/code&gt; 保持物件宽高比，不缩放，直接填充，图片较大容器较小时，只截取部分图片&lt;/li&gt;&lt;li&gt;&lt;code&gt;scale-down&lt;/code&gt; 保持物件宽高比，与 &lt;code&gt;none&lt;/code&gt; 或 &lt;code&gt;contain&lt;/code&gt; 其中物件显示较小时相同&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;code&gt;object-position&lt;/code&gt; 控制在容器中的位置，类似 &lt;code&gt;bakcground-position&lt;/code&gt;&lt;/p&gt;&lt;p&gt;一张图胜过千言万语
&lt;img src=&quot;https://user-images.githubusercontent.com/5300359/74955610-db787980-543f-11ea-911f-9ef0f30788ea.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Replaced_element&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/CSS/Replaced_element&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[css selector 选择器]]></title><description><![CDATA[写了快两年  styled-components  的本宝宝，压根就用不到什么选择器了。可想而知那帮搞出 css-in-js 的工程师肯定都是不喜欢没逻辑的 css。 我来复习复习，css 选择器是面试大概率会问的问题吧 😝 基本选择器 类型 选择器 例子 element…]]></description><link>https://hiitea.io/2019/08/22/css-selector/</link><guid isPermaLink="false">https://hiitea.io/2019/08/22/css-selector/</guid><pubDate>Thu, 22 Aug 2019 15:23:30 GMT</pubDate><content:encoded>&lt;p&gt;写了快两年 &lt;code&gt;styled-components&lt;/code&gt; 的本宝宝，压根就用不到什么选择器了。可想而知那帮搞出 css-in-js 的工程师肯定都是不喜欢没逻辑的 css。&lt;/p&gt;&lt;p&gt;我来复习复习，css 选择器是面试大概率会问的问题吧 😝&lt;/p&gt;&lt;h2&gt;基本选择器&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h2&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;&lt;th&gt;选择器&lt;/th&gt;&lt;th&gt;例子&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;element&lt;/td&gt;&lt;td&gt;element&lt;/td&gt;&lt;td&gt;e.g. &lt;code&gt;div&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;id&lt;/td&gt;&lt;td&gt;#&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;class&lt;/td&gt;&lt;td&gt;.&lt;/td&gt;&lt;td&gt;e.g. &lt;code&gt;.btn&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;全部&lt;/td&gt;&lt;td&gt;*&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;属性选择器&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;&lt;p&gt;属性选择器有以下几种语法，一般也就前两个比较常用&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;[attr]&lt;/code&gt; 所有包含 attr 属性的元素&lt;/li&gt;&lt;li&gt;&lt;code&gt;[attr=value]&lt;/code&gt; 属性等于 xx 的元素，e.g. &lt;code&gt;a[target=&amp;quot;_blank&amp;quot;]&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;[attr~=value]&lt;/code&gt; 属性包含 xx 完整“单词”的元素，xx 必须是完整的&lt;strong&gt;“单词”&lt;/strong&gt;，与其他用空格分开，e.g. &lt;code&gt;[class~=top]&lt;/code&gt; 将会选中&lt;code&gt;class=&amp;quot;abc top&amp;quot;&lt;/code&gt;，但不会选中&lt;code&gt;class=&amp;quot;abc ttoppic&amp;quot;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;[attr|=value]&lt;/code&gt; 属性由 xx 开始的元素，e.g. &lt;code&gt;[class|=top]&lt;/code&gt;，将会选中类似&lt;code&gt;class=&amp;quot;top&amp;quot;&lt;/code&gt; &lt;code&gt;class=&amp;quot;top-btn&amp;quot;&lt;/code&gt;的元素，value 必须是一个完整的&lt;strong&gt;“单词”&lt;/strong&gt;，在这个选择器下，&lt;code&gt;class=&amp;quot;topic&amp;quot;&lt;/code&gt;&lt;strong&gt;不会被选中&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;[attr^=value]&lt;/code&gt; 以 xx 开始的元素，类似正则 6.&lt;code&gt;[attr$=value]&lt;/code&gt; 以 xx 结尾的元素，类似正则&lt;/li&gt;&lt;li&gt;&lt;code&gt;[attr*=value]&lt;/code&gt; 包含 xx 的元素，与上面例 3 不同，e.g. &lt;code&gt;[class*=top]&lt;/code&gt; 将会选中&lt;code&gt;class=&amp;quot;abc top&amp;quot;&lt;/code&gt; 以及&lt;code&gt;class=&amp;quot;abc ttoppic&amp;quot;&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;学习了以上，就会有关于&lt;strong&gt;引号&lt;/strong&gt;的问题，有时候见到属性选择器中的 value 是有引号的，有时候又是没有引号的。关于引号的问题，css 中有一套规则，满足规则的情况下可以不使用引号，否则则需要使用&lt;sup id=&quot;fnref-3&quot;&gt;&lt;a href=&quot;#fn-3&quot; class=&quot;footnote-ref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;。通常情况下，为了保险起见，就全都加上引号吧。&lt;/p&gt;&lt;h3&gt;结合选择器 Combinators&lt;/h3&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;选择器&lt;/th&gt;&lt;th&gt;英文&lt;/th&gt;&lt;th&gt;例子&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;div p&lt;/code&gt;&lt;/td&gt;&lt;td&gt;desendant combinator&lt;/td&gt;&lt;td&gt;div 里的所有 p&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;div &amp;gt; p&lt;/code&gt;&lt;/td&gt;&lt;td&gt;child combinator&lt;/td&gt;&lt;td&gt;div 的直接孩子 p，direct child&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;div + p&lt;/code&gt;&lt;/td&gt;&lt;td&gt;adjacent sibling combinator&lt;/td&gt;&lt;td&gt;同一层级兄弟选择器，紧跟 div 的 p，&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;div ~ p&lt;/code&gt;&lt;/td&gt;&lt;td&gt;general sibling combinator&lt;/td&gt;&lt;td&gt;div 的所有兄弟 p&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;伪类 Pseudo-class&lt;sup id=&quot;fnref-4&quot;&gt;&lt;a href=&quot;#fn-4&quot; class=&quot;footnote-ref&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;&lt;p&gt;比较常用的伪类有&lt;code&gt;a:link,a:hover,a:visited&lt;/code&gt;,&lt;code&gt;button:focus&lt;/code&gt;, 各种 child 系列&lt;code&gt;:first-child, :last-child, :nth-child()&lt;/code&gt;&lt;/p&gt;&lt;h3&gt;伪元素 Pseudo-element&lt;/h3&gt;&lt;p&gt;比较常用的有&lt;code&gt;::before ::after&lt;/code&gt;&lt;/p&gt;&lt;p&gt;第一次知道居然还有这种 &lt;code&gt;p::first-line&lt;/code&gt; 和这种 &lt;code&gt;p::first-letter&lt;/code&gt;!简直不可思议，以及看到这两个伪元素的时候，在一次 convince 了&lt;strong&gt;很多事情其实并不需要 js，css 就完全可以搞定了！&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;关于伪元素的冒号问题&lt;code&gt;::&lt;/code&gt;，平时写 styled-component 不管是伪类还是伪元素，都写一个冒号，但是有时候会看到有的地方是两个冒号 🤔。简单的来说&lt;sup id=&quot;fnref-5&quot;&gt;&lt;a href=&quot;#fn-5&quot; class=&quot;footnote-ref&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;历史原因，CSS2 中所有都是一个冒号，CSS3 中一个冒号是伪类，两个冒号是伪元素&lt;/li&gt;&lt;li&gt;在现代浏览器（&amp;gt;IE8）中一个冒号是伪类，两个冒号是伪元素&lt;/li&gt;&lt;li&gt;由于大量网页仍然使用旧的写法，浏览器为了向后兼容，所以伪元素可以使用一个冒号或两个冒号，两种都可以&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;虽然写一个冒号可以减少一个字节，但是如果应用本身并不兼容 IE8 及以下，那么为了让代码更清晰，个人偏向于伪元素应该使用两个冒号。&lt;/p&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;https://www.w3schools.com/css/css_attribute_selectors.asp&quot;&gt;https://www.w3schools.com/css/css_attribute_selectors.asp&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-3&quot;&gt;&lt;a href=&quot;https://stackoverflow.com/a/5578880/3821392&quot;&gt;https://stackoverflow.com/a/5578880/3821392&lt;/a&gt;&lt;a href=&quot;#fnref-3&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-4&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes&lt;/a&gt;&lt;a href=&quot;#fnref-4&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-5&quot;&gt;&lt;a href=&quot;https://css-tricks.com/to-double-colon-or-not-do-double-colon/&quot;&gt;https://css-tricks.com/to-double-colon-or-not-do-double-colon/&lt;/a&gt;&lt;a href=&quot;#fnref-5&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[git重写历史]]></title><description><![CDATA[前几天在家写公司的代码，自己电脑上 git 全局设置用的是私人邮箱，太懒了懒得改，直接 commit 以后被公司的 bot check 到是非公司邮箱提交的代码，PR 都不让开，真是很严格呢，气人 😤 以前只知道怎么修改单个 commit 的信息，而且只知道用 git…]]></description><link>https://hiitea.io/2019/05/15/git-rewrite-history/</link><guid isPermaLink="false">https://hiitea.io/2019/05/15/git-rewrite-history/</guid><pubDate>Wed, 15 May 2019 15:50:46 GMT</pubDate><content:encoded>&lt;p&gt;前几天在家写公司的代码，自己电脑上 git 全局设置用的是私人邮箱，太懒了懒得改，直接 commit 以后被公司的 bot check 到是非公司邮箱提交的代码，PR 都不让开，真是很严格呢，气人 😤&lt;/p&gt;&lt;p&gt;以前只知道怎么修改单个 commit 的信息，而且只知道用&lt;code&gt;git commit --amend&lt;/code&gt;修改最新提交的 commit。学习了一下怎么修改多个 commit 的提交信息以及如何重设作者。&lt;/p&gt;&lt;h2&gt;修改多个 commit 的提交信息&lt;/h2&gt;&lt;p&gt;如果是要调整顺序啊之类的需求，都知道要用&lt;code&gt;git rebase -i&lt;/code&gt;啦，弹出的编辑窗口中，以前只会用&lt;code&gt;pick&lt;/code&gt; &lt;code&gt;squash&lt;/code&gt; &lt;code&gt;fixup&lt;/code&gt; &lt;code&gt;drop&lt;/code&gt;，其他的基本上不清楚不了解不关心…那么怎么修改作者呢？&lt;/p&gt;&lt;ol&gt;&lt;li&gt;把需要修改的 commit 前面改成&lt;code&gt;edit&lt;/code&gt;并保存&lt;/li&gt;&lt;li&gt;之后 cmd 就会跳到最早的那个 commit，&lt;code&gt;git commit --amend --no--edit --author &amp;quot;aa &amp;lt;aa@aa.com&amp;gt;&amp;quot;&lt;/code&gt; (using the standard &lt;code&gt;A U Thor &amp;lt;author@example.com&amp;gt;&lt;/code&gt; format)&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;git rebase --continue&lt;/code&gt; 然后会跳到下一个刚刚标记为&lt;code&gt;edit&lt;/code&gt;的 commit，重复第二步，直到所有 commit 都修改完成即可&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;p.s. 刚刚上面提到，要使用&lt;code&gt;A U Thor &amp;lt;author@example.com&amp;gt;&lt;/code&gt;格式，这到底是什么鬼格式呢？根本搜不到什么是&lt;code&gt;A U Thor&lt;/code&gt;, 测试了一下，大概应该是说：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;first name, second name, last name 之间用空格隔开&lt;/li&gt;&lt;li&gt;email 要用&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;括起来&lt;/li&gt;&lt;li&gt;名字和 email 之间要有空格&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;然而好像还是不 work，因为虽然 author 改了，但是 committer 的信息，还是没有变化。而且刚刚的 step2 中，每次都要输入名字和邮箱，真是好麻烦啊，有没有什么更好的办法呢？👇&lt;/p&gt;&lt;h2&gt;修改 commit 作者&lt;/h2&gt;&lt;p&gt;针对 repo 设置 committer，再&lt;code&gt;--reset-author&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ git config --local user.name &amp;quot;John Doe&amp;quot;
$ git config --local user.email johndoe@example.com
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;大家应该都见过类似的设置，通常刚刚安装 git 的时候，都会设置一个&lt;code&gt;--global&lt;/code&gt;的 config，将 global 换做&lt;code&gt;--local&lt;/code&gt;就可以只针对某个 repo 设置 committer 用户的相关信息&lt;/p&gt;&lt;p&gt;设置好之后，还是需要根据刚才的 3 个 step，其中 1，3 步都相同，只是第二步的步骤改成&lt;code&gt;git commit --amend --no-edit --reset-author&lt;/code&gt;即可&lt;/p&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://git-scm.com/docs/git-commit#Documentation/git-commit.txt---authorltauthorgt&quot;&gt;https://git-scm.com/docs/git-commit#Documentation/git-commit.txt---authorltauthorgt&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[快速排序]]></title><description><![CDATA[算法渣渣的我，一直不理解，为什么我们要学排序算法，毕竟这么多年的前端工作中，没有什么是一句  Array.prototype.sort…]]></description><link>https://hiitea.io/2019/04/04/quick-sort/</link><guid isPermaLink="false">https://hiitea.io/2019/04/04/quick-sort/</guid><pubDate>Thu, 04 Apr 2019 15:41:10 GMT</pubDate><content:encoded>&lt;p&gt;算法渣渣的我，一直不理解，为什么我们要学排序算法，毕竟这么多年的前端工作中，没有什么是一句 &lt;code&gt;Array.prototype.sort&lt;/code&gt; 解决不了的排序，如果有，那就来两句！&lt;/p&gt;&lt;p&gt;看了入门算法书，我的脑子就是比较线性不抽象的，但凡涉及到递归我就开始无法理解了:(，至于为啥会有排序算法，我的理解是，数据结构和排序是搜索的基石，正确的数据结构搭配恰当的排序算法能让搜索事半功倍，不过我们前端还是不太用得到这些知识吧，虽然各种 framework，比如 react 的 virtual dom diff 应该是用到了，但我们写 application 的，还是用不到啊。&lt;/p&gt;&lt;h2&gt;快速排序详解&lt;/h2&gt;&lt;p&gt;快速排序是基于分治（divide and conquer）的思想，通俗的说就是中国人常说的“大事化小，小事化了”。&lt;/p&gt;&lt;p&gt;总的来说快排的过程非常简单，将数组递归分割为&lt;strong&gt;基准值&lt;/strong&gt;，&lt;strong&gt;小于基准值的部分&lt;/strong&gt;，&lt;strong&gt;大于基准值的部分&lt;/strong&gt;，&lt;/p&gt;&lt;ol&gt;&lt;li&gt;选择基准值&lt;/li&gt;&lt;li&gt;将比基准值小的都排在前面&lt;/li&gt;&lt;li&gt;将比基准值大的都排在后面&lt;/li&gt;&lt;li&gt;针对 2, 3 持续重复 1-3 步，直到可分割的数组只包含零个或一个元素&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;const qsort = (arr) =&amp;gt; {
  if (arr.length &amp;lt;= 1) return arr; // 基线条件

  // 用于储存分割数组
  const left = [];
  const right = [];

  const pivotIndex = 0;
  const [pivot] = arr.splice(pivotIndex, 1); // 选取基准值

  // 分割数组
  arr.forEach((i) =&amp;gt; {
    if (i &amp;lt; pivot) {
      left.push(i);
    } else {
      right.push(i);
    }
  });

  // 递归分割已分割数组
  return [...qsort(left), pivot, ...qsort(right)];
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上是最基本的快排，需要占用额外的两个数组空间。&lt;/p&gt;&lt;p&gt;在学习快排的过程中，还了解到了快排的优化版本，以及其他的实现方法，比如填坑法，基于交换的快排等等，暂时还没看明白:( 再接再厉！&lt;/p&gt;</content:encoded></item><item><title><![CDATA[css长度单位及font-size]]></title><description><![CDATA[长度单位 字体相对长度 em - 通常 1em = 16px；但如果父元素设置了 font-size，则 1em=1 倍父元素的字体大小
rem - 根元素的 font-size，根元素通常为 <html> ch - 0 字的宽度
ex - x 小写字母的高度 viewport…]]></description><link>https://hiitea.io/2019/03/29/css-length/</link><guid isPermaLink="false">https://hiitea.io/2019/03/29/css-length/</guid><pubDate>Fri, 29 Mar 2019 02:51:55 GMT</pubDate><content:encoded>&lt;h2&gt;长度单位&lt;/h2&gt;&lt;h3&gt;字体相对长度&lt;/h3&gt;&lt;p&gt;em - 通常 1em = 16px；但如果父元素设置了 font-size，则 1em=1 倍父元素的字体大小
rem - 根元素的 font-size，根元素通常为&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;ch - 0 字的宽度
ex - x 小写字母的高度&lt;/p&gt;&lt;h3&gt;viewport 百分比长度&lt;/h3&gt;&lt;p&gt;vh 1%的视窗高度
vw 1%的视窗宽度&lt;/p&gt;&lt;p&gt;vmax - vm 和 vh 中较大值
vmin - vm 和 vh 中较小值&lt;/p&gt;&lt;h3&gt;绝对长度&lt;/h3&gt;&lt;p&gt;1px 对应屏幕中的一个点的大小
1cm = 96px/2.54 厘米
1mm = 1/10cm 毫米
1in = 2.54cm - 通常等于 96px，但不同浏览器中可能不同
1pc = 12pt
1pt = 1/72in - 转换为对应的&lt;code&gt;px&lt;/code&gt;时，则与 dpi(dots per inch)有关；使用 pt 为单位能确保在不同设备上字体大小看起来是一样的，而使用 px 为单位，则可能因为设备的分辨率不同而导致字体大小不同。&lt;/p&gt;&lt;h2&gt;font-size 字体大小&lt;/h2&gt;&lt;p&gt;font-size 的单位可以为以上长度单位 或 百分比%，通常&lt;code&gt;1em = 12pt = 16px = 100%&lt;/code&gt;&lt;/p&gt;&lt;h3&gt;&lt;code&gt;em&lt;/code&gt; vs &lt;code&gt;%&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;通常来说没有区别，但当用户设置浏览器字体大小时，则会出现显著的差别。当浏览器设为&amp;#x27;字体最小&amp;#x27;时，1em 比 100%看起来更小；而
当浏览器设为&amp;#x27;字体最大&amp;#x27;时，1em 比 100%看起来更大。虽然&lt;code&gt;em&lt;/code&gt;在 web 设计中更常用，但&lt;code&gt;%&lt;/code&gt;能够提供更加一致的体验。&lt;/p&gt;&lt;p&gt;桌面浏览器默认字体大小为&lt;code&gt;16px&lt;/code&gt;, 所以未经调整的浏览器在显示&lt;code&gt;1em=16px&lt;/code&gt;，也就是说&lt;code&gt;1px=0.0625em&lt;/code&gt;。为了简化 font-size 的换算，可以在 css 中的 body 中先全局声明&lt;code&gt;font-size=62.5%&lt;/code&gt;，也就是定义了默认字体大小为 16px*0.625=10px,子元素会继承父级元素的字体大小，于是 1em=10px&lt;/p&gt;&lt;h3&gt;62.5% vs 10px&lt;/h3&gt;&lt;p&gt;Q: 为什么是&lt;code&gt;font-size: 62.5%&lt;/code&gt;而不是&lt;code&gt;font-size: 10px&lt;/code&gt;?
A: 在不同的设备中，默认字体大小可能不同，10px 的大小在对于高 dpi 的设备可能看起来非常小，并非我们想要的效果，因此使用百分比根据默认字体的大小来设置其他字体的大小会得到更好的体验。&lt;/p&gt;&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;★☆☆ &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/length&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/CSS/length&lt;/a&gt;&lt;/li&gt;&lt;li&gt;★★★ &lt;a href=&quot;https://kyleschaeffer.com/css-font-size-em-vs-px-vs-pt-vs-percent&quot;&gt;https://kyleschaeffer.com/css-font-size-em-vs-px-vs-pt-vs-percent&lt;/a&gt;&lt;/li&gt;&lt;li&gt;★★☆ &lt;a href=&quot;https://segmentfault.com/q/1010000002411895&quot;&gt;https://segmentfault.com/q/1010000002411895&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[git bisect 二分法查找问题commit]]></title><description><![CDATA[前几天刚看到一个 git command:  git bisect ，万万没想到居然这么快就用上了，真是尴尬。更尴尬的是，debug 了半天最后发现是自己的 commit…]]></description><link>https://hiitea.io/2018/11/29/git-bisect/</link><guid isPermaLink="false">https://hiitea.io/2018/11/29/git-bisect/</guid><pubDate>Thu, 29 Nov 2018 03:47:01 GMT</pubDate><content:encoded>&lt;p&gt;前几天刚看到一个 git command: &lt;code&gt;git bisect&lt;/code&gt;，万万没想到居然这么快就用上了，真是尴尬。更尴尬的是，debug 了半天最后发现是自己的 commit 出问题 😆&lt;/p&gt;&lt;p&gt;在软件开发的过程中，由于测试覆盖率低，没时间回归测试等等原因，经常会遇到一种情况就是，某个 feature 明明前几天还好好的，不知道从什么时候开始就出 Bug 了……然后 hmm，最笨的方法就是倒回去一个一个 commit 的 checkout 出来查找啦，稍微没那么笨的方法就是跟版本来查找，然后手动人工用二分法（我以前就一直是这么做的，还以为自己很聪明呢，数 commit 数到头晕 😂）&lt;/p&gt;&lt;h2&gt;git bisect&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;This command uses a binary search algorithm to find which commit in your project’s history introduced a bug. &lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;git bisect&lt;/code&gt;做的事情其实就跟人手做的事情本质是一样的，只不过不用自己去数 commit，command 会自动定位到二分法区间中点的 commit 并 checkout&lt;/p&gt;&lt;p&gt;举个 🌰：
假如在 develop 分支中有 ABCDEFG 这几个 commit，A 最新，G 最旧，已 A 有 bug 但 G 没有 bug，想要找出 A-G 中最早出现 bug 的 commit，假设最终找到有 bug 的 commit 是 E。&lt;/p&gt;&lt;p&gt;那么首先 checkout develop 分支，然后&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git bisect start
git bisect bad
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后 checkout G commit&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git bisect good
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时 git 会自动 checkout D commit 并显示还剩下 3 个 commit 需要检查，然后我们不停的重复以上标记&lt;code&gt;good&lt;/code&gt;和&lt;code&gt;bad&lt;/code&gt;的步骤，直到找出有问题的 commit E，此时会显示还剩下 0 个 commit 需要检查， 记下这个 commit 的 hash（不知道这一步有没有什么自动记下的方法？），然后&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git bisect reset
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后会自动回到 develop 分支，然后就可以开始 fixup 了。&lt;/p&gt;&lt;p&gt;以上。&lt;/p&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://git-scm.com/docs/git-bisect&quot;&gt;https://git-scm.com/docs/git-bisect&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[取模(mod)和取余(rem) 在数学和计算机中的不同]]></title><description><![CDATA[(前几天心情差到爆:(，今天终于心情明媚可以填坑了) 我第一次知道不同语言对于 mod 的不同实现会导致结果不同，真是黑人问号…然后又了解到，在计算机界，取模和取余大都是混为一谈的… 了解取模和取余问题的起因是，想要实现类似循环链表中 tail.next === head…]]></description><link>https://hiitea.io/2018/11/20/remainder-and-modulo/</link><guid isPermaLink="false">https://hiitea.io/2018/11/20/remainder-and-modulo/</guid><pubDate>Tue, 20 Nov 2018 04:18:29 GMT</pubDate><content:encoded>&lt;p&gt;(前几天心情差到爆:(，今天终于心情明媚可以填坑了)&lt;/p&gt;&lt;p&gt;我第一次知道不同语言对于&lt;code&gt;mod&lt;/code&gt;的不同实现会导致结果不同，真是黑人问号…然后又了解到，在计算机界，取模和取余大都是混为一谈的…&lt;/p&gt;&lt;p&gt;了解取模和取余问题的起因是，想要实现类似循环链表中&lt;code&gt;tail.next === head&lt;/code&gt;, &lt;code&gt;head.prev === tail&lt;/code&gt; 的类似功能，由于平时都会用一些 ramda, lodash 之类的 util 库，所以也没想着用 js 自带的&lt;code&gt;%&lt;/code&gt;，而是直接用了&lt;code&gt;R.mathMod&lt;/code&gt;&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，并且完全没有意识到这两个运算的结果会不同。&lt;/p&gt;&lt;p&gt;先看个 🌰&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;-5 % 3; // ➡&amp;gt; -2
R.mathMod(-5, 3); // -&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通常情况下，正数都是没问题的，一般也很少考虑负数的情况，但一旦遇上需要使用负数的时候，就一定掉坑(pitfalls)里了。JS 的话还可以说是不同库的实现方法不同导致结果不同，但是在不同语言里，比如 Python 里和 JS 里，同样是&lt;code&gt;-5 % 2&lt;/code&gt;，Python 返回的结果是&lt;code&gt;1&lt;/code&gt;？！&lt;/p&gt;&lt;p&gt;在数学界，取余的方法是统一的，其结果是欧几里得除法(Euclidean division)的余数&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;；而计算机界，由于编程语言的实现不同或者硬件的不同会导致结果不同。&lt;/p&gt;&lt;p&gt;不过所有的求余方法都满足以下 3 点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;a = n * q +r&lt;/li&gt;&lt;li&gt;q ∈ Z (q 属于整数集合)&lt;/li&gt;&lt;li&gt;&lt;code&gt;|r| &amp;lt; |n|&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;但是仅满足这三点的话，当遇到负数时，还是会有正负号的问题，余数的符号到底跟除数还是被除数呢？可能这也是为什么会有不同结果的原因，毕竟这个定义就是不完善的。&lt;/p&gt;&lt;h2&gt;欧几里得除法 Euclidean division&lt;/h2&gt;&lt;p&gt;欧几里得除法中定义，余数永远不为负，r≥0。然后经过哐哐一顿推倒，最终：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;r = a - |n| * floor(a/|n|)

e.g.
1 = 7 - |-3| * floor(7 / |-3|) -&amp;gt; 7 - 6
2 = -7 - 3 * floor( (-7) / 3)  -&amp;gt; -7 - (-9)
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;截断除法 truncated division&lt;/h2&gt;&lt;p&gt;截断除法中，商向 0 取整，余数可以为负，JS 中的&lt;code&gt;%&lt;/code&gt;使用该定义&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;r = a - n * trunc(a/n)

e.g.
 1 = 7 - (-3) * trunc(7/(-3)) -&amp;gt; 7 - (-3) * (-2)
-1 = -7 - 3 * trunc((-7)/3) -&amp;gt; - 7 - (3) * (-2)
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;取底除法 floored division&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;r = a - n * floor(a/n)

e.g.
-2 = 7 - (-3) * (-3)
2 = (-7) - 3 *(-3)
1 = 7 - 3 * 2
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;常见问题&lt;/h2&gt;&lt;p&gt;判断一个数是否为奇数的时候，通常都会想到&lt;code&gt;x%2===1&lt;/code&gt;，当 x 为负的奇数时，使用这个等式就有问题了…当然啦，不考虑正负数又要正确判断的最简单的还是使用偶数大法，永远也不会出错&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function is_odd(x) {
  return x % 2 !== 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;其他&lt;/h2&gt;&lt;p&gt;在不同的语言或库中可能存在各种情况，使用的时候需要特别留意：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;有些语言中，被除数(dividend)可以为负，但除数(divisor)不能为负。e.g. &lt;code&gt;R.mathMod(7,-3) -&amp;gt; NaN&lt;/code&gt;&lt;/li&gt;&lt;li&gt;有些语言中，可能会有&lt;code&gt;mod&lt;/code&gt;、&lt;code&gt;rem&lt;/code&gt;两种方法来区分截断除法和欧几里得除法的不同结果&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;wiki 抄来的图，红色为商，绿色为余数，其实我不是很看得懂 😅
&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/2/22/Divmod.svg/250px-Divmod.svg.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;&lt;p&gt;总的来说，求商的时候会分为向零取整、向下取整、欧几里得除法，读书的时候就最烦数学定义这种东西了，然而现在发现“定义”才是一切的根本，真是悔不当初…&lt;/p&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://ramdajs.com/docs/#mathMod&quot;&gt;https://ramdajs.com/docs/#mathMod&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Modulo_operation#Remainder_calculation_for_the_modulo_operation&quot;&gt;https://en.wikipedia.org/wiki/Modulo_operation#Remainder_calculation_for_the_modulo_operation&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[关于eventListener的那些事]]></title><description><![CDATA[If multiple identical  EventListeners  are registered on the same  EventTarget  with the same parameters, the duplicate instances are…]]></description><link>https://hiitea.io/2018/08/22/event-listener/</link><guid isPermaLink="false">https://hiitea.io/2018/08/22/event-listener/</guid><pubDate>Wed, 22 Aug 2018 03:41:52 GMT</pubDate><content:encoded>&lt;blockquote&gt;&lt;p&gt;If multiple identical &lt;code&gt;EventListeners&lt;/code&gt; are registered on the same &lt;code&gt;EventTarget&lt;/code&gt; with the same parameters, the duplicate instances are discarded. They do not cause the &lt;code&gt;EventListener&lt;/code&gt; to be called twice, and they do not need to be removed manually with the &lt;code&gt;removeEventListener()&lt;/code&gt; method. &lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;如果在同一个&lt;code&gt;EventTarget&lt;/code&gt;上添加同一个（reference 相同）&lt;code&gt;EventListeners&lt;/code&gt;，该 listener 只会执行一次，无需手动调用&lt;code&gt;removeEventListener&lt;/code&gt;移除多余的 listener&lt;/p&gt;&lt;p&gt;所以在&lt;code&gt;addEventListener&lt;/code&gt;时应尽量&lt;strong&gt;避免使用匿名函数&lt;/strong&gt;的形式，而应该引用已定义好的函数，从而避免之后重复添加 listener 时被重复执行多次，并且也为&lt;code&gt;removeListener&lt;/code&gt;提供可能性&lt;/p&gt;&lt;h2&gt;getEventListeners&lt;/h2&gt;&lt;p&gt;有时候我们会想知道 document 里的全部或某个 object 上面都绑定了什么 listener，除了自己写一段代码去查看之外，chrome dev tools 也为我们提供了一些方便的接口&lt;sup id=&quot;fnref-3&quot;&gt;&lt;a href=&quot;#fn-3&quot; class=&quot;footnote-ref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;h3&gt;查看 document 中的所有 listener&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://gist.github.com/dmnsgn/36b26dfcd7695d02de77f5342b0979c7&quot;&gt;https://gist.github.com/dmnsgn/36b26dfcd7695d02de77f5342b0979c7&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;使用 chrome 查看单个 object 上的 listener&lt;/h3&gt;&lt;p&gt;直接在 chrome 的 console 中使用&lt;code&gt;getEventListeners&lt;/code&gt;接口即可&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;getEventListeners(document);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果想知道 listener 的函数源码，可以对该 listener 右键选择 &lt;strong&gt;store as global variable&lt;/strong&gt;， chrome 会将其储存为名为&lt;code&gt;tempX&lt;/code&gt;的变量(X 为正整数)，并打印出该变量内容，即可看到 listener 函数的具体代码&lt;/p&gt;&lt;h2&gt;addEventListener&lt;/h2&gt;&lt;p&gt;大多数时候我们在&lt;code&gt;addEventListener&lt;/code&gt;时，都会省略第三个参数&lt;code&gt;options&lt;/code&gt;。要了解&lt;code&gt;options&lt;/code&gt;中的各项参数有什么用途，首先我们需要了解，事件冒泡(Event Bubbling)和事件捕捉(Event Capturing)的执行顺序&lt;sup id=&quot;fnref-4&quot;&gt;&lt;a href=&quot;#fn-4&quot; class=&quot;footnote-ref&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;h3&gt;事件冒泡 事件捕捉&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://mdn.mozillademos.org/files/14075/bubbling-capturing.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;&lt;p&gt;当触发一个 event 时，现代浏览器可以有两种执行模式/顺序，默认为&lt;strong&gt;事件冒泡&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;事件冒泡，由下至上，child 向 ancestor 依次查找 eventListner 并执行&lt;/li&gt;&lt;li&gt;事件捕捉，由顶至下，由最外层 ancestor 向 child 依次查找、执行， (until it reaches the element that was actually clicked on)&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;code&gt;options&lt;/code&gt;&lt;sup id=&quot;fnref-5&quot;&gt;&lt;a href=&quot;#fn-5&quot; class=&quot;footnote-ref&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;options&lt;/code&gt;包括以下几个选项：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;capture&lt;/code&gt;，如果为&lt;code&gt;true&lt;/code&gt;，该 event 会最先 dispatch。 &lt;strong&gt; before any other children doms&amp;#x27; same event &lt;/strong&gt; 如同上一节所提到的，如果设置为&lt;code&gt;true&lt;/code&gt;，浏览器会按照事件捕捉的顺序来执行相关 listener&lt;/li&gt;&lt;li&gt;&lt;code&gt;once&lt;/code&gt;，如果为&lt;code&gt;true&lt;/code&gt;，listener 最多只会执行一次，之后会自动移除&lt;/li&gt;&lt;li&gt;&lt;code&gt;passive&lt;/code&gt;，如果为&lt;code&gt;true&lt;/code&gt;，不会调用&lt;code&gt;preventDefault()&lt;/code&gt;，如果该方法被调用，则该方法会被忽略且抛出警告 ⚠️。&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;Unable to preventDefault inside passive event listener invocation.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;passive&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;时，&lt;code&gt;touch&lt;/code&gt;event 会阻塞浏览器的主线程，从而影响 scroll 的性能，因此一些浏览器(chrome, firefox)将&lt;code&gt;touchstart&lt;/code&gt; &lt;code&gt;touchemove&lt;/code&gt;事件在&lt;code&gt;window&lt;/code&gt; &lt;code&gt;document&lt;/code&gt; &lt;code&gt;document.body&lt;/code&gt;级别的&lt;code&gt;passive&lt;/code&gt;默认值设为&lt;code&gt;true&lt;/code&gt; &lt;sup id=&quot;fnref-6&quot;&gt;&lt;a href=&quot;#fn-6&quot; class=&quot;footnote-ref&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;MDN 的这个例子非常好的解释了各种 option 搭配下的各种情况
&lt;a href=&quot;https://jsfiddle.net/HiiTea/m2vha9sj/embedded/result,html,js&quot;&gt;https://jsfiddle.net/HiiTea/m2vha9sj/embedded/result,html,js&lt;/a&gt;&lt;/p&gt;&lt;p&gt;另外需要注意的是，我们经常看到这样的写法：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;element.addEventListener(&amp;#x27;click&amp;#x27;, myClickHandler, false);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第三个参数并非一个&lt;code&gt;object&lt;/code&gt;，而是一个&lt;code&gt;boolean&lt;/code&gt;，这样的写法是为了兼容一些旧的浏览器，当使用这样的写法时，第三个参数&lt;code&gt;false&lt;/code&gt;指代的是&lt;code&gt;capture&lt;/code&gt;参数&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options’s capture. &lt;sup id=&quot;fnref-7&quot;&gt;&lt;a href=&quot;#fn-7&quot; class=&quot;footnote-ref&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;IE&lt;/h3&gt;&lt;p&gt;IE9 之前，没有&lt;code&gt;addEventListener&lt;/code&gt;方法，需要使用&lt;code&gt;attachEvent&lt;/code&gt;方法代替，该方法不接受第三个参数 &lt;sup id=&quot;fnref-8&quot;&gt;&lt;a href=&quot;#fn-8&quot; class=&quot;footnote-ref&quot;&gt;8&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;h2&gt;removeListener&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;While &lt;code&gt;addEventListener()&lt;/code&gt; will let you add the same listener more than once for the same type if the options are different, the only option &lt;code&gt;removeEventListener()&lt;/code&gt; checks is the capture/useCapture flag. Its value must match for &lt;code&gt;removeEventListener()&lt;/code&gt; to match, but the other values don&amp;#x27;t. &lt;sup id=&quot;fnref-9&quot;&gt;&lt;a href=&quot;#fn-9&quot; class=&quot;footnote-ref&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这个就是说，如果在&lt;code&gt;addEventListener&lt;/code&gt;是添加了某些&lt;code&gt;options&lt;/code&gt;，那么移除时也需要添加相应的&lt;code&gt;options&lt;/code&gt;才能成功移除 listener 😭 真是麻烦&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;document.addEventListener(&amp;#x27;click&amp;#x27;, handler, { passive: true });
document.removeEventListener(&amp;#x27;click&amp;#x27;, handler); // fails
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Multiple_identical_event_listeners#Multiple_identical_event_listeners&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Multiple_identical_event_listeners#Multiple_identical_event_listeners&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-3&quot;&gt;&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/console/command-line-reference&quot;&gt;https://developers.google.com/web/tools/chrome-devtools/console/command-line-reference&lt;/a&gt;&lt;a href=&quot;#fnref-3&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-4&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture&quot;&gt;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture&lt;/a&gt;&lt;a href=&quot;#fnref-4&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-5&quot;&gt;&lt;a href=&quot;https://developers.google.com/web/updates/2016/10/addeventlistener-once&quot;&gt;https://developers.google.com/web/updates/2016/10/addeventlistener-once&lt;/a&gt;&lt;a href=&quot;#fnref-5&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-6&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners&lt;/a&gt;&lt;a href=&quot;#fnref-6&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-7&quot;&gt;&lt;a href=&quot;https://dom.spec.whatwg.org/#interface-eventtarget&quot;&gt;https://dom.spec.whatwg.org/#interface-eventtarget&lt;/a&gt;&lt;a href=&quot;#fnref-7&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-8&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Legacy_Internet_Explorer_and_attachEvent&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Legacy_Internet_Explorer_and_attachEvent&lt;/a&gt;&lt;a href=&quot;#fnref-8&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-9&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener&lt;/a&gt;&lt;a href=&quot;#fnref-9&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[如何延迟加载script(defer, async)]]></title><description><![CDATA[<script> 的下载和执行都会阻塞页面渲染，因此大多数情况下，我们都把 <script> 放在 <body> 的底部，渲染完前面的 html 内容之后才加载和执行 JS。 然而有时由于某些限制，只把某些 <script> 放在 <head…]]></description><link>https://hiitea.io/2018/05/31/script-defer-async/</link><guid isPermaLink="false">https://hiitea.io/2018/05/31/script-defer-async/</guid><pubDate>Thu, 31 May 2018 07:18:29 GMT</pubDate><content:encoded>&lt;p&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;的下载和执行都会阻塞页面渲染，因此大多数情况下，我们都把&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;放在&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;的底部，渲染完前面的 html 内容之后才加载和执行 JS。&lt;/p&gt;&lt;p&gt;然而有时由于某些限制，只把某些&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;放在&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;里，但又不希望页面渲染被阻塞，这种情况下，可以使用&lt;code&gt;async&lt;/code&gt;或&lt;code&gt;defer&lt;/code&gt;属性来延迟加载、渲染。&lt;/p&gt;&lt;p&gt;一张图胜过千言万语&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;
&lt;img src=&quot;https://i.stack.imgur.com/wfL82.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;code&gt;&amp;lt;script/&amp;gt;&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;如果没有加任何与延迟加载相关的属性，浏览器会先加载、然后执行。这个过程会阻塞后面内容的渲染，也就是说，要等&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;加载并执行之后，才会开始渲染之后的内容。&lt;/p&gt;&lt;h4&gt;原因&lt;/h4&gt;&lt;p&gt;因为可能存在类似需求：在执行脚本时，使用&lt;code&gt;document.write&lt;/code&gt;，因此需要阻塞渲染&lt;/p&gt;&lt;h3&gt;async&lt;/h3&gt;&lt;p&gt;如果添加了&lt;code&gt;async&lt;/code&gt;属性，浏览器会并行的一边渲染页面一边加载脚本。一旦脚本加载完成，就会执行脚本，执行脚本的过程会阻塞后续内容的渲染。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;!!!注意: 由于是加载完成就立刻执行，因此执行顺序是无法保证的！&lt;/strong&gt;
&lt;code&gt;async&lt;/code&gt;是 html5 中才有的属性，因此需要注意旧的浏览器不支持此属性&lt;/p&gt;&lt;h3&gt;defer&lt;/h3&gt;&lt;p&gt;如果添加了&lt;code&gt;defer&lt;/code&gt;属性，浏览器会并行的一边渲染页面一边加载脚本。等到页面内容完全渲染完成之后才开始执行，能够节约一点加载时间（因为是并行的）。这么看来使用&lt;code&gt;defer&lt;/code&gt;跟放在&lt;code&gt;body&lt;/code&gt;底部效果差不多，甚至更胜一筹，那么为什么现在还有很多人还在使用后者(body 底部)这种方式呢，这两种方式到底有什么区别呢？&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;h2&gt;历史小知识&lt;/h2&gt;&lt;p&gt;最早实现&lt;code&gt;defer&lt;/code&gt;的是 IE4，然而在 IE4-9 中的实现并没有按照 WHATWG 的标准&lt;sup id=&quot;fnref-3&quot;&gt;&lt;a href=&quot;#fn-3&quot; class=&quot;footnote-ref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;，这个 bug 使得执行脚本时的&lt;strong&gt;顺序无法得到保证&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;deferred scripts should run after the document had parsed, in the order they were added. &lt;sup id=&quot;fnref-4&quot;&gt;&lt;a href=&quot;#fn-4&quot; class=&quot;footnote-ref&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;The defer attribute may be specified with the async attribute, so legacy browsers that only support defer (and not async) fall back to the defer behavior instead of the default blocking behavior &lt;sup id=&quot;fnref-4&quot;&gt;&lt;a href=&quot;#fn-4&quot; class=&quot;footnote-ref&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;!!!注意：&lt;/strong&gt;
为了避免在旧的 IE 浏览器上，脚本的执行顺序不符合预期，因此大多数时候还是使用将脚本放在&lt;code&gt;body&lt;/code&gt;底部的方式&lt;/p&gt;&lt;h2&gt;IMPORTANT&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;The &lt;code&gt;defer&lt;/code&gt; and &lt;code&gt;async&lt;/code&gt; attributes &lt;strong&gt;must not&lt;/strong&gt; be specified if the src attribute is &lt;strong&gt;absent&lt;/strong&gt; &lt;sup id=&quot;fnref-5&quot;&gt;&lt;a href=&quot;#fn-5&quot; class=&quot;footnote-ref&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;body bottom&lt;/h3&gt;&lt;p&gt;将&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;放在&lt;code&gt;body&lt;/code&gt;底部，能够保证脚本按照顺序加载及执行，缺点是无法节约加载时间&lt;/p&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://stackoverflow.com/a/39711009/3821392&quot;&gt;https://stackoverflow.com/a/39711009/3821392&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;https://stackoverflow.com/questions/5250412/how-exactly-does-script-defer-defer-work&quot;&gt;https://stackoverflow.com/questions/5250412/how-exactly-does-script-defer-defer-work&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-3&quot;&gt;&lt;a href=&quot;https://www.html5rocks.com/en/tutorials/speed/script-loading/&quot;&gt;https://www.html5rocks.com/en/tutorials/speed/script-loading/&lt;/a&gt;&lt;a href=&quot;#fnref-3&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-4&quot;&gt;&lt;a href=&quot;https://html.spec.whatwg.org/multipage/scripting.html#attr-script-defer&quot;&gt;https://html.spec.whatwg.org/multipage/scripting.html#attr-script-defer&lt;/a&gt;&lt;a href=&quot;#fnref-4&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-5&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement#&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement#&lt;/a&gt;&lt;a href=&quot;#fnref-5&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[使用fixup和auto squash修改git commit]]></title><description><![CDATA[在写程序的过程中，经常遇到一些刚提交了 commit 就发现有个错别字这种尴尬的情况，我以前的做法是 git reset HEAD~1  将 HEAD 指向提交之前的一个 commit 然后改完再重新提交 ‍🤦‍ 除此之外，如果是最新的 commit…]]></description><link>https://hiitea.io/2018/05/21/fixup-and-auto-squash/</link><guid isPermaLink="false">https://hiitea.io/2018/05/21/fixup-and-auto-squash/</guid><pubDate>Mon, 21 May 2018 06:38:40 GMT</pubDate><content:encoded>&lt;p&gt;在写程序的过程中，经常遇到一些刚提交了 commit 就发现有个错别字这种尴尬的情况，我以前的做法是&lt;code&gt;git reset HEAD~1&lt;/code&gt; 将 HEAD 指向提交之前的一个 commit 然后改完再重新提交 ‍🤦‍&lt;/p&gt;&lt;p&gt;除此之外，如果是最新的 commit 中的错误需要修改，其实还可以直接修改，之后使用&lt;code&gt;git add FILE_TO_CHANGE git comit --amend&lt;/code&gt;，既可以修改最后一次提交的内容，也可以修改 commit message。&lt;/p&gt;&lt;p&gt;但还有一些情况是，发现之前的某个 commit 有错别字或 bug，这种情况很多同学（包括我 😂）会开个新的普通的 commit 去 fix，而不是&lt;code&gt;git commit --fixup COMMIT_HASH&lt;/code&gt;&lt;/p&gt;&lt;h3&gt;Conventional Commit &lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;&lt;p&gt;使用 Conventional Commit 的 repo 可以使用 &lt;a href=&quot;https://github.com/conventional-changelog/standard-version&quot;&gt;standard-version&lt;/a&gt; 自动根据 commit message 生成 CHANGELOG，并且自动 bump version。前提是 commit message 需要 follow 相关的一些规定，例如&lt;code&gt;fix: xxx&lt;/code&gt;， &lt;code&gt;feat: xxx&lt;/code&gt;&lt;/p&gt;&lt;p&gt;在使用 Conventional Commit 的 repo 中经常看到 &lt;code&gt;!fixup fix:xxx&lt;/code&gt;这样的 commit，此类 commit 会被忽略，而不会影响生成 CHANGELOG。&lt;/p&gt;&lt;h3&gt;&lt;code&gt;--fixup&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;然而我并不知道有一个 command 是&lt;code&gt;--fixup&lt;/code&gt;，再加上我平时都是用 source tree 之类的图形界面工具，所以每次需要 fix 一个 commit 的时候，都是手写&lt;code&gt;!fixup xx&lt;/code&gt;这样的 message，然后又由于偷懒，也不粘贴复制 fixup 的提交信息，而是直接写一个相似的短一点的信息 🤦‍ （估计这样应该会导致无法&lt;code&gt;autosquash&lt;/code&gt;）&lt;/p&gt;&lt;h4&gt;正确的使用方法及流程&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;git commit --fixup fb2f677&lt;/code&gt;
假设 fixup 后 git log 如下&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;c5069d5 fixup! Feature A is done
733e2ff Feature B is done
fb2f677 Feature A is done
ac5db87 Previous commit
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;git rebase -i --autosquash ac5db87&lt;/code&gt;
需要注意，&lt;code&gt;autosquash&lt;/code&gt;后面的 hash 必须是将要 squash 的 commit 的前一个&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;patch&lt;/h3&gt;&lt;p&gt;可能现在的 web 开发中很少用到 patch 了，我反正一次也没用过，也没听别人说用过，可能在 APP 或者客户端中比较常用到吧。&lt;/p&gt;&lt;p&gt;这个功能的作用是能够生成一个补丁文件，用&lt;code&gt;git apply ./xx.patch&lt;/code&gt; 可以将补丁打到当前的 repo 中。&lt;/p&gt;&lt;p&gt;在没有 github 之前的时候，可能人们是通过这种方式玩开源的吧…发现别人有 bug，修复之后如果直接发源文件实在太大大麻烦了，于是打一个补丁用 email 发出去给作者…感谢 gayhub 的出现，让我们这些小白参与开源社区的门槛降低也很多，操作也方便了很多，真是科技改变生活 :)&lt;/p&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://conventionalcommits.org/&quot;&gt;https://conventionalcommits.org/&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;https://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html&quot;&gt;https://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[开发时如何使用本地npm包作为依赖]]></title><description><![CDATA[这个问题我已经遇到两次了。 第一次是我发布了 react-aplayer （第一次发布 npm 包，好紧张）,然后有人提 issue 说 npm install 后用不了。我自己在本地开发 demo 的时候是直接引用 ./src ，没有试过真的当做一个 package…]]></description><link>https://hiitea.io/2018/05/15/npm-local-pacakge-as-dependency/</link><guid isPermaLink="false">https://hiitea.io/2018/05/15/npm-local-pacakge-as-dependency/</guid><pubDate>Tue, 15 May 2018 07:01:19 GMT</pubDate><content:encoded>&lt;p&gt;这个问题我已经遇到两次了。&lt;/p&gt;&lt;p&gt;第一次是我发布了&lt;a href=&quot;https://github.com/MoePlayer/react-aplayer&quot;&gt;react-aplayer&lt;/a&gt;（第一次发布 npm 包，好紧张）,然后有人提 issue 说&lt;code&gt;npm install&lt;/code&gt;后用不了。我自己在本地开发 demo 的时候是直接引用&lt;code&gt;./src&lt;/code&gt;，没有试过真的当做一个 package 来使用，所以我用的时候是没问题的 😅&lt;/p&gt;&lt;p&gt;第二次就是我们有一个把所有 API 包起来的 package，所有请求都添加到这个 package 里来做，于是除了要写主要的 application 还要维护这个 package，需要测试这个 package 是否能够正常使用。&lt;/p&gt;&lt;p&gt;根据 Stackoverflow&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，在本地使用本地 package 作为 dependency 有很多方法可以实现，我经常用到的是&lt;code&gt;npm link&lt;/code&gt;，暂时也还没有遇到什么奇奇怪怪的问题。&lt;/p&gt;&lt;p&gt;官方的例子&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;已经说的很清楚了，这里就不赘述了&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd ~/projects/node-redis    # go into the package directory
npm link                    # creates global link 先在dependency里创建link
cd ~/projects/node-bloggy   # go into some other package directory.
npm link redis              # link-install the package 然后在主项目里安装已连接的dependency
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://stackoverflow.com/questions/15806241/how-to-specify-local-modules-as-npm-package-dependencies&quot;&gt;https://stackoverflow.com/questions/15806241/how-to-specify-local-modules-as-npm-package-dependencies&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;https://docs.npmjs.com/cli/link&quot;&gt;https://docs.npmjs.com/cli/link&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Object.is()]]></title><description><![CDATA[前几天写测试的时候，有个地方需要检查 Object 的 reference 是否改变，jest 中的 toEqual(value) 是 deep compare，不适用于 reference，于是查看了一下应该使用 toBe(value) 。 toBe  just checks…]]></description><link>https://hiitea.io/2018/04/26/Object-is/</link><guid isPermaLink="false">https://hiitea.io/2018/04/26/Object-is/</guid><pubDate>Thu, 26 Apr 2018 04:25:15 GMT</pubDate><content:encoded>&lt;p&gt;前几天写测试的时候，有个地方需要检查 Object 的 reference 是否改变，jest 中的&lt;code&gt;toEqual(value)&lt;/code&gt;是 deep compare，不适用于 reference，于是查看了一下应该使用&lt;code&gt;toBe(value)&lt;/code&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;toBe&lt;/code&gt; just checks that a value is what you expect. It uses &lt;code&gt;Object.is&lt;/code&gt; to check exact equality.&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;以前没见过也没用过&lt;code&gt;Object.is&lt;/code&gt;，查了一下发现是 ES6 的新语法&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;h3&gt;&lt;code&gt;Object.is(val1, val2)&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Object.is&lt;/code&gt;方法用于比较两个对象是否相同，与&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;===&lt;/code&gt;是有一定区别的&lt;/p&gt;&lt;p&gt;在使用&lt;code&gt;==&lt;/code&gt;时，如果等号两边类型不同，js 会先进行类型转换，再进行值的比较。
而使用&lt;code&gt;===&lt;/code&gt;时，只要类型不同就为 false
&lt;code&gt;Object.is&lt;/code&gt;在大多数情况下可以等同于&lt;code&gt;===&lt;/code&gt;，但有两种情况除外&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;+0&lt;/code&gt; / &lt;code&gt;-0&lt;/code&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;===&lt;/code&gt; 无法区分 &lt;code&gt;+0&lt;/code&gt;和&lt;code&gt;-0&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Object.is(+0, -0)&lt;/code&gt; 返回&lt;code&gt;false&lt;/code&gt; 可以区分&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;ul&gt;&lt;li&gt;无法用&lt;code&gt;===&lt;/code&gt;来进行检查，需要使用&lt;code&gt;isNaN()&lt;/code&gt;方法&lt;/li&gt;&lt;li&gt;但现在也可以用&lt;code&gt;Object.is(NaN, NaN)&lt;/code&gt;来检查&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Magic JS&lt;/h3&gt;&lt;p&gt;原来除了&lt;code&gt;0.1+0.2=0.00000000000034&lt;/code&gt;这样的，还有其他搞笑的事情存在，可能这就是 that&amp;#x27;s why I love js？写的不好的时候就可以 blame 是 JS 辣鸡的原因，哈哈&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;1 === 1;
// true
+0 === -0;
// true
1 / +0 === 1 / -0;
// false
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Infinity &lt;sup id=&quot;fnref-4&quot;&gt;&lt;a href=&quot;#fn-4&quot; class=&quot;footnote-ref&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Infinity&lt;/code&gt;是比任何数都大的&lt;strong&gt;数&lt;/strong&gt;， 在运算上与数学上的 Inf 一样
需要注意：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;Infinity / Infinity&lt;/code&gt; -&amp;gt; &lt;code&gt;NaN&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Number.POSITIVE_INFINITY&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Number.NEGATIVE_INFINITY&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Number.MAX_SAFE_INTEGER &lt;sup id=&quot;fnref-5&quot;&gt;&lt;a href=&quot;#fn-5&quot; class=&quot;footnote-ref&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;&lt;p&gt;本来只是想研究一下&lt;code&gt;Object.is&lt;/code&gt;的，没想到顺带就又引申出了这么多其他的东西…上面提到&lt;code&gt;Infinity&lt;/code&gt;，很容易联想到那么 JS 中最大的数是多大呢
JS 中有&lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt;，其值为&lt;code&gt;2^53 - 1&lt;/code&gt;，对应的最小数&lt;code&gt;Number.MIN_SAFE_INTEGER&lt;/code&gt;，其值为&lt;code&gt;-(2^53 - 1)&lt;/code&gt; 只有在这个范围内的数才能保证一定是正确的。&lt;/p&gt;&lt;p&gt;超出范围的数可能由于精度丢失还是什么别的原因，不一定正确，典型的例子：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2; // true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;🙄&lt;/p&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://facebook.github.io/jest/docs/en/expect.html#tobevalue&quot;&gt;https://facebook.github.io/jest/docs/en/expect.html#tobevalue&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-4&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity&lt;/a&gt;&lt;a href=&quot;#fnref-4&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-5&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER&lt;/a&gt;&lt;a href=&quot;#fnref-5&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[global .gitignore]]></title><description><![CDATA[为什么需要全局  .gitignore 通常来说，在 repo 中提交跟 IDE 相关的文件并非最佳实践，所以大多数时候会在 .gitignore 中加入 IDE 相关的文件 pattern，然而市面上的 IDE 很多，不同程序员对 IDE…]]></description><link>https://hiitea.io/2018/03/27/global-gitignore/</link><guid isPermaLink="false">https://hiitea.io/2018/03/27/global-gitignore/</guid><pubDate>Tue, 27 Mar 2018 04:39:44 GMT</pubDate><content:encoded>&lt;h3&gt;为什么需要全局 &lt;code&gt;.gitignore&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;通常来说，在 repo 中提交跟 IDE 相关的文件并非最佳实践，所以大多数时候会在&lt;code&gt;.gitignore&lt;/code&gt;中加入 IDE 相关的文件 pattern，然而市面上的 IDE 很多，不同程序员对 IDE 也有着自己的偏好，似乎不太可能把市面上所有的 IDE 都列出来。&lt;/p&gt;&lt;p&gt;除此之外，可能还有一些其他情况下，希望在本地 ignore 某些文件，但却不希望提交到远程的&lt;code&gt;.gitignore&lt;/code&gt;中。&lt;/p&gt;&lt;p&gt;这种时候就该 Git 的 &lt;strong&gt;global ignore&lt;/strong&gt; 上场啦！&lt;/p&gt;&lt;p&gt;添加全局&lt;code&gt;gitignore&lt;/code&gt;之后会在本地所有的 repo 中都 ignore 在其中列出的文件，以达到本地忽略特定文件的效果，通常都是 IDE 啦…例如，本地 ignore 与 &lt;code&gt;.idea&lt;/code&gt; 相关的所有文件，但我们并不需要修改 repo 中的&lt;code&gt;.gitignore&lt;/code&gt;文件。&lt;/p&gt;&lt;h3&gt;如何设置全局 &lt;code&gt;.gitignore&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;首先在根文件夹&lt;code&gt;~&lt;/code&gt;下创建一个&lt;code&gt;.gitignore_global&lt;/code&gt;文件，（也可以在其他文件夹创建，但通常习惯于根文件夹下），然后运行以下命令：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git config --global core.excludesfile ~/.gitignore_global
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果使用 sourcetree 就更简单了：
&lt;strong&gt;menu &amp;gt; sourcetree &amp;gt; preference &amp;gt; git&lt;/strong&gt;
将会看到 &lt;strong&gt;global ignore list:&lt;/strong&gt; 字样，添加刚刚创建的&lt;code&gt;.gitignore_global&lt;/code&gt;文件即可&lt;/p&gt;&lt;h3&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://help.github.com/articles/ignoring-files/&quot;&gt;https://help.github.com/articles/ignoring-files/&lt;/a&gt;
&lt;a href=&quot;https://stackoverflow.com/questions/30907829/sourcetree-adding-files-in-global-gitignore-not-in-repository-gitignore&quot;&gt;https://stackoverflow.com/questions/30907829/sourcetree-adding-files-in-global-gitignore-not-in-repository-gitignore&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[WebStorm的一些小技巧]]></title><description><![CDATA[从我最开始学 js，就一直用的是 webstorm，因为很穷，一直都是用 lanyu 的盗版……我也很想买正版啊，但真的是太贵了。去年年底终于用上了正版了（用学校的邮箱注册的学生版）🤦‍♀️ 因为比较懒，一直不想背各种快捷键，所以一直忍受着 IDE…]]></description><link>https://hiitea.io/2018/03/09/tips-for-webstorm/</link><guid isPermaLink="false">https://hiitea.io/2018/03/09/tips-for-webstorm/</guid><pubDate>Fri, 09 Mar 2018 04:06:02 GMT</pubDate><content:encoded>&lt;p&gt;从我最开始学 js，就一直用的是 webstorm，因为很穷，一直都是用 lanyu 的盗版……我也很想买正版啊，但真的是太贵了。去年年底终于用上了正版了（用学校的邮箱注册的学生版）🤦‍♀️&lt;/p&gt;&lt;p&gt;因为比较懒，一直不想背各种快捷键，所以一直忍受着 IDE 的蜗牛速度，也没有换 sublime vsc 什么的，然而渐渐发现，有时候记点常用的快捷键还是非常有用的…(能让人更懒…)，看来所有的程序员到了一定阶段都都无法避免要折腾 IDE 啊…&lt;/p&gt;&lt;p&gt;总结一下 webstorm 的一些使用小技巧，防止以后又忘记了…&lt;/p&gt;&lt;h3&gt;快捷键技巧&lt;/h3&gt;&lt;h4&gt;search&lt;/h4&gt;&lt;p&gt;全局搜索文件、文件夹、关键字...全部： &lt;kbd&gt;shift&lt;/kbd&gt; + &lt;kbd&gt;shift&lt;/kbd&gt;
全局搜索关键字： &lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;shift&lt;/kbd&gt; + &lt;kbd&gt;F&lt;/kbd&gt;
查看函数、变量在哪里定义的： &lt;kbd&gt;cmd&lt;/kbd&gt; + click 或者 &lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;B&lt;/kbd&gt;
当前文件下查找： &lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;F&lt;/kbd&gt;
当前文件下查找并替换： &lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;R&lt;/kbd&gt;&lt;/p&gt;&lt;h4&gt;文件&lt;/h4&gt;&lt;p&gt;关闭当前标签： &lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;w&lt;/kbd&gt;
重新打开刚才关闭的标签： 这个没有默认的快捷键，需要在 preference 里面搜索 reopen 后设置
最近使用的文件列表： &lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;E&lt;/kbd&gt;
收起所有文件夹： &lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;-&lt;/kbd&gt;
打开所有文件夹： &lt;kbd&gt;*&lt;/kbd&gt;&lt;/p&gt;&lt;h3&gt;code&lt;/h3&gt;&lt;p&gt;自动补全： &lt;kbd&gt;tab&lt;/kbd&gt;
格式化： &lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;alt&lt;/kbd&gt; + &lt;kbd&gt;L&lt;/kbd&gt;&lt;/p&gt;&lt;p&gt;选中更大的代码块：&lt;kbd&gt;opt&lt;/kbd&gt; + &lt;kbd&gt;↑&lt;/kbd&gt;， &lt;em&gt;例如有一个 switch 代码块，光标定位在 case 处，按下快捷键选中整个 case 块（一下不行就多按几下，不太明白选中的机制），再按一下选中 switch 代码块&lt;/em&gt;
放置多个光标： &lt;kbd&gt;alt&lt;/kbd&gt; + click
在当前行下添加一行： &lt;kbd&gt;shift&lt;/kbd&gt; + &lt;kbd&gt;enter&lt;/kbd&gt; 这样不需要特意将光标放在行末
删除行 line：&lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;back&lt;/kbd&gt;
复制并粘贴行 line： &lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;D&lt;/kbd&gt;
复制行： &lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;C&lt;/kbd&gt;
剪切行： &lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;X&lt;/kbd&gt;
移动行： &lt;kbd&gt;alt&lt;/kbd&gt; + &lt;kbd&gt;shift&lt;/kbd&gt; + &lt;kbd&gt;↑ or ↓&lt;/kbd&gt;
缓存去粘贴： &lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;shift&lt;/kbd&gt; + &lt;kbd&gt;V&lt;/kbd&gt;&lt;/p&gt;&lt;p&gt;注释/取消注释： &lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;/&lt;/kbd&gt;
展开代码块： &lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;+&lt;/kbd&gt;
折叠代码块： &lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;-&lt;/kbd&gt;&lt;/p&gt;&lt;p&gt;返回上次编辑的地方： &lt;kbd&gt;cmd&lt;/kbd&gt; + &lt;kbd&gt;shift&lt;/kbd&gt; + &lt;kbd&gt;back&lt;/kbd&gt;&lt;/p&gt;&lt;h4&gt;重构&lt;/h4&gt;&lt;p&gt;变量名、函数名重构： &lt;kbd&gt;shift&lt;/kbd&gt; + &lt;kbd&gt;F6&lt;/kbd&gt; 或右击需要重构的变量/函数，选择 refactor - rename&lt;/p&gt;&lt;p&gt;代码校验：&lt;kbd&gt;F2&lt;/kbd&gt; 切换到下一个错误的那行&lt;/p&gt;&lt;h3&gt;非快捷键小技巧&lt;/h3&gt;&lt;h4&gt;VSC 版本控制&lt;/h4&gt;&lt;p&gt;开启 blame view： 在行号与代码之间的空白处右击弹出菜单中选&lt;code&gt;Annotate&lt;/code&gt;可以打开 blame view，查看当前版本都是谁修改的哪一行代码
关闭 blame view： 在与上面相同的位置右击弹出菜单中选&lt;code&gt;Close Annotations&lt;/code&gt;&lt;/p&gt;&lt;h4&gt;窗口&lt;/h4&gt;&lt;p&gt;多标签显示： 在标签出右击，可选&lt;code&gt;split vertically&lt;/code&gt; 或 &lt;code&gt;split horizontally&lt;/code&gt;&lt;/p&gt;&lt;p&gt;TBC...&lt;/p&gt;&lt;h3&gt;参考&lt;/h3&gt;&lt;p&gt;[1] &lt;a href=&quot;https://blog.jetbrains.com/webstorm/2015/06/10-webstorm-shortcuts-you-need-to-know/&quot;&gt;https://blog.jetbrains.com/webstorm/2015/06/10-webstorm-shortcuts-you-need-to-know/&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[以太坊智能合约应用初体验]]></title><description><![CDATA[我刚来香港那年（2012 年）上了 Pf.Lau 的 enterpreneur 课知道了比特币，那个时候好像才 CNY700 多块钱一枚，13 年的炒的最火的时候大概涨到了 6000，如今五年多过去，比特币最高已经十几万人民币一枚了，反正我是没挣到钱:( ， 1…]]></description><link>https://hiitea.io/2018/01/16/first-experience-of-ethereum-dapp/</link><guid isPermaLink="false">https://hiitea.io/2018/01/16/first-experience-of-ethereum-dapp/</guid><pubDate>Tue, 16 Jan 2018 14:57:42 GMT</pubDate><content:encoded>&lt;p&gt;我刚来香港那年（2012 年）上了 Pf.Lau 的 enterpreneur 课知道了比特币，那个时候好像才 CNY700 多块钱一枚，13 年的炒的最火的时候大概涨到了 6000，如今五年多过去，比特币最高已经十几万人民币一枚了，反正我是没挣到钱:( ， 14 年找工作的时候还差点去了一家比特币平台公司，这应该就是我跟区块链最初的良缘了。&lt;/p&gt;&lt;p&gt;最近半年也不知道为啥区块链特别火，到处的人们都在谈论区块链，感觉泡沫又快崩溃了。我个人是不看好比特币的货币属性的，但是对于区块链的去中心化以及智能合约应用却是很看好的。而且以太坊(Ethereum，缩写为 ETH)最火的开发平台(truffle)又是我最喜欢的 js，所以就看了看 demo 学了 ETH 界的 hello world (pet shop)&lt;/p&gt;&lt;p&gt;总的来说感觉配置环境还是有一点点麻烦，需要安装 nodejs, npm, truffle(开发平台), ganache(本地区块链), MetaMask(chrome 插件)&lt;/p&gt;&lt;p&gt;官方给的 demo 不错，缺点是很多文件解释的不太清楚。
大概流程如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;解压官方 demo &lt;code&gt;truffle unbox pet-shop&lt;/code&gt;&lt;/li&gt;&lt;li&gt;编写合约 Adoption.sol, 编译(compoile)合约 (目前还不知道编译是干什么用的)&lt;/li&gt;&lt;li&gt;运行本地区块链&lt;/li&gt;&lt;li&gt;编写迁移配置文件(&lt;code&gt;/migrates/*&lt;/code&gt;)，迁移(migrate)应用到本地区块链&lt;/li&gt;&lt;li&gt;测试合约&lt;/li&gt;&lt;li&gt;编写前端 (web3.js)&lt;/li&gt;&lt;li&gt;应用完成，可于网页中收养宠物&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;合约部分是用&lt;code&gt;solidity&lt;/code&gt;，这是开发 ETH 应用所使用的语言，是静态类型语言，需要声明变量的类型，函数入参的类型及返回值的类型。用分号分隔每一句代码。&lt;/p&gt;&lt;p&gt;官方的例子是前后端全都在一个项目里，不知道是否可以前后端放在不同的项目里分开开发，前端负责界面、业务逻辑、web3 整合，后端负责合约的编写。不知道这样是否可行。&lt;/p&gt;&lt;p&gt;----- 分割线 ------
又看了两眼，感觉过程是这样的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;编译的时候生成了&lt;code&gt;/build/&lt;/code&gt;文件夹下的与合约相关的 json 文件&lt;/li&gt;&lt;li&gt;migrate 的时候极有可能是把对应的 json 放到区块链上去&lt;/li&gt;&lt;li&gt;前端通过 &lt;code&gt;App.web3Provider = new Web3.providers.HttpProvider(&amp;#x27;http://localhost:7545&amp;#x27;);&lt;/code&gt; 服务器获取合约相关的内容，由 web3 将获取的内容包装成一个实例&lt;/li&gt;&lt;li&gt;前端通过 web3 生成的实例进行相应操作&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果是按照以上的流程来走的话，前后端就是完全可以分开开发的了。初来乍到，如有猜的不对的地方还请各位大佬多多指教。:)&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;
&lt;a href=&quot;http://truffleframework.com/tutorials/pet-shop&quot;&gt;http://truffleframework.com/tutorials/pet-shop&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[HTML DOM Element - image]]></title><description><![CDATA[忘了是去年还是前年写了一个 urbtix 抢演唱会票的 chrome 小插件  https://github.com/sabrinaluo/urbtix-helper  （每次都进不去网站，一次都没抢到 😂），逻辑其实很简单，就是当用户设置了 event_id…]]></description><link>https://hiitea.io/2018/01/12/image-element/</link><guid isPermaLink="false">https://hiitea.io/2018/01/12/image-element/</guid><pubDate>Fri, 12 Jan 2018 08:42:54 GMT</pubDate><content:encoded>&lt;p&gt;忘了是去年还是前年写了一个 urbtix 抢演唱会票的 chrome 小插件 &lt;a href=&quot;https://github.com/sabrinaluo/urbtix-helper&quot;&gt;https://github.com/sabrinaluo/urbtix-helper&lt;/a&gt; （每次都进不去网站，一次都没抢到 😂），逻辑其实很简单，就是当用户设置了&lt;code&gt;event_id&lt;/code&gt; &lt;code&gt;perfomence_id&lt;/code&gt; &lt;code&gt;seat_type&lt;/code&gt; &lt;code&gt;ticket_amount&lt;/code&gt;之后，凡是自动点击的就由程序自动点击，以加快整个购票过程。&lt;/p&gt;&lt;p&gt;为了让界面和用户体验更好，所以在界面加了一个图片，来展示对应的演唱会海报（海报是通过 urbtix 的 url 扒来的，e.g. &lt;a href=&quot;https://ticket.urbtix.hk/internet/p_image/cover/34505.jpg&quot;&gt;https://ticket.urbtix.hk/internet/p_image/cover/34505.jpg&lt;/a&gt; ）。一直以来 urbtix 都是用&lt;code&gt;.jpg&lt;/code&gt;图片文件，今天忽然发现，他们居然有些图片是&lt;code&gt;.jpeg&lt;/code&gt;的 🙄&lt;/p&gt;&lt;p&gt;于是问题就来了，如果不爬取 urbtix 的 html 是无法知道正确的图片格式的，所以一个代替的方案是，在&lt;code&gt;.jpg&lt;/code&gt;下载失败时尝试使用&lt;code&gt;.jpeg&lt;/code&gt;来下载，这就涉及到怎么检测图片是否加载成功…&lt;/p&gt;&lt;p&gt;搜了一下 google，发现是非常基础的知识，这种时候就觉得自己基础实在是太差了…☹&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var image = new Image();
// 相当于 document.createElement(&amp;#x27;img&amp;#x27;)
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;image.onload&lt;/h3&gt;&lt;p&gt;当图片加载完成时，触发 image.onload&lt;/p&gt;&lt;h3&gt;image.onerror&lt;/h3&gt;&lt;p&gt;当图片加载出现错误时，触发 image.onerror&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// 继续上面的例子
image.onload = function () {
  console.log(&amp;#x27;ok&amp;#x27;);
};
image.onerror = function () {
  console.log(&amp;#x27;error&amp;#x27;);
};

image.src = &amp;#x27;https://ticket.urbtix.hk/internet/p_image/cover/34505.jpg&amp;#x27;;
// → &amp;#x27;error&amp;#x27;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上，就是辣么简单啦。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image&lt;/a&gt;
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL/image&quot;&gt;https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL/image&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[神奇的toLocaleString, Intl.NumberFormat]]></title><description><![CDATA[一如之前提到的，由于我的工作中会接触到很多 internationalization 的内容，对于货币、数字等的 foatmatting 需要特别注意。在我看到这条问题 之前，并不知道 toLocaleString 的用法和作用。我们自己的 codebase…]]></description><link>https://hiitea.io/2018/01/05/the-magic-of-tolocalestring/</link><guid isPermaLink="false">https://hiitea.io/2018/01/05/the-magic-of-tolocalestring/</guid><pubDate>Fri, 05 Jan 2018 04:00:00 GMT</pubDate><content:encoded>&lt;p&gt;一如之前提到的，由于我的工作中会接触到很多 internationalization 的内容，对于货币、数字等的 foatmatting 需要特别注意。在我看到这条问题&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;之前，并不知道&lt;code&gt;toLocaleString&lt;/code&gt;的用法和作用。我们自己的 codebase 中，关于国际化的部分是写了自己的 service 来实现不同国家的货币格式，经常都有各种 Bug，可以说是非常辣鸡了…&lt;/p&gt;&lt;p&gt;当然也有可能是需要照顾 IE 或者部分手机浏览器，从而限制了&lt;code&gt;toLocaleString&lt;/code&gt;的使用，具体原因无法追溯…&lt;/p&gt;&lt;h3&gt;固定整数字符串长度&lt;/h3&gt;&lt;p&gt;例如，我们需要显示的数字&lt;strong&gt;值&lt;/strong&gt;为 1, 2, 3 ... 10, 11 ..。 100, 200 等等，但希望显示的格式为所有数字都是固定的三位数，001, 002 这样&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var number = 1;
number.toLocaleString(&amp;#x27;en-US&amp;#x27;, { minimumIntegerDigits: 3, useGrouping: false });
// output &amp;#x27;001&amp;#x27;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果&lt;code&gt;locale&lt;/code&gt;为&lt;code&gt;undefined&lt;/code&gt; (上例中为&lt;code&gt;en-US&lt;/code&gt;)，则默认值为系统的 locale，即&lt;code&gt;navigator.language&lt;/code&gt;&lt;/p&gt;&lt;p&gt;不使用&lt;code&gt;toLocaleString&lt;/code&gt;的实现方法：思路是将带转换数字转换为字符串后，在前面补足够多的零，然后用&lt;code&gt;slice&lt;/code&gt;获取需要的最后若干位数。（我第一次看到这种实现方法的时候觉得，哇，还有这种骚操作！）&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var number = 12;
(&amp;#x27;00&amp;#x27; + number).slice(-3);
// → &amp;#x27;012&amp;#x27;

var number = 1;
(&amp;#x27;00&amp;#x27; + number).slice(-3);
// → &amp;#x27;001&amp;#x27;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Intl.NumberFormat&lt;/h3&gt;&lt;p&gt;当需要格式化的数字较大时（多长算大呢？🤔），为了使性能更好，最好新建一个&lt;code&gt;Intl.NumberFormat&lt;/code&gt;实例，使用其&lt;code&gt;format&lt;/code&gt;方法来格式化。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;When formatting large numbers of numbers, it is better to create a NumberFormat object and use the function provided by its &lt;code&gt;NumberFormat.format&lt;/code&gt; property. &lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;, &lt;sup id=&quot;fnref-3&quot;&gt;&lt;a href=&quot;#fn-3&quot; class=&quot;footnote-ref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var number = 123456.789;
console.log(new Intl.NumberFormat(&amp;#x27;en-US&amp;#x27;).format(number));
// → 123,456.789
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://stackoverflow.com/questions/8043026/javascript-format-number-to-have-2-digit&quot;&gt;https://stackoverflow.com/questions/8043026/javascript-format-number-to-have-2-digit&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-3&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat&lt;/a&gt;&lt;a href=&quot;#fnref-3&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[angular指令什么情况下只能有一个根元素(root element)]]></title><description><![CDATA[好久么有记录什么有用的知识了，总是猴子掰玉米似的学点忘点:( 问题 在写自定义指令(custom directive)的时候，经常遇到下面这个错误： 但有时候又发现别人写的指令超过一个根元素，却并没有报错，真是非常的 confusing🤔 文档 官访文档在 directive…]]></description><link>https://hiitea.io/2017/12/05/angular-directive-only-one-root-element/</link><guid isPermaLink="false">https://hiitea.io/2017/12/05/angular-directive-only-one-root-element/</guid><pubDate>Tue, 05 Dec 2017 07:28:03 GMT</pubDate><content:encoded>&lt;p&gt;好久么有记录什么有用的知识了，总是猴子掰玉米似的学点忘点:(&lt;/p&gt;&lt;h3&gt;问题&lt;/h3&gt;&lt;p&gt;在写自定义指令(custom directive)的时候，经常遇到下面这个错误：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Error: [$compile:tplrt] Template for directive &amp;#x27;xxx&amp;#x27; must have exactly one root element.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但有时候又发现别人写的指令超过一个根元素，却并没有报错，真是非常的 confusing🤔&lt;/p&gt;&lt;h3&gt;文档&lt;/h3&gt;&lt;p&gt;官访文档在 directive 一节是找不到任何和 replace 有关的东西，后来是在\$compile 一节找到的，然而又已经弃用了……(又要感叹了，前端圈真特喵难混)&lt;/p&gt;&lt;p&gt;以下为文档说明&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;replace (DEPRECATED)&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;replace will be removed in next major release - i.e. v2.0).&lt;/li&gt;&lt;li&gt;Specifies what the template should replace. Defaults to false.&lt;ul&gt;&lt;li&gt;true - the template will replace the directive&amp;#x27;s element.&lt;/li&gt;&lt;li&gt;false - the template will replace the contents of the directive&amp;#x27;s element.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;The replacement process migrates all of the attributes / classes from the old element to the new one. See the Directives Guide for an example.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;大概是说这个 replace 属性没什么卵用…实际使用的时候也觉得没什么场景是非要 replace 不可的，不过为了避免在 jq selector 里使用一堆莫名其妙的 dom 名称，replace 一下让 Html 看起来更正常一点（对，我们就是 jQuery 和 angular 混用，就是这么任！性！🤷‍）&lt;/p&gt;&lt;h3&gt;感悟&lt;/h3&gt;&lt;p&gt;在写组件 template 的时候用根元素把其他元素 wrap 起来，其实一个很好的习惯，这样一来，根元素上可以有 css class，在使用 sass 之类的 css 预处理器时，有根类会使得维护成本变低&lt;/p&gt;&lt;p&gt;那么为什么会存在有多余一个根元素的组件呢？&lt;/p&gt;&lt;p&gt;我个人的感觉是，组件在最初设计时，并没有考虑到之后的扩展性，比如要写一个 dropdown 组件，首先想到的肯定是把 select 元素作为根元素，于是模板成了这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;select class=&amp;quot;xxxx&amp;quot;&amp;gt;
...
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后来了个需求：当所选的选项是某一些特定选项时，显示一个 error message。这一下就比较尴尬了……&lt;/p&gt;&lt;p&gt;error message 这个&lt;code&gt;div&lt;/code&gt;只能和&lt;code&gt;select&lt;/code&gt;同一个 level 才行，因为加在&lt;code&gt;select&lt;/code&gt;里是肯定不会显示的。而一旦新加一个 wrapper 把之前的模板包起来，之前的 css 可能都要重写才会看起来没有变化。此时影响最小的做法就是移除指令中的&lt;code&gt;replace:true&lt;/code&gt;属性，然后加多一个根元素了 😂&lt;/p&gt;&lt;p&gt;Angular 本身 compile 的机制是，如果没有 replace:true，默认就是 false，&lt;strong&gt;会自动创建一个&lt;code&gt;&amp;lt;directive-name&amp;gt;&lt;/code&gt;元素作为根元素&lt;/strong&gt;包裹住模板中的全部内容。&lt;/p&gt;&lt;p&gt;以上。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Angular directive指令相关的scope问题(= @ & ?)]]></title><description><![CDATA[老生常谈之 isolated scope 每次说到 directive, isolated scope 总是要被提起的…官方的例子已经很好的说明了为什么我们需要 isolated scope。当没有 isolated scope 的时候，directive…]]></description><link>https://hiitea.io/2017/09/01/angular-directive-scope/</link><guid isPermaLink="false">https://hiitea.io/2017/09/01/angular-directive-scope/</guid><pubDate>Fri, 01 Sep 2017 07:59:44 GMT</pubDate><content:encoded>&lt;h3&gt;老生常谈之 isolated scope&lt;/h3&gt;&lt;p&gt;每次说到 directive, isolated scope 总是要被提起的…官方的例子已经很好的说明了为什么我们需要 isolated scope。当没有 isolated scope 的时候，directive 依赖于 controller 的 scope，这样每次使用 directive，都需要创建新的 controller。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div ng-controller=&amp;quot;NaomiController&amp;quot;&amp;gt;
  &amp;lt;my-customer&amp;gt;&amp;lt;/my-customer&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;hr /&amp;gt;
&amp;lt;div ng-controller=&amp;quot;IgorController&amp;quot;&amp;gt;
  &amp;lt;my-customer&amp;gt;&amp;lt;/my-customer&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;angular
  .module(&amp;#x27;docsScopeProblemExample&amp;#x27;, [])
  .controller(&amp;#x27;NaomiController&amp;#x27;, [
    &amp;#x27;$scope&amp;#x27;,
    function ($scope) {
      $scope.customer = {
        name: &amp;#x27;Naomi&amp;#x27;,
        address: &amp;#x27;1600 Amphitheatre&amp;#x27;,
      };
    },
  ])
  .controller(&amp;#x27;IgorController&amp;#x27;, [
    &amp;#x27;$scope&amp;#x27;,
    function ($scope) {
      $scope.customer = {
        name: &amp;#x27;Igor&amp;#x27;,
        address: &amp;#x27;123 Somewhere&amp;#x27;,
      };
    },
  ])
  .directive(&amp;#x27;myCustomer&amp;#x27;, function () {
    return {
      restrict: &amp;#x27;E&amp;#x27;,
      template:
        &amp;#x27;&amp;lt;div&amp;gt;Name: {{customer.name}} Address: {{customer.address}}&amp;lt;/div&amp;gt;&amp;#x27;,
    };
  });
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Isolated scope 其实就是当你在 directive 里要 return 的那个 object 里，定义一个 scope 属性，这个&lt;code&gt;scope&lt;/code&gt;会 override controller 中的&lt;code&gt;$scope&lt;/code&gt;，从而实现 isolated。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;angular
  .module(&amp;#x27;docsIsolateScopeDirective&amp;#x27;, [])
  .controller(&amp;#x27;Controller&amp;#x27;, [
    &amp;#x27;$scope&amp;#x27;,
    function ($scope) {
      $scope.naomi = { name: &amp;#x27;Naomi&amp;#x27;, address: &amp;#x27;1600 Amphitheatre&amp;#x27; };
      $scope.igor = { name: &amp;#x27;Igor&amp;#x27;, address: &amp;#x27;123 Somewhere&amp;#x27; };
    },
  ])
  .directive(&amp;#x27;myCustomer&amp;#x27;, function () {
    return {
      restrict: &amp;#x27;E&amp;#x27;,
      scope: {
        customerInfo: &amp;#x27;=&amp;#x27;,
      },
      templateUrl: &amp;#x27;my-customer-iso.html&amp;#x27;,
    };
  });
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;code&gt;=&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;@&lt;/code&gt; &lt;code&gt;?&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;通常在写 Angular 的时候经常看到别人的指令 scope 里会有下面着这样&lt;code&gt;=&lt;/code&gt; &lt;code&gt;@&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt;的符号，我自己呢，90%的时候都是用&lt;code&gt;=&lt;/code&gt;，也不知道其他符号到底是干什么用的。今天无心工作，仔细研究了一下。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;app.directive(&amp;#x27;myDirective&amp;#x27;, function () {
  return {
    scope: {
      optionOne: &amp;#x27;=&amp;#x27;,
      optionTwo: &amp;#x27;=?&amp;#x27;,
      optionThree: &amp;#x27;@&amp;#x27;,
      optionFour: &amp;#x27;&amp;amp;&amp;#x27;,
    },
  };
});
&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;code&gt;=&lt;/code&gt; 双向绑定(two way binding)&lt;/h4&gt;&lt;p&gt;这个好理解，父子两个 scope，任何一个改变，剩下的一个也跟着一起改变&lt;/p&gt;&lt;p&gt;需要注意的是，传入参数时，是没有花括号的&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;my-directive options=&amp;quot;options&amp;quot;&amp;gt;&amp;lt;/my-directive&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;code&gt;@&lt;/code&gt; 单向绑定(one way binding)&lt;/h4&gt;&lt;p&gt;首先，单向绑定传入的是一个&lt;strong&gt;字！符！串！&lt;/strong&gt;；其次，父 scope 改变子 scope 跟着变，但子 scope 改变时，父 scope 不会改变！&lt;/p&gt;&lt;p&gt;由于传入的是一个字符串，所以是需要花括号的，如下，假如父 scope 中&lt;code&gt;name=&amp;#x27;Lucy&amp;#x27;&lt;/code&gt;，第一个指令接收到的是&lt;code&gt;&amp;#x27;name&amp;#x27;&lt;/code&gt;这个字符串，第二个指令接受的才是&lt;code&gt;&amp;#x27;Lucy&amp;#x27;&lt;/code&gt;这个字符串&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;my-directive name=&amp;quot;name&amp;quot;&amp;gt;&amp;lt;/my-directive&amp;gt;
&amp;lt;my-directive name=&amp;quot;{{name}}&amp;quot;&amp;gt;&amp;lt;/my-directive&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; 绑定函数&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;The &lt;code&gt;&amp;amp;&lt;/code&gt; binding allows a directive to trigger evaluation of an expression in the context of the original scope&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;绑定允许指令触发原始 scope(指令所在的父元素的 scope)中的函数&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Best Practice: use &lt;code&gt;&amp;amp;attr&lt;/code&gt; in the &lt;code&gt;scope&lt;/code&gt; option when you want your directive to expose an API for binding to behaviors.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;可以理解为传入一个&lt;strong&gt;回调函数&lt;/strong&gt;给指令，指令触发该函数，但该函数并不定义在指令的 scope 中。因为如果该函数定义在 directive 的 scope 中，则逻辑是固定的，从外部传入的话，可以传入任意逻辑的函数。&lt;/p&gt;&lt;p&gt;我的一些&lt;strong&gt;Anti-pattern&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;关于函数绑定这个事，我通常直接用&lt;code&gt;=&lt;/code&gt;绑定函数，也能用……但这个肯定有什么潜在的问题我没发现；&lt;/li&gt;&lt;li&gt;我的另一种用法是，仍然用&lt;code&gt;=&lt;/code&gt;绑定一个对象，把函数放在对象里，比如绑定的是&lt;code&gt;options&lt;/code&gt;这个对象，但对象中有&lt;code&gt;options.sayHi&lt;/code&gt;这个属性（其实是个函数）。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我能想到的潜在的问题就是，会存在&lt;code&gt;undefined is not a function&lt;/code&gt;，但如果检查一下属性是否存在是否类型 function 不就可以了？？？我知道可能会有问题，但到底会有什么问题呢？🤔&lt;/p&gt;&lt;p&gt;---- 更新 ----
大概知道原因了…不用&lt;code&gt;@&lt;/code&gt;很好理解，用&lt;code&gt;@&lt;/code&gt;传入的是个字符串不是函数；而不用&lt;code&gt;=&lt;/code&gt;因为双向绑定存在子 scope 改变父 scope 中的函数的风险，并且也会有&lt;code&gt;$watch&lt;/code&gt;的开销，一定程度上影响性能。
&lt;a href=&quot;https://stackoverflow.com/questions/29857998/proper-way-to-pass-functions-to-directive-for-execution-in-link&quot;&gt;https://stackoverflow.com/questions/29857998/proper-way-to-pass-functions-to-directive-for-execution-in-link&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;绑定后，返回的是一个返回父 scope 中对应函数的函数 😂，有点拗口。举个栗子：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;my-directive callback=&amp;quot;sayHi(a,b,c)&amp;quot;&amp;gt;&amp;lt;/my-directive&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;指令中的&lt;code&gt;scope.callback&lt;/code&gt;值为&lt;code&gt;function(locals){ return parentGet(scope, locals);}&lt;/code&gt;&lt;/p&gt;&lt;p&gt;所以&lt;code&gt;scope.callback({a:1,b:2,c:3})&lt;/code&gt;等价于&lt;code&gt;parentScope.sayHi(1,2,3)&lt;/code&gt;
需要注意的是:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;scope.callback({a:1,b:2,c:3})&lt;/code&gt;的入参是一个&lt;code&gt;object&lt;/code&gt;&lt;/li&gt;&lt;li&gt;如果是这样&lt;code&gt;scope.callback({a:1,b:2})&lt;/code&gt;，则&lt;code&gt;c&lt;/code&gt;的值会与&lt;code&gt;parentScope.c&lt;/code&gt;相同。也就是说，如果&lt;strong&gt;子 scope&lt;/strong&gt;传入的&lt;code&gt;obj&lt;/code&gt;中没有定义对应参数，各参数的默认值与&lt;code&gt;parentScope&lt;/code&gt;中的对应值一致。如果&lt;strong&gt;父子 scope&lt;/strong&gt;中都没有定义相关参数，则为&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;code&gt;?&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;问号这个挺简单的，跟 glob 啊，正则的里面的&lt;code&gt;?&lt;/code&gt;意思相似，就是说该属性是否是必需选项，当有问号的时候，说明对应的属性可以省略，而不会报错&lt;code&gt;NON_ASSIGNABLE_MODEL_EXPRESSION &lt;/code&gt;&lt;/p&gt;&lt;h3&gt;无关感言&lt;/h3&gt;&lt;p&gt;我第一次知道 AngularJS 大约是 3 年前，除了学校的一些酱油小项目外完全没有任何开发经验，对于 JS 只知道 jQuery 却又要去找一份程序员的工作。面试的时候人家问我：会 Angular 吗？我：？？？当然是没有面上，回去之后到 code school 学完了入门课程，在官网学完了那个卖手机的 demo。当然之后我也没有直接去做一份跟 Angular 有关的工作。&lt;/p&gt;&lt;p&gt;如今，在我终于做着一份 Angular1.x 的工作时，Angular5 都快发布了，（再次感叹，前端圈真难混），而我连 TypeScript 也还没学会，关于 Angular 的很多基本问题也还是云里雾里……但这并不妨碍我能写出能在生产环境使用的应用 🙄，基础和工程经验这是没什么必然关系，（当然也可能是我天赋异禀而不自知 🤣）。其实我现在是很不想写 Angular1.x 的，总觉得是非常 outdated 的东西，然而 🤷‍&lt;/p&gt;&lt;p&gt;另外，这篇真是 50%以上都是抄袭官网…但是不抄根本记不住…&lt;/p&gt;&lt;h3&gt;参考&lt;/h3&gt;&lt;p&gt;[1] &lt;a href=&quot;https://docs.angularjs.org/guide/directive&quot;&gt;https://docs.angularjs.org/guide/directive&lt;/a&gt;
[2] &lt;a href=&quot;https://blog.coding.net/blog/angularjs-directive-isolate-scope&quot;&gt;https://blog.coding.net/blog/angularjs-directive-isolate-scope&lt;/a&gt;
[3] &lt;a href=&quot;https://stackoverflow.com/questions/14908133/what-is-the-difference-between-vs-and-in-angularjs&quot;&gt;https://stackoverflow.com/questions/14908133/what-is-the-difference-between-vs-and-in-angularjs&lt;/a&gt;
[4] &lt;a href=&quot;https://stackoverflow.com/questions/20447786/whats-the-meaning-of-in-angularjs-directive-isolate-scope-declaration&quot;&gt;https://stackoverflow.com/questions/20447786/whats-the-meaning-of-in-angularjs-directive-isolate-scope-declaration&lt;/a&gt;
[5] &lt;a href=&quot;https://stackoverflow.com/questions/29857998/proper-way-to-pass-functions-to-directive-for-execution-in-link&quot;&gt;https://stackoverflow.com/questions/29857998/proper-way-to-pass-functions-to-directive-for-execution-in-link&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[用webpack打包react组件]]></title><description><![CDATA[吐槽 好多人都吐槽 Webpack 配置太复杂了，然而 1.x 我都还没学会现在都已经 3.x 了，前段圈真的好难混啊，真是必须活到老学到老啊… 前段时间闲得无聊看到个播放器叫 APlayer ，就想着包起来做个 Vue 或者 React…]]></description><link>https://hiitea.io/2017/08/14/react-component-with-webpack/</link><guid isPermaLink="false">https://hiitea.io/2017/08/14/react-component-with-webpack/</guid><pubDate>Mon, 14 Aug 2017 02:36:56 GMT</pubDate><content:encoded>&lt;h3&gt;吐槽&lt;/h3&gt;&lt;p&gt;好多人都吐槽 Webpack 配置太复杂了，然而 1.x 我都还没学会现在都已经 3.x 了，前段圈真的好难混啊，真是必须活到老学到老啊…&lt;/p&gt;&lt;p&gt;前段时间闲得无聊看到个播放器叫&lt;a href=&quot;https://github.com/DIYgod/APlayer&quot;&gt;APlayer&lt;/a&gt;，就想着包起来做个 Vue 或者 React 能用的吧，练练手……然后由于我的拖延症，写了好久，就在我写完 Vue 版本的第二天，还没 push，就发现 MD 已经有别人比我早几天写好了，好气哦…于是只能重头开始写 React 版&lt;/p&gt;&lt;p&gt;因为从开始就是用&lt;code&gt;create-react-app&lt;/code&gt;的脚手架，所以也没考虑 npm require 时候会有什么问题，&lt;a href=&quot;http://sabrinaluo.com/react-aplayer/&quot;&gt;Demo&lt;/a&gt;更是直接写在&lt;code&gt;src&lt;/code&gt; 文件夹里，我自己引用的时候当然没有问题啦…不过&lt;code&gt;create-react-app&lt;/code&gt;没有提供相应的功能也有别人吐槽过了&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;发布了之后有人给提了个 Issue，说引用之后编译的时候有问题，我一看果然…&lt;/p&gt;&lt;pre&gt;&lt;code&gt;uncaught ReferenceError: React is not defined
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;正经事儿&lt;/h3&gt;&lt;p&gt;&lt;code&gt;/src&lt;/code&gt;里的文件都是&lt;code&gt;ES6&lt;/code&gt;和&lt;code&gt;JSX&lt;/code&gt;形式，第一反应是我的文件没有被 webpack 里的&lt;code&gt;babel-loader&lt;/code&gt;成功编译，查了一些资料之后发现问题是在&lt;code&gt;create-react-app&lt;/code&gt;的 webpack 配置中，只会编译&lt;code&gt;./src&lt;/code&gt;下的文件，而当我的库作为第三方依赖引入时，是在&lt;code&gt;./node_modules&lt;/code&gt;下，因此没有被编译。（使用 webpack 编译时通常都会忽略&lt;code&gt;./node_modules&lt;/code&gt;下的文件，没理由去编译别人的包呀，也就是说别人发布这个包的时候，就应该是编译好的了，然而偷懒的我没有编译就直接发布了）(⊙﹏⊙)b&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// ./react-scripts/config/webpack.config.prod.js
// Process JS with Babel.
{
  test: /\.(js|jsx)$/,
  include: paths.appSrc,
  loader: require.resolve(&amp;#x27;babel-loader&amp;#x27;),
  options: {
    // @remove-on-eject-begin
    babelrc: false,
    presets: [require.resolve(&amp;#x27;babel-preset-react-app&amp;#x27;)],
    // @remove-on-eject-end
    compact: true,
  },
},
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了编译我的文件，我还要专门写一个&lt;code&gt;webpack.config.js&lt;/code&gt;真是好心累…写的时候遇到的问题更心累&lt;/p&gt;&lt;p&gt;首先就是最基本的配置，相关的&lt;code&gt;loader&lt;/code&gt;和 minify plugin，编译之后文件很大…原来是把&lt;code&gt;react&lt;/code&gt;也打包进去了，如果所有人都这么写组件的话……最后的 APP 里有几个组件就会有几份重复的 react，肯定是不对的。&lt;/p&gt;&lt;p&gt;之后搜到，要排除某个库，可以用&lt;code&gt;external&lt;/code&gt;选项&lt;/p&gt;&lt;pre&gt;&lt;code&gt;  externals: [&amp;#x27;react&amp;#x27;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然而，加上这个时候我的噩梦就来啦，永远都提示&lt;code&gt;React is undefined&lt;/code&gt;，试了各种各样的&lt;code&gt;external&lt;/code&gt;写法，对象、数组…都不管用。花了两三天时间，才搜到一个说&lt;code&gt;libiaryTarget: &amp;#x27;umd&amp;#x27;&lt;/code&gt;的&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://github.com/facebookincubator/create-react-app/issues/1492&quot;&gt;https://github.com/facebookincubator/create-react-app/issues/1492&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;https://github.com/zhengweikeng/blog/issues/10&quot;&gt;https://github.com/zhengweikeng/blog/issues/10&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[尾逗号(Trailing Comma)的意义]]></title><description><![CDATA[以前在网上看别人写的代码，有时候会看到这样，数组的最后一个元素后面多一个逗号： 作为一个懒癌晚期患者，觉得要多加一个逗号，真是好麻烦！那是 naive 的我，当然还不知道有版本控制 diff…]]></description><link>https://hiitea.io/2017/07/12/trailing-comma/</link><guid isPermaLink="false">https://hiitea.io/2017/07/12/trailing-comma/</guid><pubDate>Wed, 12 Jul 2017 03:01:13 GMT</pubDate><content:encoded>&lt;p&gt;以前在网上看别人写的代码，有时候会看到这样，数组的最后一个元素后面多一个逗号：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var foo = [1, 2, 3];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;作为一个懒癌晚期患者，觉得要多加一个逗号，真是好麻烦！那是 naive 的我，当然还不知道有版本控制 diff 这种高级工具，还停留在复制粘贴文件夹的人工版本控制低级阶段…&lt;/p&gt;&lt;p&gt;后来看到几家大厂的代码规范&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, &lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;中都有相应的规范。Airbnb 的 JS 代码规范是非常火的，然而最开始的时候我个人比较喜欢的是 Google 的 JS 代码规范，就因为 A 家有我不喜欢的 trailing comma。没想到，过了一段时间之后，G 家也采用了这一条…而恰好也是这段时间，我一直在思考为什么有的人要把代码写的那么不 clean？多年的经验告诉我，所有规则一定都是有原因的！&lt;/p&gt;&lt;p&gt;传图好麻烦…我就文字描述一下吧。凡是用过 git 的人应该都知道有 diff view 这种东西，用来比较两个版本的代码有什么区别。没有尾逗号的时候，当你需要添加一个元素，就需要在最后一个元素的&lt;strong&gt;1. 末尾加上一个逗号，2.换行添加新内容&lt;/strong&gt;，如下面的例子所示。&lt;/p&gt;&lt;p&gt;Before&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var foo = [1, 2];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var foo = [1, 2, 3];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样一来，diff view 中就会显示修改了&lt;strong&gt;两行&lt;/strong&gt;代码。如果使用尾逗号，则添加一个元素只需要&lt;strong&gt;1.换行添加新内容&lt;/strong&gt;即可，diff view 中显示只修改（添加）了一行代码。&lt;/p&gt;&lt;h3&gt;一点人生感悟&lt;/h3&gt;&lt;p&gt;这个世界上，凡事都是 trade off，算法复杂度里要么时间换空间要么空间换时间。
尾逗号也一样，想要 diff view clean，代码就不那么 clean；想要代码 clean，diff view 就不那么 clean。
所以搞清楚自己想要什么，又有什么可以去 trade off，就很重要了。&lt;/p&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://github.com/airbnb/javascript#functions--signature-invocation-indentation&quot;&gt;https://github.com/airbnb/javascript#functions--signature-invocation-indentation&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;https://google.github.io/styleguide/jsguide.html#features-arrays-trailing-comma&quot;&gt;https://google.github.io/styleguide/jsguide.html#features-arrays-trailing-comma&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[关于本地化的一些技巧]]></title><description><![CDATA[在香港工作总是能接触到各种“本地化”的需求，大多数网站至少都会有中英文两个版本，有的还会分简体中文和繁体中文。而在实现本地化的过程中，由于英文与中文的文法、语序等差异，会有很多情况需要处理。 i18n & i10n 一直以来我都混淆使用这两个 term，其中 i18n…]]></description><link>https://hiitea.io/2017/05/26/interpolation-and-pluralization/</link><guid isPermaLink="false">https://hiitea.io/2017/05/26/interpolation-and-pluralization/</guid><pubDate>Fri, 26 May 2017 09:59:03 GMT</pubDate><content:encoded>&lt;p&gt;在香港工作总是能接触到各种“本地化”的需求，大多数网站至少都会有中英文两个版本，有的还会分简体中文和繁体中文。而在实现本地化的过程中，由于英文与中文的文法、语序等差异，会有很多情况需要处理。&lt;/p&gt;&lt;h3&gt;i18n &amp;amp; i10n&lt;/h3&gt;&lt;p&gt;一直以来我都混淆使用这两个 term，其中 i18n 是国际化，主要用于世界通用内容的翻译，&lt;strong&gt;使产品无需做大的改变就能够适应不同的语言和地区的需要&lt;/strong&gt;，包括时间、日期、货币等；而 i10n 是本地化，也就是把网站里其他内容进行翻译。&lt;/p&gt;&lt;h3&gt;content key&lt;/h3&gt;&lt;p&gt;将需要翻译的位置用&lt;strong&gt;Content Key&lt;/strong&gt;占位，在单独的文件里来处理对应的翻译已经成为了本地化的最基本策略。这样做的好处是，1. 保持代码的整洁，无需因为翻译问题不断提交 commit，避免污染 git history；2. 方便不懂代码的运营人员随时调整翻译内容，而无需增加开发负担。&lt;/p&gt;&lt;h3&gt;单复数 pluralization&lt;/h3&gt;&lt;p&gt;举个栗子，如果需要翻译“x 个苹果”，对应的英文会有单复数形式，遇到这种情况的时候，如果缺乏经验，通常是写&lt;code&gt;if&lt;/code&gt; &lt;code&gt;else&lt;/code&gt;， 然后用两个不同的 key：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;key&lt;/th&gt;&lt;th&gt;zh&lt;/th&gt;&lt;th&gt;en&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;webstie.key.apple&lt;/td&gt;&lt;td&gt;个苹果&lt;/td&gt;&lt;td&gt;apple&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;webstie.key.apples&lt;/td&gt;&lt;td&gt;个苹果&lt;/td&gt;&lt;td&gt;apples&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;但是 template 里写太多的 if else 容易使得逻辑混乱，也不利于维护，机智的我今天忽然发现 angular 其实有一个专门的指令来做这个事:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;ng-pluralize count=&amp;quot;personCount&amp;quot;
                 when=&amp;quot;{&amp;#x27;0&amp;#x27;: &amp;#x27;Nobody is viewing.&amp;#x27;,
                     &amp;#x27;one&amp;#x27;: &amp;#x27;1 person is viewing.&amp;#x27;,
                     &amp;#x27;other&amp;#x27;: &amp;#x27;{} people are viewing.&amp;#x27;}&amp;quot;&amp;gt;
&amp;lt;/ng-pluralize&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个指令的本质其实跟 if else 类似，使用了一个 hash map 来储存对应的翻译，而我们可以利用这个指令，把 when 的值写到 controller 里，这样会比较美观 XD&lt;/p&gt;&lt;h3&gt;插值 interpolation&lt;/h3&gt;&lt;p&gt;有时候我们不得不把一整句话打断成多个部分，比如“step 1 of 5 ”，而对应的中文如果要求翻译成“第 1 步（共 5 步）”。这种情况下，如果使用断句的方法来翻译，中文需要有 3 个 key，分别对应&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;lang&lt;/th&gt;&lt;th&gt;part1&lt;/th&gt;&lt;th&gt;part2&lt;/th&gt;&lt;th&gt;part3&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;en&lt;/td&gt;&lt;td&gt;step&lt;/td&gt;&lt;td&gt;of&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;zh&lt;/td&gt;&lt;td&gt;第&lt;/td&gt;&lt;td&gt;步（共&lt;/td&gt;&lt;td&gt;步）&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这样做，不仅不美观，写起来&lt;code&gt;string + string + string&lt;/code&gt;也非常麻烦，同时代码及翻译文件都增加了维护的难度。&lt;/p&gt;&lt;p&gt;大家应该都有经验，在&lt;code&gt;console.log&lt;/code&gt;中，可以使用&lt;code&gt;%s&lt;/code&gt;作为占位符，如果能够使用占位符来进行翻译，以上情况就会简单很多。&lt;/p&gt;&lt;p&gt;Angular 原生的&lt;code&gt;$interpolate&lt;/code&gt;服务，用于编译含有特定标记的字符串，&lt;code&gt;Hello, {% raw %}{{name}}{% endraw %}&lt;/code&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Compiles a string with markup into an interpolation function&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;翻译时，大多时候时候都是用&lt;code&gt;angular-translate&lt;/code&gt;，这个第三方的服务能很好的处理插值，使用的标记是两个花括号&lt;code&gt;{% raw %}{{}}{% endraw %}&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;//基本用法
$translate(translationId[, interpolateParams], interpolationId, defaultTranslationText, forceLanguage);

//例子
$scope.stepInfoText = $filter(&amp;#x27;translate&amp;#x27;)(&amp;#x27;widget-progress-bar.step.text&amp;#x27;, {currentStep:1, totalStep: 5});

//翻译文件 *.properties
widget-progress-bar.step.text=step {{currentStep}} of {{totalStep}}
//output: step 1 of 5
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;参考&lt;/h3&gt;&lt;p&gt;1: &lt;a href=&quot;https://docs.angularjs.org/guide/i18n&quot;&gt;https://docs.angularjs.org/guide/i18n&lt;/a&gt;
2: &lt;a href=&quot;https://docs.angularjs.org/api/ng/directive/ngPluralize&quot;&gt;https://docs.angularjs.org/api/ng/directive/ngPluralize&lt;/a&gt;
3: &lt;a href=&quot;https://stackoverflow.com/questions/27259723/angularjs-pluralization-with-angular-translate-and-ng-pluralize&quot;&gt;https://stackoverflow.com/questions/27259723/angularjs-pluralization-with-angular-translate-and-ng-pluralize&lt;/a&gt;
4: &lt;a href=&quot;https://docs.angularjs.org/api/ng/service/$interpolate&quot;&gt;https://docs.angularjs.org/api/ng/service/$interpolate&lt;/a&gt;
5: &lt;a href=&quot;https://angular-translate.github.io/docs/#/api/pascalprecht.translate.$translate&quot;&gt;https://angular-translate.github.io/docs/#/api/pascalprecht.translate.$translate&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[一点感悟]]></title><description><![CDATA[不知道为什么，我是比较喜欢 JS 这种脑残语言的，并且也不想将其他语言用在工作中，比如 PHP、PYTHON、JAVA 之类的。 其实到最后肯定所有语言都是相通的，比如每种语言都会有自己的 lodash 、 npm 、 package.json…]]></description><link>https://hiitea.io/2017/05/11/thoughts/</link><guid isPermaLink="false">https://hiitea.io/2017/05/11/thoughts/</guid><pubDate>Thu, 11 May 2017 03:21:54 GMT</pubDate><content:encoded>&lt;p&gt;不知道为什么，我是比较喜欢 JS 这种脑残语言的，并且也不想将其他语言用在工作中，比如 PHP、PYTHON、JAVA 之类的。&lt;/p&gt;&lt;p&gt;其实到最后肯定所有语言都是相通的，比如每种语言都会有自己的&lt;code&gt;lodash&lt;/code&gt;、&lt;code&gt;npm&lt;/code&gt;、&lt;code&gt;package.json&lt;/code&gt;，所以当精通一种语言之后是能对其他语言的人指点江山的。我之前的一个同事新手写 python，库也不会用也不知道去哪里下载，我对 Python 的认识只限于这是一个用缩进来控制块的语言，但搜了一下果然有&lt;code&gt;pip&lt;/code&gt;，&lt;code&gt;requirements.txt&lt;/code&gt;&lt;/p&gt;&lt;p&gt;举这个例子是因为我认为，用一个语言用得精通比会用很多语言都是略知一二更重要。&lt;/p&gt;&lt;p&gt;前几天我有一个写 PHP 的同事，被迫去写 nodeJS，然后遇到一个 soap 的问题，调了一天都没调出来，扔给我帮忙。问题大概是，用了一个叫&lt;code&gt;node-soap&lt;/code&gt;的库，发请求的时候对方服务器总是返回&lt;code&gt;ERROR Invalid XML&lt;/code&gt;，而用 Postman 把请求的 body 发出去，却能得到成功的返回结果，同事怀疑这个第三方库有问题。&lt;/p&gt;&lt;p&gt;我虽然对 SOAP 一窍不通，但我懂 JS，觉得这个问题应该能找出原因。根据以前的经验，我觉得不太可能是第三方库的问题，因为每次只使用基本方法却有问题时我 debug 到别人库里去看明白原理之后，绝大多数时候都会发现是自己的问题。更何况这是一个 1500+ star 的库。&lt;/p&gt;&lt;p&gt;首先我想到的是，肉眼看上去同样的 body，为什么得到不同的结果？很可能是 encoding 的问题。单步调试后发现库里并没有任何 encoding 的动作，所以排除该问题。&lt;/p&gt;&lt;p&gt;后来我注意到，第三方库在发送请求的时候发了很多 header，把这些 header 也写进 postman 之后，果然返回了同样的错误。而之前同事测试时，postman 里 header 都是默认值。所以可以肯定问题出在 header 上。&lt;/p&gt;&lt;p&gt;删除了&lt;code&gt;SOAPAction&lt;/code&gt;这个 header 之后，请求就成功了。再具体到库里去搜这个&lt;code&gt;SOAPAction&lt;/code&gt;，发现有一段&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;if (!this.wsdl.options.forceSoap12Headers) {
  headers.SOAPAction = &amp;#x27;&amp;quot;&amp;#x27; + soapAction + &amp;#x27;&amp;quot;&amp;#x27;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;猜测应该是有一个&lt;code&gt;forceSoap12Headers&lt;/code&gt;相关的设置，再去文档里一搜，果然有，把这个设置为&lt;code&gt;true&lt;/code&gt;之后，问题就解决了。前后大概花了一小时。&lt;/p&gt;&lt;p&gt;写这篇是想说，磨刀不误砍柴工，首先你得学会怎么磨刀，然后得学会怎么砍柴，这样才能磨刀不误砍柴工。对于一个完全不熟悉的东西，因为掌握了最基本的方法，才能万物归一的去解决。&lt;/p&gt;&lt;p&gt;我反对对于不熟悉的东西，一上来就通看文档。在工作当中，是没有那么多时间让你从头去看文档，把所有东西都弄明白之后才开始工作的。
文档对于没有经验的人来说看 quick start 部分就够，因为就算看到&lt;code&gt;forceSoap12Headers&lt;/code&gt;，也不知道是干什么用的。
对于有经验的人，才会需要在一开始就去细看&lt;code&gt;forceSoap12Headers&lt;/code&gt;的设置&lt;/p&gt;&lt;p&gt;我也反对把写一种语言的员工强行安排暂时写另一种语言。除非是打算长期转向另一种语言，否则一两天做完一个 task，根本不会对新的语言有系统性的研究，甚至都不知道 debug 的工具怎么用，对个人的发展是没什么实质性的帮助的，而且写出来的代码大都只能达到“能用”的程度，可维护性和稳定性都不一定会好，长远来看对公司也是不太好的。不过创业公司嘛，半年一次 revamp，好像也没什么问题…&lt;/p&gt;</content:encoded></item><item><title><![CDATA[openvpn在mac下的一点问题]]></title><description><![CDATA[今天才发现自从买了新 Mac 之后根本没有用新电脑写过什么东西，导致我今天居然还要 npm install 才能跑起来 HEXO，真是不知道有多懒。 作为一个在墙外居住了好几年的人，只知道用 Unblock youku…]]></description><link>https://hiitea.io/2017/01/03/vpn/</link><guid isPermaLink="false">https://hiitea.io/2017/01/03/vpn/</guid><pubDate>Tue, 03 Jan 2017 06:42:57 GMT</pubDate><content:encoded>&lt;p&gt;今天才发现自从买了新 Mac 之后根本没有用新电脑写过什么东西，导致我今天居然还要&lt;code&gt;npm install&lt;/code&gt;才能跑起来 HEXO，真是不知道有多懒。&lt;/p&gt;&lt;p&gt;作为一个在墙外居住了好几年的人，只知道用 Unblock youku 翻墙进墙内去看视频，根本不知道在墙内怎么翻出来。早些年的时候，翻到墙外是很简单的，免费的软件也很多，好像也不用 VPN 啥，host 文件里加几个 IP 啥的就能上 Google 了，现在真是门槛越来越高了呢……回一趟内地 80%我平时上的网站都上不去，公司的网站也上不去，反正根本没法 work from home，幸好我是在过年前发现了这个问题，现在还来得及解决一下，不然就呵呵呵呵……&lt;/p&gt;&lt;p&gt;以前好像也用过&lt;code&gt;.ovpn&lt;/code&gt;文件，用命令行跑一下，就连上了 vpn，现在已经不记得是怎么用了的…今天忽然发现公司居然有 openvpn，妈妈再也不用担心我在内地没法工作了，对的，我的心里只有工作！:P&lt;/p&gt;&lt;p&gt;通常公司提供的 openvpn 服务都会有一个 portal，也就是有个网址，进入之后需要登录公司提供的账号，然后下载相应的客户端，之后基本上是无脑使用……反正我到现在也不知道我电脑上的 credentials 是怎么生成的。&lt;/p&gt;&lt;p&gt;然而高贵的 mac 总是有各种各样的问题，装好 openvpn connect 之后居然连接错误&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Fails: Error running jsondialog
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查了一下这是因为 mac 下的一个什么&lt;code&gt;csrutil&lt;/code&gt;保护机制出于 enable 状态，&lt;code&gt;csrutil status&lt;/code&gt;可查看。而 disable 这个东西需要在 recovery mode 下跑命令才行……真是麻烦呢。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;重启电脑，按住 cmd+r 键进入 recovery mode&lt;/li&gt;&lt;li&gt;开头会让选个语言，选完之后会出来一个对话框，里面有好多选项，一个都不要选！&lt;/li&gt;&lt;li&gt;在顶部的工具条中点击 utilities，然后选 terminal&lt;/li&gt;&lt;li&gt;在命令行工具中执行&lt;code&gt;csrutil disable; reboot&lt;/code&gt;&lt;/li&gt;&lt;li&gt;重启之后就能连接上了&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;参考：
[1]&lt;a href=&quot;https://forums.openvpn.net/viewtopic.php?t=19879&quot;&gt;https://forums.openvpn.net/viewtopic.php?t=19879&lt;/a&gt;
[2]&lt;a href=&quot;http://osxdaily.com/2015/10/05/disable-rootless-system-integrity-protection-mac-os-x/&quot;&gt;http://osxdaily.com/2015/10/05/disable-rootless-system-integrity-protection-mac-os-x/&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[一些js小技巧]]></title><description><![CDATA[一直以为这篇已经发过了，结果前两天搜的时候发现搜不到。一直扔在草稿里，今天整理一下之前和最近学到的一些 JS 小技巧 利用位运算取整 利用位运算，与、或、异或、左右移位， &   |   ^   >>   >>>   <<  ，舍去小数点后的数字 ， jsPerf…]]></description><link>https://hiitea.io/2016/10/19/some-js-tricks/</link><guid isPermaLink="false">https://hiitea.io/2016/10/19/some-js-tricks/</guid><pubDate>Wed, 19 Oct 2016 07:08:33 GMT</pubDate><content:encoded>&lt;p&gt;一直以为这篇已经发过了，结果前两天搜的时候发现搜不到。一直扔在草稿里，今天整理一下之前和最近学到的一些 JS 小技巧&lt;/p&gt;&lt;h3&gt;利用位运算取整&lt;/h3&gt;&lt;p&gt;利用位运算，与、或、异或、左右移位，&lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; ，舍去小数点后的数字&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;，&lt;a href=&quot;http://jsperf.com/coercion-vs-casting/3&quot;&gt;jsPerf&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var a = 6.54321;
console.log(a | 0); //6
console.log(a &amp;amp; 0); //6
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;按位&lt;strong&gt;非非&lt;/strong&gt;运算也是可以的，所以你也可以用&lt;strong&gt;呻吟号&lt;/strong&gt;把代码写成这样&lt;code&gt;~~a&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;+ 字符串转换为数字&lt;/h3&gt;&lt;p&gt;利用加号 &lt;code&gt;+&lt;/code&gt; 将数字字符串转换为数字类型&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var a = &amp;#x27;56789&amp;#x27;;
var b = +a;
console.log(typeof b); //number
console.log(b); //56789
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;只能是十进制&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;如果&lt;code&gt;a&lt;/code&gt;是非数字字符串，则会返回&lt;code&gt;NaN&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;!! 强制转换为布林类型&lt;/h3&gt;&lt;p&gt;利用&lt;code&gt;!!&lt;/code&gt;将变量类型强制转换为&lt;code&gt;boolean&lt;/code&gt;类型&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var a = 123;
typeof a; //nmuber
typeof !!a; //boolean
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;避免&lt;code&gt;can not read property ‘xxx’ of null&lt;/code&gt;的小技巧&lt;/h3&gt;&lt;p&gt;经常会遇到的一个情况是下面的代码会报错&lt;code&gt;can not read property &amp;#x27;c&amp;#x27; of null&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;if (a.b.c === 1) {
  //do something
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以前自己的写法以及经常见到的写法是这样&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;if (a &amp;amp;&amp;amp; a.b &amp;amp;&amp;amp; a.b.c === 1) {
  //do something
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;前几天看到一个逼格很高的写法，不过我觉得括号太多了，容易写错，而且也没有上面的那种写法简单。不过还是要记录一下，以免以后见到不知道是什么意思。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;if (((a || {}).b || {}).c === 1) {
  //do something
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;|| 设置默认值&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function abc(a, b) {
  a = a || 1;
  b = b || 2;

  return a + b;
}

abc(); //3
abc(5); //7
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有一些情况下函数中需要设置默认值，经常看到有人的写法是&lt;code&gt;typeof&lt;/code&gt;先判断这个参数是不是&lt;code&gt;undefined&lt;/code&gt;然后再赋值，这种写法实在是太麻烦了……上面的是懒人写法&lt;/p&gt;&lt;p&gt;感觉善用&lt;code&gt;||&lt;/code&gt;和&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;还是能搞出很多黑科技的。&lt;/p&gt;&lt;p&gt;以上，是为打酱油博客一篇。&lt;/p&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://github.com/hexojs/hexo-cli/blob/master/lib/goodbye.js&quot;&gt;https://github.com/hexojs/hexo-cli/blob/master/lib/goodbye.js&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/kkun/archive/2012/01/30/2332309.html&quot;&gt;http://www.cnblogs.com/kkun/archive/2012/01/30/2332309.html&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[CSS的几个小技巧：pointer-events, transform垂直居中,nth-child]]></title><description><![CDATA[千万不要用没有自动保存功能的编辑器！千万不要用没有自动保存功能的编辑器！千万不要用没有自动保存功能的编辑器！:( 好久没有写什么东西了，可能是因为最近一直做的事情都是在重复搬砖，没有什么新鲜的东西…更可能是因为太懒了… 总结一下前段时间学到的几个 css…]]></description><link>https://hiitea.io/2016/09/20/some-css-tricks/</link><guid isPermaLink="false">https://hiitea.io/2016/09/20/some-css-tricks/</guid><pubDate>Tue, 20 Sep 2016 08:44:46 GMT</pubDate><content:encoded>&lt;blockquote&gt;&lt;p&gt;千万不要用没有自动保存功能的编辑器！千万不要用没有自动保存功能的编辑器！千万不要用没有自动保存功能的编辑器！:(&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;好久没有写什么东西了，可能是因为最近一直做的事情都是在重复搬砖，没有什么新鲜的东西…更可能是因为太懒了…&lt;/p&gt;&lt;p&gt;总结一下前段时间学到的几个 css 小技巧，以免过几天又忘记了&lt;/p&gt;&lt;h3&gt;CSS 控制超链接是否可点击：pointer-event&lt;/h3&gt;&lt;p&gt;一开始我听说 CSS 可以 disable 超链接的时候我是拒绝的，因为通常在有&lt;code&gt;href&lt;/code&gt;属性的时候，都是用 js 来禁止超链接的。
然鹅…CSS 里居然有 pointer-events&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;这种黑科技！&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;a {
  pointer-events: none;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;transform 垂直居中 &lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;&lt;p&gt;CSS 垂直居中一直是一个蛋疼的问题，常常需要用到，却没有一个所有浏览器，在所有情况下都适用的解决方案。等我以后有空了，应该专门写一篇讨论 CSS 垂直居中各种解决方案的博客……别问我以后是什么时候…XD&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;style&amp;gt;
.bbb{
    position: relative;
    transform: translateY(-50%);
    top: 50%
}
&amp;lt;/style&amp;gt;
&amp;lt;div class=&amp;quot;aaa&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;bbb&amp;quot;&amp;gt;qqq&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;nth-child&lt;/h3&gt;&lt;p&gt;通常一个列表里，总是回遇到需要高亮某几个 item 的情况，CSS 居然还可以通过公式来控制样式，我又涨姿势了。&lt;/p&gt;&lt;p&gt;以前只知道可以控制奇数偶数这种简单的，后来发现，只要是有规律的，能够写成 an+b 的公式，都可以适用&lt;code&gt;nth-child&lt;/code&gt;&lt;sup id=&quot;fnref-3&quot;&gt;&lt;a href=&quot;#fn-3&quot; class=&quot;footnote-ref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;li:nth-child(even)&lt;/code&gt; 选中偶数&lt;/li&gt;&lt;li&gt;&lt;code&gt;li:nth-child(odd)&lt;/code&gt; 选中奇数&lt;/li&gt;&lt;li&gt;&lt;code&gt;li:nth-child(3n+2)&lt;/code&gt; 从第 2 个开始，每 3 个选中一个&lt;/li&gt;&lt;li&gt;&lt;code&gt;li:nth-child(3)&lt;/code&gt; 直选中第 3 个&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/pointer-events&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/CSS/pointer-events&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;http://zerosixthree.se/vertical-align-anything-with-just-3-lines-of-css/&quot;&gt;http://zerosixthree.se/vertical-align-anything-with-just-3-lines-of-css/&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-3&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child&lt;/a&gt;&lt;a href=&quot;#fnref-3&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Jenkins集成github pull request插件]]></title><description><![CDATA[前不久给 bootstrap 提了个 issue ，然后被他们的高科技自动回复机器人吓萌比了。
有印象之前给，某些 repo 提 PR 的时候，如果是用的 Travis CI，也会有相应的提示该 PR 是否 pass 了所有 test case。 如果使用 cloud based…]]></description><link>https://hiitea.io/2016/07/14/jenkins-github-pull-request-builder/</link><guid isPermaLink="false">https://hiitea.io/2016/07/14/jenkins-github-pull-request-builder/</guid><pubDate>Thu, 14 Jul 2016 06:41:02 GMT</pubDate><content:encoded>&lt;p&gt;前不久给 bootstrap 提了个&lt;a href=&quot;https://github.com/twbs/bootstrap/issues/19997&quot;&gt;issue&lt;/a&gt;，然后被他们的高科技自动回复机器人吓萌比了。
有印象之前给，某些 repo 提 PR 的时候，如果是用的 Travis CI，也会有相应的提示该 PR 是否 pass 了所有 test case。&lt;/p&gt;&lt;p&gt;如果使用 cloud based CI，很多功能都已经整合了，所以可以很方便的使用。如上 travis 的例子，只要在 travis 配置里开启 pull request 选项，允许 PR 过来的时候自动跑测试，就可以实现。&lt;/p&gt;&lt;p&gt;然而，如果使用的是 jenkins 这种自己服务器上的 CI，配置就稍微有点麻烦了。&lt;/p&gt;&lt;h3&gt;整合 push 和 jenkins&lt;/h3&gt;&lt;p&gt;github repo 页面 &amp;gt; Settings &amp;gt; webhooks &amp;amp; services&lt;/p&gt;&lt;p&gt;这里有两个选项：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;add webhook，可自定义触发事件，可定制程度较高&lt;/li&gt;&lt;li&gt;add service，选好对应的服务，只填一个 url 即可，可定制程度较低。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第一个比较复杂，但是点进去看看有哪些选项也就比较清晰明了大概用法了。
第二个，如果使用 jenkins，需要你的 jenkins 服务器装有对应的插件。&lt;/p&gt;&lt;p&gt;整个流程的原理是，当 github 收到任何事件（比如 push, pr 等等），就会将对应的信息发送到你填的那个 url 中。这个 url 是你 jenkins 服务器用来接受信息的。Jenkins 收到信息之后，就会根据 job 的配置做相应的事情，比如构建、测试、部署等等。&lt;/p&gt;&lt;h3&gt;整合 pull request&lt;/h3&gt;&lt;p&gt;这里重点说一下怎么整合 jenkins 和 github 的 pull request，&lt;strong&gt;实现每当有 pull request 时，触发 CI 跑测试，并将测试结果显示在 github 上&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;这里需要分别在 github 和 jenkins 做相应的设置。&lt;/p&gt;&lt;p&gt;github 中的设置与上部分提到的相同，主要是填 url&lt;/p&gt;&lt;p&gt;jenkins 服务器中：
首先需要安装 &lt;a href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/GitHub+pull+request+builder+plugin&quot;&gt;github pull request builder plugin&lt;/a&gt;&lt;/p&gt;&lt;p&gt;添加用户名、密码、token 等等 credentials 相关的需要在 jenkins 的管理面板添加&lt;/p&gt;&lt;ul&gt;&lt;li&gt;source code management，除基本选项外，需要填写 advanced 选项。&lt;ul&gt;&lt;li&gt;repo name: &lt;code&gt;origin&lt;/code&gt;&lt;/li&gt;&lt;li&gt;repo refspec: &lt;code&gt;+refs/pull/*:refs/remotes/origin/pr/*&lt;/code&gt;&lt;/li&gt;&lt;li&gt;repository browser 选择 githubweb&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Build Triggers:&lt;ul&gt;&lt;li&gt;勾选 Github Pull Request Builder&lt;/li&gt;&lt;li&gt;勾选 Use github hooks for build triggering&lt;/li&gt;&lt;li&gt;Admin List 里可以填写 github 用户名，这样该用户就会有对应的权限&lt;/li&gt;&lt;li&gt;advanced 选项中，需要在 White List 以及 List of organizetions 填写相应的用户名，这样 PR 才能被自动 build，不在白名单里的用户提交的 pr 需要管理员审核后才会 build&lt;/li&gt;&lt;li&gt;如果没有勾选 Build every pull request automatically without asking (Dangerous!)，每次有 pr 时，机器人账号会自动评论&lt;em&gt;&amp;quot;Can one of the admins verify this patch?&amp;quot;&lt;/em&gt;，之后管理员回复相应的语句来触发 Jenkins 操作 - &amp;quot;ok to test&amp;quot; 允许该 pr 之后自动触发 jenkins build - &amp;quot;test this please&amp;quot; 只 build 一次，该 pr 之后的改动不会自动触发 Build - &amp;quot;add to whitelist&amp;quot; 将该 pr 的作者假如白名单 - &amp;quot;retest this please&amp;quot; 重新 bulid 一次
&lt;strong&gt;其他选项都保持默认不要更改！&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;构建、环境相关的设置例如&lt;code&gt;npm install&lt;/code&gt; &lt;code&gt;npm test&lt;/code&gt;等，跟平时一样即可。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最后保存设置，提交一个 pr，如果设置都正确的话，在提交 pr 的页面将能看到一个“正在 checking...”的提示，当测试跑完之后将能看到 check passed 或者 check failed。另外也能够在 pr overview 页面看到 pr 后面会有个绿色的小勾或红色的小叉。&lt;/p&gt;&lt;p&gt;于是谁提交的 pr 不通过测试就能一目了然，再也不用帮别人 fix test case 啦！&lt;/p&gt;&lt;h3&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://jakubstas.com/github-and-jenkins-pull-request-checking&quot;&gt;http://jakubstas.com/github-and-jenkins-pull-request-checking&lt;/a&gt;
&lt;a href=&quot;http://jakubstas.com/github-and-jenkins-integration&quot;&gt;http://jakubstas.com/github-and-jenkins-integration&lt;/a&gt;
&lt;a href=&quot;https://www.theguild.nl/building-github-pull-requests-with-jenkins&quot;&gt;https://www.theguild.nl/building-github-pull-requests-with-jenkins&lt;/a&gt;
&lt;a href=&quot;https://wiki.jenkins-ci.org/display/JENKINS/GitHub+pull+request+builder+plugin&quot;&gt;https://wiki.jenkins-ci.org/display/JENKINS/GitHub+pull+request+builder+plugin&lt;/a&gt;
&lt;a href=&quot;https://github.com/jenkinsci/ghprb-plugin&quot;&gt;https://github.com/jenkinsci/ghprb-plugin&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[微博开放平台的Basic Auth和OAuth2.0认证]]></title><description><![CDATA[这篇文章不是讲各种认证方式是怎么实现的，只是简单的介绍如何与微博进行整合。 微博开放平台允许使用 api 来开发一些与微博相关的应用，微博提供 Basic Auth 和 OAuth2.0 两种认证方式，其中 Basic Auth 只能用于测试环境。 Basic Auth…]]></description><link>https://hiitea.io/2016/06/20/intro-of-oauth2-0/</link><guid isPermaLink="false">https://hiitea.io/2016/06/20/intro-of-oauth2-0/</guid><pubDate>Mon, 20 Jun 2016 09:59:09 GMT</pubDate><content:encoded>&lt;p&gt;这篇文章不是讲各种认证方式是怎么实现的，只是简单的介绍如何与微博进行整合。&lt;/p&gt;&lt;p&gt;微博开放平台允许使用 api 来开发一些与微博相关的应用，微博提供&lt;strong&gt;Basic Auth&lt;/strong&gt;和&lt;strong&gt;OAuth2.0&lt;/strong&gt;两种认证方式，其中 Basic Auth 只能用于测试环境。&lt;/p&gt;&lt;h3&gt;Basic Auth&lt;/h3&gt;&lt;p&gt;跟名字一样，就是很基本很简单。其本质是使用&lt;code&gt;username:password&lt;/code&gt;进行&lt;code&gt;base64&lt;/code&gt;加密之后得到一个 token，然后发送的请求中添加一个 header &lt;code&gt;Authorization: Basic token&lt;/code&gt;。&lt;/p&gt;&lt;h3&gt;OAuth 2.0&lt;/h3&gt;&lt;p&gt;生产环境中，微博只允许使用这种认证方式，这个比起直接用用户名和密码就要复杂一些。&lt;/p&gt;&lt;p&gt;简单的来说 OAuth2.0 认证的流程大概是这样：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;首先发一个请求去微博，告诉它，我要登陆啦&lt;/li&gt;&lt;li&gt;然后微博返回一个登录页面，等待用户用微博账号登陆&lt;/li&gt;&lt;li&gt;用户登陆之后，页面会跳转到&lt;strong&gt;授权回调页&lt;/strong&gt;，这个页面的 url 会有一个 query 是&lt;code&gt;code=&lt;/code&gt;，后面跟着的一串 code&lt;/li&gt;&lt;li&gt;当进行其他 api 调用时，在 api 后加上 query&lt;code&gt;code=xxx&lt;/code&gt;以及其他要求的参数，比如&lt;code&gt;client_id&lt;/code&gt;，&lt;code&gt;client_key&lt;/code&gt;等等即可进行调用&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;开放平台&amp;gt;我的应用&amp;gt;应用信息&amp;gt;基本信息，这里能看到 app key 和 app token&lt;/li&gt;&lt;li&gt;开放平台&amp;gt;我的应用&amp;gt;应用信息&amp;gt;高级信息，这里需要填写授权回调页和取消授权回调页&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;需要注意的是，在第 2 步和第 3 步中，授权回调页的链接一定要和在申请 app 时填写的&lt;strong&gt;一！模！一！样！&lt;/strong&gt;，否则会报错。&lt;/p&gt;&lt;p&gt;比如在 app 填写的是&lt;code&gt;http://example.com/auth/&lt;/code&gt;，而 api 请求时参数写为&lt;code&gt;http://example.com/auth&lt;/code&gt;，少了个斜杠都是错的…&lt;/p&gt;&lt;h3&gt;参考&lt;/h3&gt;&lt;p&gt;[1] &lt;a href=&quot;http://open.weibo.com/wiki/Oauth2/authorize&quot;&gt;http://open.weibo.com/wiki/Oauth2/authorize&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[利用travis进行heroku部署]]></title><description><![CDATA[好久么有写东西了，总感觉一直忙的跟狗一样，身心俱疲，但是又不知道到底在忙什么。 最近实践了一下利用 travis 部署到 heroku 的流程，又莫名其妙的尝试了新的编辑器 atom，安装了 markdown-preview-plus…]]></description><link>https://hiitea.io/2016/06/02/travis-heroku/</link><guid isPermaLink="false">https://hiitea.io/2016/06/02/travis-heroku/</guid><pubDate>Thu, 02 Jun 2016 07:27:46 GMT</pubDate><content:encoded>&lt;p&gt;好久么有写东西了，总感觉一直忙的跟狗一样，身心俱疲，但是又不知道到底在忙什么。&lt;/p&gt;&lt;p&gt;最近实践了一下利用 travis 部署到 heroku 的流程，又莫名其妙的尝试了新的编辑器 atom，安装了 markdown-preview-plus 插件，当然要来写点东西试一试， 也不知道英文的 linux 下到底是什么问题，webstorm 和 sublime 居然不能打中文，所以之前每次写东西都要去简书边预览边写。&lt;/p&gt;&lt;p&gt;atom 还是很好用的，可能因为我（后）天生就对 JS 写的东西有好感，记不住快捷键的我，不能徒手写 html 的我还是需要 IDE 的帮助，atom 就用来写点简单的东西吧。&lt;/p&gt;&lt;p&gt;travis 和 heroku 都有自己的命令行工具（CLI），尤其 travis cli 用起来总比徒手写.travis.yml 方便许多&lt;/p&gt;&lt;h3&gt;安装 travis-cli&lt;/h3&gt;&lt;p&gt;travis-cli 是 ruby 写的，所以安装之前需要安装 ruby&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install ruby-full
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;详细的安装教程可以看官方的这个&lt;a href=&quot;https://github.com/travis-ci/travis.rb#installation&quot;&gt;https://github.com/travis-ci/travis.rb#installation&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;gem install travis -v 1.8.2 --no-rdoc --no-ri
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;安装 heroku-cli&lt;/h3&gt;&lt;p&gt;heroku-cli 也是 ruby 写的……有点不懂为啥都喜欢用 ruby 写 cli？js 不是挺好的吗，有啥 cli 是&lt;code&gt;npm install -g&lt;/code&gt; 解决不了的吗？…
具体的安装教程看&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://toolbelt.heroku.com&quot;&gt;https://toolbelt.heroku.com&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://devcenter.heroku.com/articles/heroku-command#installing-the-heroku-cli&quot;&gt;https://devcenter.heroku.com/articles/heroku-command#installing-the-heroku-cli&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;wget -O- https://toolbelt.heroku.com/install-ubuntu.sh | sh
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;登陆&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;travis login
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;heroku login
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;.travis.yml&lt;/h3&gt;&lt;p&gt;在项目的根目录下执行以下命令，将会生成&lt;code&gt;.travis.yml&lt;/code&gt;文件&lt;/p&gt;&lt;pre&gt;&lt;code&gt;travis init
travis setup heroku
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;注意：一定要通过命令行登陆 heroku，否则 travis 会卡住，也不报错啥的反正就一直没反应&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;打开&lt;code&gt;.travis.yml&lt;/code&gt;文件可以看到除了基本的信息之外，还有&lt;code&gt;deploy&lt;/code&gt;相关的信息，其中比较让人疑惑的是&lt;code&gt;api_key&lt;/code&gt;，这个&lt;code&gt;api_key&lt;/code&gt;其实是你的 heroku 账户的 token 加密之后的一个字符串。heroku 的 token 看起来是一个类似 uuid5 的字符串，可以通过以下命令查看&lt;/p&gt;&lt;pre&gt;&lt;code&gt;heroku auth:token
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有一个问题我不太明白的是，之前用 travis 加密文件&lt;code&gt;travis encrypt-file path/of/file --add&lt;/code&gt;的时候，可以在 travis 网站对应 repo 的 setting 里看到多出的环境变量，用来加密的 key value，然后需要用&lt;code&gt;openssl&lt;/code&gt;命令来解密。&lt;/p&gt;&lt;p&gt;但加密 heroku 的 token 后，并没有生成任何新的环境变量，而且也无需在&lt;code&gt;.travis.yml&lt;/code&gt;中执行解密的相关操作。&lt;/p&gt;&lt;p&gt;那么用来加密的 key value 到底存在哪里了呢？！&lt;/p&gt;&lt;h3&gt;为什么要在 travis 做部署，而不直接利用 heroku 提供的 github 自动部署？&lt;/h3&gt;&lt;p&gt;首先，heroku 似乎不能跑测试…&lt;/p&gt;&lt;p&gt;其实，大多数简单的项目其实都可以用 github 的方式，如果需要编译和生成的，都在&lt;code&gt;package.json&lt;/code&gt;里添加&lt;code&gt;prepublish&lt;/code&gt;脚本即可&lt;/p&gt;&lt;p&gt;我这次又是搞了一个奇怪的事情，做了一个前后端分离项目，后端提供 RESTful API,前端是 SPA，但是又想把 SPA 和 API 放在同一个服务器，而且分了两个 repo 来放前端和后端。&lt;/p&gt;&lt;p&gt;所以我的需求是，当前端或后端 push 之后，trigger travis 去把前后端都克隆下来，并且编译和 Build 前端代码，放到指定文件夹，然后部署。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[微信撤回信息昵称显示原理分析]]></title><description><![CDATA[吐槽 为了让各位亲朋好友方便的用撤回信息装 x…]]></description><link>https://hiitea.io/2016/04/21/theory-analysis-for-wechat-recall-message-nickname/</link><guid isPermaLink="false">https://hiitea.io/2016/04/21/theory-analysis-for-wechat-recall-message-nickname/</guid><pubDate>Thu, 21 Apr 2016 09:07:08 GMT</pubDate><content:encoded>&lt;h3&gt;吐槽&lt;/h3&gt;&lt;p&gt;为了让各位亲朋好友方便的用撤回信息装 x，本宝宝写了一个&lt;a href=&quot;http://sabrinaluo.com/nickname-gen&quot;&gt;昵称生成器&lt;/a&gt;
虽然是比较简单的页面，但本宝宝还没发布呢，微信就封了这个功能，宝宝心里委屈但宝宝不说…&lt;/p&gt;&lt;h3&gt;起因&lt;/h3&gt;&lt;p&gt;今天早些时候，在微信群里看到了这样的撤回信息：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;quot;牛奶&amp;quot;撤回了一条信息并亲了你一下
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;开始的时候我是一脸懵逼的，然后知道复制牛奶的昵称，然后再修改就可以实现这个效果，&lt;strong&gt;一定要复制，一个字一个字打就不行&lt;/strong&gt;。
之后有同学转发了&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAwNDY5NzI4MQ==&amp;amp;mid=505551279&amp;amp;idx=1&amp;amp;sn=f10a4b837a10ed9c4a252c606f2f7c7f&amp;amp;scene=1&amp;amp;srcid=0421JP3AeSA1CmbSqEn1rLMh&amp;amp;from=singlemessage&amp;amp;isappinstalled=0&amp;amp;pass_ticket=HbJ8e6BomIu6b3R%2Bi6i69%2FT2TY3g%2FHUMQSItE5M2cd8%3D&quot;&gt;一篇文章&lt;/a&gt;，然后大家纷纷搞出了各种有趣的效果：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;1. &amp;quot;zz并亲了你一下&amp;quot;撤回了一条消息
2. &amp;quot;朱饼饼息消条一了回撤&amp;quot;并又瘦了一斤
3. &amp;quot;仝哈哈&amp;quot;撤回了一条消息下一你了亲并
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;分析&lt;/h3&gt;&lt;p&gt;机智的我一开始就猜到，肯定是有些什么看不见的特殊字符导致的。&lt;/p&gt;&lt;p&gt;作为一只前端狗，首先想到的当然是打开 web 微信，F12，看看昵称里到底是什么鬼，果然不出所料，我的昵称是这样的：&lt;code&gt;&amp;amp;#8238;&amp;amp;#8238;&amp;amp;#8238; 用卵么什有没并而然&amp;amp;#8237;萝卜&lt;/code&gt;&lt;/p&gt;&lt;p&gt;于是开始找这个&lt;code&gt;&amp;amp;#8238;&lt;/code&gt;特殊字符到底是做什么的，机智的我很快就找到了&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;
首先这种字符叫做&lt;em&gt;Unicode_control_characters&lt;/em&gt;&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;
要知道更详细的内容（比如这种字符最开始是用于阿拉伯文等东亚文字的排版，另外类似的字符还有好几个，但）可以看看 wiki 的双向文稿&lt;sup id=&quot;fnref-3&quot;&gt;&lt;a href=&quot;#fn-3&quot; class=&quot;footnote-ref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;，还有其他更详细的使用范例&lt;sup id=&quot;fnref-4&quot;&gt;&lt;a href=&quot;#fn-4&quot; class=&quot;footnote-ref&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;html 特殊符号&lt;/th&gt;&lt;th align=&quot;center&quot;&gt;js unicode&lt;/th&gt;&lt;th align=&quot;left&quot;&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;&amp;amp;#8237;&lt;/code&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;\u202D&lt;/code&gt;&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;Unicode Character &amp;#x27;LEFT-TO-RIGHT OVERRIDE&amp;#x27;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;&amp;amp;#8238;&lt;/code&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;\u202E&lt;/code&gt;&lt;/td&gt;&lt;td align=&quot;left&quot;&gt;Unicode Character &amp;#x27;RIGHT-TO-LEFT OVERRIDE&amp;#x27;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;所以&lt;code&gt;8237&lt;/code&gt;的作用是从左到右显示，&lt;code&gt;8238&lt;/code&gt;的作用是从右到左显示。&lt;/p&gt;&lt;p&gt;也就是说，跟在&lt;code&gt;8238&lt;/code&gt;后面的字符串将从右到左显示（原来的排版方式会被 override，直到遇到其他的控制排版的字符(Unicode_control_characters)）；而跟在&lt;code&gt;8237&lt;/code&gt;后面的字符串将从左到右显示。&lt;/p&gt;&lt;p&gt;由于大家在复制的时候根本看不到这些字符，而且可能因为在修改昵称时&lt;strong&gt;删除&lt;/strong&gt;或&lt;strong&gt;加多&lt;/strong&gt;了这些特殊符号，所以产生了各种奇怪的效果。而前面提到的最正确我的昵称应该是只有一个&lt;code&gt;8238&lt;/code&gt;，也就是这样&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;amp;#8238;用卵么什有没并而然&amp;amp;#8237;萝卜
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;微信撤回信息的显示逻辑是，&lt;code&gt;&amp;quot;昵称&amp;quot;+撤回了一条信息&lt;/code&gt;，昵称前后是有引号的。
所以实际上，撤回信息的&lt;strong&gt;字符串&lt;/strong&gt;是&lt;code&gt;&amp;quot;&amp;amp;#8238;用卵么什有没并而然&amp;amp;#8237;萝卜&amp;quot;撤回了一条信息&lt;/code&gt;。
根据之前提到的&lt;code&gt;8238&lt;/code&gt;和&lt;code&gt;8237&lt;/code&gt;的作用以及前提条件（正常情况下我们看到的字都是从左到右显示），分解过程如下：（LTR 从左到右，RTL 从右到左）&lt;/p&gt;&lt;ol&gt;&lt;li&gt;`第一个引号是正常显示，这个引号是 LTR 显示的强字符： （&amp;quot;）&lt;/li&gt;&lt;li&gt;&lt;code&gt;&amp;amp;#8238;&lt;/code&gt;后面的 &lt;em&gt;用卵么什有没并而然&lt;/em&gt; 是 RTL 显示的强字符：（&amp;quot;然而并没有什么卵用）&lt;/li&gt;&lt;li&gt;&lt;code&gt;&amp;amp;#8237;&lt;/code&gt;后面的 &lt;em&gt;萝卜&amp;quot;撤回了一条信息&lt;/em&gt; 是 LTR 显示的强字符，所以会&lt;strong&gt;紧跟&lt;/strong&gt;前面的 LTR 的强字符，也就是紧跟第一个引号 ：（&amp;quot;萝卜&amp;quot;撤回了一条信息然而并没有什么卵用）&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;其他&lt;/h3&gt;&lt;p&gt;上面提到的有趣的效果分析：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;根本没有复制到特殊符号&lt;/li&gt;&lt;li&gt;复制到特殊符号，但&amp;quot;并亲了你一下&amp;quot;被写反了，实际的文本为&lt;code&gt;&amp;amp;#8238;并亲了你一下&amp;amp;#8237;仝哈哈&lt;/code&gt;&lt;/li&gt;&lt;li&gt;复制到的特殊符号不正确，实际的文本为&lt;code&gt;&amp;amp;#8238;斤一了瘦又并&amp;amp;#8237;朱饼饼&amp;amp;#8238;&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;http://www.fileformat.info/info/unicode/char/202e/index.htm&quot;&gt;http://www.fileformat.info/info/unicode/char/202e/index.htm&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_control_characters&quot;&gt;https://en.wikipedia.org/wiki/Unicode_control_characters&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-3&quot;&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9B%99%E5%90%91%E6%96%87%E7%A8%BF&quot;&gt;https://zh.wikipedia.org/wiki/%E9%9B%99%E5%90%91%E6%96%87%E7%A8%BF&lt;/a&gt;&lt;a href=&quot;#fnref-3&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-4&quot;&gt;&lt;a href=&quot;https://www.w3.org/International/questions/qa-bidi-unicode-controls&quot;&gt;https://www.w3.org/International/questions/qa-bidi-unicode-controls&lt;/a&gt;&lt;a href=&quot;#fnref-4&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[如何通过Git钩子自动部署(Push to Deploy)]]></title><description><![CDATA[看了好多讲通过 git 钩子自动部署的，大多讲的绕来绕去乱七八糟思路一点也不清晰…
做了一晚上实验之后大概明白了是怎么工作的。 裸仓库（bare） 裸仓库跟我们平时 git clone 得到的仓库不太一样，裸仓库其实相当于通过克隆来的仓库里的 .git…]]></description><link>https://hiitea.io/2016/04/14/push-to-deploy-through-git-hook/</link><guid isPermaLink="false">https://hiitea.io/2016/04/14/push-to-deploy-through-git-hook/</guid><pubDate>Thu, 14 Apr 2016 10:59:37 GMT</pubDate><content:encoded>&lt;p&gt;看了好多讲通过 git 钩子自动部署的，大多讲的绕来绕去乱七八糟思路一点也不清晰…
做了一晚上实验之后大概明白了是怎么工作的。&lt;/p&gt;&lt;h3&gt;裸仓库（bare）&lt;/h3&gt;&lt;p&gt;裸仓库跟我们平时&lt;code&gt;git clone&lt;/code&gt;得到的仓库不太一样，裸仓库其实相当于通过克隆来的仓库里的&lt;code&gt;.git&lt;/code&gt;文件夹，整个裸仓库中只有 git 索引（index），&lt;strong&gt;并没有任何代码相关的东西&lt;/strong&gt;。要实现 Push to Deploy，首先我们需要一个裸仓库。&lt;/p&gt;&lt;p&gt;在克隆时使用 &lt;code&gt;--bare&lt;/code&gt;参数来克隆一个裸仓库&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git init --bare xxx-bare
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;钩子（hook）&lt;/h3&gt;&lt;p&gt;普通仓库&lt;code&gt;.git&lt;/code&gt;文件夹下有一个&lt;code&gt;hooks&lt;/code&gt;文件夹，裸仓库下直接有一个&lt;code&gt;hooks&lt;/code&gt;文件夹，里面有各种各样以&lt;code&gt;.sample&lt;/code&gt;结尾的钩子，当把&lt;code&gt;.sample&lt;/code&gt;后缀删除时，钩子就是激活状态。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;.git
├───hooks
│   └───post-update.sample
└─── ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以在钩子文件里写一些 bash 命令，被激活的钩子被触发时会执行你的 bash 命令。&lt;/p&gt;&lt;p&gt;与 deploy 相关的通常使用&lt;code&gt;post-update&lt;/code&gt;钩子或者&lt;code&gt;post-receive&lt;/code&gt;钩子&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，关于这两个钩子到底有什么不同，我是没太看懂，大概的理解是这两个钩子被 trigger 的时候收到的信息不一样，如果需要用 commit 的相关信息来做一些事情的话要仔细研究（比如可以设置某个分支收到了推送就做相应的事情之类），其他如果只是通过 bash 来跑一些 node 相关的部署命令，两个都可以。这篇文章只给一个最简单的例子，跟分支啊什么的都没关系，只要收到推送就部署。&lt;/p&gt;&lt;p&gt;要实现 Push to Deploy，我们需要修改裸仓库中相应的钩子文件&lt;/p&gt;&lt;h3&gt;裸仓库是怎么工作的&lt;/h3&gt;&lt;p&gt;可以在本地同一个文件夹下先创建一个裸仓库名为 xxx-remote（模拟远程服务器），再创建一个 xxx-local 仓库（模拟本地），将 xxx-remote 添加为本地仓库的远程仓库，在本地仓库写一个&lt;code&gt;README.md&lt;/code&gt;文件，提交并 push&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git init --bare xxx-remote
git init xxx-local
cd xxx-local
git remote add origin ../xxx-remote
echo test123&amp;gt;README.md
git add .
git commit -m &amp;#x27;add readme file&amp;#x27;
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后切换到远程仓库文件夹，查看 git log&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd ..
cd xxx-remote
git log
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将能够看到有一条 commit 记录，提交信息是 add readme file，远程仓库收到了本地仓库的 push&lt;/p&gt;&lt;h3&gt;钩子是怎么工作的&lt;/h3&gt;&lt;p&gt;进入远程仓库，将&lt;code&gt;hooks&lt;/code&gt;文件夹下的&lt;code&gt;post-update.sample&lt;/code&gt;改名为&lt;code&gt;post-update&lt;/code&gt;，打开并编辑为如下内容：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;#!/bin/sh
set -x #显示每条命令
echo &amp;quot;push push&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改本地仓库的文件，进行一次推送，将会看到远程服务器执行了相应的命令&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Total 0 (delta 0), reused 0 (delta 0)
remote: + echo push push
remote: push push
To ../xxx
 + 41b78ee...055cec9 master -&amp;gt; master (forced update)
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;一个完整的场景举例&lt;/h3&gt;&lt;p&gt;假设有一台远程服务器上跑着一个网站，希望每次 git push 之后这个网站就自动更新。
为了方便：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;假设远程服务器上放了&lt;strong&gt;裸仓库&lt;/strong&gt;和&lt;strong&gt;网站&lt;/strong&gt;，自动部署的过程就是裸仓库收到 push 之后更新一下网站的文件夹&lt;/li&gt;&lt;li&gt;假设网站都是静态文件，不需要重启 web server&lt;/li&gt;&lt;li&gt;假设都只考虑默认的 master 分支&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们需要：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在这台远程服务器上创建一个裸仓库，假如名叫 xxx。克隆 repo 取名为 website，用于存放网站文件&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git init --bare xxx
git clone ./xxx website
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;修改远程服务器下&lt;code&gt;hooks&lt;/code&gt;文件夹下的&lt;code&gt;post-update.sample&lt;/code&gt;改名为&lt;code&gt;post-update&lt;/code&gt;，编辑为如下内容：&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;#!/bin/sh
set -x #显示每条命令
git reset --hard origin/master #防止因为forced push而导致无法checkout
git checkout
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;在本地 repo 添加远程仓库&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git remote add origin ubuntu@59.64.123.123:home/xxx.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.在本地仓库修改文件并 push&lt;/p&gt;&lt;p&gt;至此整个 git 自动部署的过程就完成了&lt;/p&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/githooks.html&quot;&gt;https://www.kernel.org/pub/software/scm/git/docs/githooks.html&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[结合使用Babel Mocha Istanbul进行ES6代码测试和覆盖率测试]]></title><description><![CDATA[题外话：
一直以为 mocha 读作“抹茶”并且一直这么读了很久，直到最近看了一个 mocha 的教学视频，才知道这是摩卡咖啡的摩卡…而抹茶的抹茶应该是 matcha… 在还没有 babel 的时候，一切都很简单，基础的问题就先不讨论了，这里主要记录一下 Babel…]]></description><link>https://hiitea.io/2016/04/12/babel-mocha-istanbul-es6-testing-and-coverage/</link><guid isPermaLink="false">https://hiitea.io/2016/04/12/babel-mocha-istanbul-es6-testing-and-coverage/</guid><pubDate>Tue, 12 Apr 2016 04:32:01 GMT</pubDate><content:encoded>&lt;p&gt;题外话：
一直以为 mocha 读作“抹茶”并且一直这么读了很久，直到最近看了一个 mocha 的教学视频，才知道这是摩卡咖啡的摩卡…而抹茶的抹茶应该是 matcha…&lt;/p&gt;&lt;p&gt;在还没有 babel 的时候，一切都很简单，基础的问题就先不讨论了，这里主要记录一下 Babel 转码和 Istanbul 测覆盖率的一些坑。&lt;/p&gt;&lt;h3&gt;基本设置&lt;/h3&gt;&lt;p&gt;通常我们会有好几个文件夹，例如&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;src&lt;/code&gt;用来存放源文件，也就是包含 es6,7 的代码；&lt;/li&gt;&lt;li&gt;&lt;code&gt;lib&lt;/code&gt;用来存放编译后的代码&lt;/li&gt;&lt;li&gt;&lt;code&gt;test&lt;/code&gt;用来放测试脚本&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在&lt;code&gt;test&lt;/code&gt;文件夹下，通常有一个&lt;code&gt;mocha.opts&lt;/code&gt;文件用来存放 mocha 的参数&lt;/p&gt;&lt;pre&gt;&lt;code&gt;--compilers js:babel-register
--require babel-polyfill
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果用到了需要用 babel-polyfill 才能实现的方法就需要加上第二句，别忘了&lt;code&gt;npm install babel-polyfill --save-dev&lt;/code&gt;&lt;/p&gt;&lt;p&gt;生成覆盖率的测试命令：（&lt;code&gt;_mocha&lt;/code&gt; 是有下划线的）&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;istanbul cover _mocha --  --opts ./test/mocha.opts
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;编译&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;babel src/ -d lib/ --presets es2015 --source-map both
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用&lt;code&gt;--source-map both&lt;/code&gt;参数将会生成 source map，有了 source map，istanbul 就能够追踪到&lt;code&gt;src&lt;/code&gt;下的源代码的覆盖率&lt;/p&gt;&lt;h3&gt;正确的 require&lt;/h3&gt;&lt;p&gt;在 mocha 中，一定要 require &lt;code&gt;src&lt;/code&gt;文件夹下的文件，而不是&lt;code&gt;lib&lt;/code&gt;文件夹下的文件。虽然两个文件夹下的文件 mocha 都能测，但是覆盖率会有一些问题。&lt;/p&gt;&lt;h3&gt;可能的问题&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;出现以下错误提示时，很可能因为 istanbul 的版本过低，使用&lt;code&gt;1.0.0-alpha.2&lt;/code&gt;版本可以正常运行&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;No coverage information was collected, exit without writing coverage information
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;istanbul 生成的覆盖率文件里代码几乎都是&lt;strong&gt;红色&lt;/strong&gt;的，这是因为编译时没有 &lt;code&gt;--source-map both&lt;/code&gt; 参数，追踪的是&lt;code&gt;lib&lt;/code&gt;文件夹下的覆盖率&lt;/li&gt;&lt;li&gt;istanbul 生成的覆盖率文件总是显示 100%，就算有些地方没测，也显示 100%，这是因为在 Mocha 里 require 的是&lt;code&gt;lib&lt;/code&gt;而非&lt;code&gt;src&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;其他&lt;/h3&gt;&lt;p&gt;我最喜欢 mocha 的报告形式是&lt;code&gt;-R nyan&lt;/code&gt;，一只可爱的喵星人，没有错的时候是这样的^_^，有错的时候是这样的 O_O，反正就是萌萌萌。&lt;/p&gt;&lt;p&gt;然而最实用的报告形式可能是&lt;code&gt;-R mochawesome&lt;/code&gt;，需要&lt;code&gt;npm i mochawesome&lt;/code&gt;安装插件，生成直观的 html 测试报告&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;平时遇到的问题十有八九一搜都能找到阮一峰老师的教程…这覆盖率也太高了？！&lt;/p&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/06/istanbul.html&quot;&gt;http://www.ruanyifeng.com/blog/2015/06/istanbul.html&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html&quot;&gt;http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[箭头函数的作用域和this]]></title><description><![CDATA[JS 里的作用域和 this 一直是一件令人头疼的事情，以前接触的不太多，毕竟面向过程编程的我基本上都不会使用“类”这个概念。 自从开始学习 ES6，很长一段时间都认为箭头函数(Arrow Function…]]></description><link>https://hiitea.io/2016/04/01/scope-and-this-of-arrow-function/</link><guid isPermaLink="false">https://hiitea.io/2016/04/01/scope-and-this-of-arrow-function/</guid><pubDate>Fri, 01 Apr 2016 08:38:12 GMT</pubDate><content:encoded>&lt;p&gt;JS 里的作用域和 this 一直是一件令人头疼的事情，以前接触的不太多，毕竟面向过程编程的我基本上都不会使用“类”这个概念。&lt;/p&gt;&lt;p&gt;自从开始学习 ES6，很长一段时间都认为箭头函数(Arrow Function)&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;就是给懒人用的&lt;strong&gt;简写的匿名函数&lt;/strong&gt;而已。后来看到有人挑战阮一峰老师&lt;a href=&quot;http://es6.ruanyifeng.com/&quot;&gt;《ECMAScript 6 入门》&lt;/a&gt;中关于箭头函数 this 的一些问题&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;，才对箭头函数有了一丁点的理解。&lt;/p&gt;&lt;p&gt;我平时的工作基本上都是各种第三方的 API 整合，于是各种异步请求，promise 都是家常便饭。由于 SalesForce 没有直接的 nodejs sdk，所以自己写一个自定义的类就不可避免了。在写的过程中，关于 this 踩到坑里了，所以就有了这篇文章。&lt;/p&gt;&lt;h3&gt;场景&lt;/h3&gt;&lt;p&gt;其中一个简单的功能是，查找用户是否存在，若存在则发送欢迎邮件（整个流程对应&lt;code&gt;onBoardFlow&lt;/code&gt;）。实际场景比这个要复杂，可能需要连续发送好几个请求，为了避免&lt;em&gt;回调地狱&lt;/em&gt;，所有的请求我都用 promise 包了起来。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#x27;use strict&amp;#x27;;
class SalesForce {
  constructor(email, username) {
    this.email = email;
    this.username = username;
  }
  checkUser(){
    return getUserByName(this.username); //发送一个请求到salesforce，返回一个promise
  }
  sendEmail(){
    return send(this.email); //发送一个请求通知salesforce发送邮件，返回一个promise
  }
  onBoardFlow(){
    //....
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;方案&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;在&lt;code&gt;onBoardFlow&lt;/code&gt;中，搞不清 this 和作用域的我首先这么写：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;//例1
this.checkuser().then(this.sendEmail);  //Cannot read property &amp;#x27;email&amp;#x27; of undefined
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后想到了在 promise 链中，this 指向的是 global；&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Q: &lt;strong&gt;为什么能找到&lt;code&gt;this.sendEmail()&lt;/code&gt;方法，却找不到&lt;code&gt;this.email&lt;/code&gt;属性呢？&lt;/strong&gt;
A: 我的理解是：因为&lt;code&gt;this.sendEmail&lt;/code&gt;是作为参数传入，传入的 this 是 then 外部的 this，也就是&lt;code&gt;SalesForce&lt;/code&gt;对象；
而 this.sendEmail 函数的作用域中产生了&lt;strong&gt;新的 this&lt;/strong&gt;，而这个 this 指向 global（浏览器中为 window 对象）；在严格模式下 this 为 undefined；&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;然后容易想到的就是各种_this self，然后 bind(this) call(_this)之类的&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;//例2
this.checkuser().then(this.sendEmail.bind(this));  //it works !
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样是可以正常工作的，但感觉怪怪的，每个 then 都要&lt;code&gt;bind(this)&lt;/code&gt;真是一点也不优雅。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;匿名函数和箭头函数原来不一样啊&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;//例3
this.checkuser().then(function(){
  return this.sendEmail();
});  //Cannot read property &amp;#x27;updateFunnelData&amp;#x27; of undefined
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时&lt;code&gt;this.sendEmail&lt;/code&gt;的 this 是 then 中的匿名函数新产生的 promise 作用域下的 this，非严格模式下指向 global&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在箭头函数出现之前，每个新定义的函数都将新产生自己作用域下的 this, arguments 等对象&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;例4
this.checkuser().then(()=&amp;gt;this.sendEmail());  //it works!
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;词法作用域&lt;/h3&gt;&lt;p&gt;作用域内可以嵌套作用域，从而形成作用域链，在最外层的也就是全局作用域，当在内部查找一个对象时，会顺着作用域链最内层，层层向外寻找，直到找到为止。&lt;/p&gt;&lt;p&gt;在例 3 中，匿名函数的作用域中产生了新的&lt;code&gt;this&lt;/code&gt;，该&lt;code&gt;this&lt;/code&gt;指向 global
在例 4 中，箭头函数的作用域中没有产生新的 this，所以顺着作用域链层层往外寻找&lt;code&gt;this&lt;/code&gt;，找到&lt;code&gt;onBoardFlow()&lt;/code&gt;的作用域时，找到了&lt;code&gt;this&lt;/code&gt;，而此时&lt;code&gt;this&lt;/code&gt;就是&lt;code&gt;SalesForce&lt;/code&gt;对象&lt;/p&gt;&lt;h3&gt;为什么 promise 中的 this 指向 global&lt;/h3&gt;&lt;p&gt;这个，我还没学会…&lt;/p&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;https://github.com/ruanyf/es6tutorial/issues/150&quot;&gt;https://github.com/ruanyf/es6tutorial/issues/150&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[AWS EC2 SSH访问 & mongodb 安装]]></title><description><![CDATA[环境：Ubuntu SSH 连接 EC2 windows 下通常用 putty
ubuntu 下先打个命令 ssh 看看能否识别命令，如果能就方便很多 要连接 EC2 通常都会有一个 .pem 的 私钥 文件，另外还会有一个 Public IP…]]></description><link>https://hiitea.io/2016/03/14/aws-ec2-ssh-access-mongodb-installation/</link><guid isPermaLink="false">https://hiitea.io/2016/03/14/aws-ec2-ssh-access-mongodb-installation/</guid><pubDate>Mon, 14 Mar 2016 10:33:31 GMT</pubDate><content:encoded>&lt;p&gt;环境：Ubuntu&lt;/p&gt;&lt;h3&gt;SSH 连接 EC2&lt;/h3&gt;&lt;p&gt;windows 下通常用 putty
ubuntu 下先打个命令&lt;code&gt;ssh&lt;/code&gt;看看能否识别命令，如果能就方便很多&lt;/p&gt;&lt;p&gt;要连接 EC2 通常都会有一个&lt;code&gt;.pem&lt;/code&gt;的&lt;strong&gt;私钥&lt;/strong&gt;文件，另外还会有一个&lt;strong&gt;Public IP&lt;/strong&gt;
首先设置权限（并不知道这个有什么用，chmod 400 使得文件只能被该文件的拥有者读取）&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;chmod 400 /*path*/my-key-pair.pem
ssh -i /*path*/my-key-pair.pem username@59.64.123.1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 username 默认如下：&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;right&quot;&gt;OS&lt;/th&gt;&lt;th align=&quot;right&quot;&gt;username&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&quot;right&quot;&gt;Linux&lt;/td&gt;&lt;td align=&quot;right&quot;&gt;ec2-user&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;right&quot;&gt;RHEL5&lt;/td&gt;&lt;td align=&quot;right&quot;&gt;root 或 ec2-user&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;right&quot;&gt;Ubuntu&lt;/td&gt;&lt;td align=&quot;right&quot;&gt;ubuntu&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;mongodb 安装及配置&lt;/h3&gt;&lt;p&gt;有了 apt-get 一切真是轻松如放屁…连解压缩都不用！也不用再设置环境变量什么的（根部记不住解压缩的命令…）&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install mongodb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装好了之后，去&lt;strong&gt;根目录&lt;/strong&gt;下创建&lt;code&gt;data&lt;/code&gt;文件夹即可，然后打&lt;code&gt;mongod&lt;/code&gt;命令，应该就启动了，此时访问&lt;code&gt;localhost:27017&lt;/code&gt;，如果看到以下文字，就成功启动了芒果 DB&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;You are trying to access MongoDB on the native driver port. For http diagnostic access, add 1000 to the port number&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;如果有 error 通常是没有 data 文件夹，设置&lt;code&gt;dbpath&lt;/code&gt;后再尝试启动&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mongod --dbpath=./path_of _data
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/AccessingInstancesLinux.html&quot;&gt;http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/AccessingInstancesLinux.html&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[AWS API Gateway Mapping Template 获取IP, header等]]></title><description><![CDATA[API Gateway 暂时没有详细的中文文档，翻译无能的我实在不知道 Mapping Template 应该翻译成什么比较好。 适用场景 在配合 API Gateway 和 Lambda 来搭建 RESTful API 时，Lambda 获取的 payload…]]></description><link>https://hiitea.io/2016/03/07/aws-api-gateway-mapping-templates/</link><guid isPermaLink="false">https://hiitea.io/2016/03/07/aws-api-gateway-mapping-templates/</guid><pubDate>Mon, 07 Mar 2016 06:33:03 GMT</pubDate><content:encoded>&lt;p&gt;API Gateway 暂时没有详细的中文文档，翻译无能的我实在不知道 Mapping Template 应该翻译成什么比较好。&lt;/p&gt;&lt;h3&gt;适用场景&lt;/h3&gt;&lt;p&gt;在配合 API Gateway 和 Lambda 来搭建 RESTful API 时，Lambda 获取的 payload 并非通常服务器端获取的一个 request 对象，lambda 获取到的 payload 并&lt;strong&gt;不包含 request header&lt;/strong&gt;的内容，而只有&lt;strong&gt;request body&lt;/strong&gt;的内容。&lt;/p&gt;&lt;p&gt;header 中的部分内容可以通过 API Gateway 提供的变量从 mapping template 中获取。可以获取的内容包括 IP, http 方法，路由参数，query 等，具体可以看文档&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;h3&gt;设置方法&lt;/h3&gt;&lt;p&gt;按照理论来说，AWS 设置可以通过界面设置的都可以通过脚本来设置。下面只介绍在界面中的设置：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在 API Gateway 界面中选中具体的 api 方法，点击右侧的&lt;strong&gt;Intergration Request&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;在底部点击&lt;strong&gt;Mapping Templates&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;点击&lt;strong&gt;Add Mapping Template&lt;/strong&gt;，输入&lt;code&gt;application/json&lt;/code&gt;，点击 √ 进行确认&lt;/li&gt;&lt;li&gt;在右侧新出现的区域，点击编辑按钮（铅笔图标），输入需要的变量即可，例如要获取 ip：&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;{
  &amp;quot;body&amp;quot;: $input.json(&amp;#x27;$&amp;#x27;),
  &amp;quot;source_ip&amp;quot; : &amp;quot;$context.identity.sourceIp&amp;quot;,
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中&lt;code&gt;$input.json(&amp;#x27;$&amp;#x27;)&lt;/code&gt;是请求时客户端发来的 body&lt;/p&gt;&lt;h3&gt;response header 和 cookie&lt;/h3&gt;&lt;p&gt;在配合使用 lambda 和 API gateway 的时候，header 和 cookie 是非常令人头疼的问题…
lambda 返回的内容，只是 response body，因此设置 header 要在 api gateway 中进行，并且也是有一些限制的：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在 API Gateway 界面中选中具体的 api 方法，点击右侧的&lt;strong&gt;Method Response&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;展开 HTTP Status，点击&lt;strong&gt;Add Header&lt;/strong&gt;，添加一个 header。&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：可以添加多个 Header，但这些 header 不能同名，这也就意味着，只能有一个&lt;code&gt;Set-Cookie&lt;/code&gt;，只能添加一个 cookie&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;完成以上步骤后，返回第一步所在的页面，点击&lt;strong&gt;Integration Response&lt;/strong&gt;，点击三角展开，会看到&lt;strong&gt;Header Mappings&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;在对应的位置编辑&lt;strong&gt;mapping value&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;如果想使用 lambda 返回的数据，设置为&lt;code&gt;integration.response.body.KEY&lt;/code&gt;&lt;/li&gt;&lt;li&gt;如果不是使用 lambda（即把 gateway 用作代理），而是使用实际服务器返回的 header，设置为&lt;code&gt;integration.response.header.KEY&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/apigateway/latest/developerguide/how-to-method-settings-execution-console.html&quot;&gt;http://docs.aws.amazon.com/zh_cn/apigateway/latest/developerguide/how-to-method-settings-execution-console.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/apigateway/latest/developerguide/request-response-data-mappings.html&quot;&gt;http://docs.aws.amazon.com/zh_cn/apigateway/latest/developerguide/request-response-data-mappings.html&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html&quot;&gt;http://docs.aws.amazon.com/zh_cn/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Cookie在前端和后端的设置]]></title><description><![CDATA[http 协议什么的，不知道跟通信有没有关系…作为一个通信科班出身的硬 汉 妹，对各种协议基本上只能说出名字，别的一窍不通=，= 所以当我知道 cookie 原来是在 header 里的时候，当时我就震惊了… 在服务器端，各种框架都已经包装好了方便设置 cookie…]]></description><link>https://hiitea.io/2016/02/29/set-cookie-from-server-side-and-client-side/</link><guid isPermaLink="false">https://hiitea.io/2016/02/29/set-cookie-from-server-side-and-client-side/</guid><pubDate>Mon, 29 Feb 2016 06:04:57 GMT</pubDate><content:encoded>&lt;p&gt;http 协议什么的，不知道跟通信有没有关系…作为一个通信科班出身的硬&lt;del&gt;汉&lt;/del&gt;妹，对各种协议基本上只能说出名字，别的一窍不通=，= 所以当我知道 cookie 原来是在 header 里的时候，当时我就震惊了…&lt;/p&gt;&lt;p&gt;在服务器端，各种框架都已经包装好了方便设置 cookie 的方法，比如 nodejs 的 express，php 的 codeignitor、laravel（我居然都被迫写过 php 了，真是逼良为娼…）&lt;/p&gt;&lt;p&gt;为什么要了解设置 cookie 的原理呢？了解了才能在某些时候用最原始的方法来设置 cookie，比如没有框架可用的时候，以及框架提供的方法不适用于某些场景的时候。
我是在使用 laravel 设置 cookie 的时候踩了坑，现在的项目里因为要配合使用 GTM（google tag manager），所以 cookie 是不加密的 raw data，但通过 laravel 设置的 cookie 都是加密了的。于是只能学习 PHP 原生的添加 cookie 方法。&lt;code&gt;setcookie(NAME, VALUE, EXPIRES)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;另外就是因为用 AWS API Gateway 时候的一些需求，想要通过 gateway 直接设置 cookie，这个时候就不得不了解 http cookie 的运作方式。&lt;/p&gt;&lt;h3&gt;response cookie 从服务器端返回新 cookie&lt;/h3&gt;&lt;p&gt;设置 cookie 是通过在响应的头部加入&lt;code&gt;Set-Cookie&lt;/code&gt;来设置的，&lt;/p&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;一个请求通常包含 header 和 body&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;与请求有关的 cookie 分为 request cookie 和 response cookie&lt;ul&gt;&lt;li&gt;request cookie 是浏览器已储存的 cookie&lt;/li&gt;&lt;li&gt;response cookie 是服务器端返回的新的 cookie，也就是将会储存在浏览器端的新 cookie&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;一个完整的 cookie header&lt;/h4&gt;&lt;p&gt;一个完整的 cookie 头长这样&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Set-Cookie: NAME=VALUE; expires=DATE; path=PATH; domain=DOMAIN
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;NAME VALUE 是一对键值
expires 是过期日期，通常用当前时间的毫秒数加上一段时间：&lt;code&gt;new Date().getTime()+30*24*60*60*1000)&lt;/code&gt;，然后&lt;strong&gt;需要调用&lt;code&gt;toUTCString()&lt;/code&gt;方法&lt;/strong&gt;
如果不设置 expires，在浏览器中这个 cookie 将被当做 session 对待，也就是关闭了浏览器 cookie 就消失
path 和 domain 这个…感觉不太用得到，具体可以看&lt;a href=&quot;http://blog.sina.com.cn/s/blog_70c4d9410100z3il.html&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;&lt;p&gt;如果要同时设置多个 cookie，同时返回多个&lt;code&gt;Set-Cookie&lt;/code&gt;头即可&lt;/p&gt;&lt;h4&gt;maxAge&lt;/h4&gt;&lt;p&gt;有一些服务器端的框架会提供 maxAge 属性来设置 cookie 的过期时间，但是原始的 Set-Cookie 头是不支持 maxAge 的，所以在通过头部来设置 cookie 还是乖乖用回 expires 吧&lt;/p&gt;&lt;h3&gt;浏览器端读取 cookie&lt;/h3&gt;&lt;p&gt;JS 原生方法：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var cookies = document.cookie;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;读取的 cookie 是一个分号分隔的包含所有 cookie 键值字符串，可以通过正则表达式来提取需要的 cookie&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var cookieA = document.cookie.replace(
  /(?:(?:^|.*;\s*)cookieA\s*\=\s*([^;]*).*$)|^.*$/,
  &amp;#x27;$1&amp;#x27;
);
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;request cookie 浏览器端设置 cookie&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;document.cookie = &amp;#x27;cookie_example=123&amp;#x27; + &amp;#x27;;expires=&amp;#x27; + expire + &amp;#x27;;path=/&amp;#x27;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果要设置多个 cookie，多次调用&lt;code&gt;document.cookie&lt;/code&gt;即可&lt;/p&gt;&lt;h4&gt;document.cookie&lt;/h4&gt;&lt;p&gt;这个 document 的 behavior 有点奇怪，明明返回的是个字符串，本来以为每次设置 cookie 得用新的字符串连接旧的字符串，但其实直接等于新的值也并不会覆盖旧的值，不知道实现这个属性&amp;amp;方法混用的原理是什么 0,0&lt;/p&gt;&lt;p&gt;####NOTE
通常设置 cookie 的时候都会把 path 设置为&lt;code&gt;/&lt;/code&gt;，这样同一个域名下，所有路径都共用一个 cookie
如果没有设置 path，某些框架可能默认会使用创建 cookie 时的路径作为 path，这样就可能存在多个 path 不同的同名 cookie。&lt;/p&gt;&lt;p&gt;####工具&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在浏览器端，可以使用 chrome 的扩展&lt;em&gt;EditThisCookie&lt;/em&gt;来查看和编辑 cookie&lt;/li&gt;&lt;li&gt;如果是从服务器端写入的 cookie，可以在 F12 network 选项卡中选中请求，有 cookie 的时候会有一个 cookie 选项，能看到 request cookie 和 response cookie&lt;/li&gt;&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[jQuery中利用JSONP进行跨域GET请求]]></title><description><![CDATA[每次遇到跨域的问题真是！@#￥% 我对 JSONP 的一些浅显的理解就是，有时候会看到类似 http://xxx.xx.com/?callback=xxx 这样的请求（ callback= 也可能是 jsonp= 也可能是 jsonpcallback…]]></description><link>https://hiitea.io/2016/02/17/using-jQuery-to-handle-CORS-with-jsonp/</link><guid isPermaLink="false">https://hiitea.io/2016/02/17/using-jQuery-to-handle-CORS-with-jsonp/</guid><pubDate>Wed, 17 Feb 2016 04:31:55 GMT</pubDate><content:encoded>&lt;p&gt;每次遇到跨域的问题真是！@#￥%&lt;/p&gt;&lt;p&gt;我对&lt;code&gt;JSONP&lt;/code&gt;的一些浅显的理解就是，有时候会看到类似&lt;code&gt;http://xxx.xx.com/?callback=xxx&lt;/code&gt;这样的请求（&lt;code&gt;callback=&lt;/code&gt;也可能是&lt;code&gt;jsonp=&lt;/code&gt;也可能是&lt;code&gt;jsonpcallback=&lt;/code&gt;，这个取决于服务器端是怎么实现 jsonp 的），这样的请求做的事情简单的来说就是等得到所有数据之后就执行回调函数。&lt;/p&gt;&lt;p&gt;由于这个回调函数已经发给了服务器，返回的结果其实是一个函数，函数的入参是获取的数据。&lt;/p&gt;&lt;p&gt;jQuery 的 ajax 请求其实能很简单的在客户端进行跨域 GET 请求，具体如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var options = {
  url: &amp;#x27;http://xx.xx.com/xxx&amp;#x27;,
  method: &amp;#x27;GET&amp;#x27;,
  dataType: &amp;#x27;jsonp&amp;#x27;,
  //jsonp: &amp;#x27;callback&amp;#x27;,
  success: function (data) {
    //do something here;
  },
};

$.ajax(options);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中需要注意的是，一定要声明&lt;strong&gt;&lt;code&gt;dataType&lt;/code&gt;&lt;/strong&gt;，然后把回调函数写在 success 后面就可以了。
另外一开始提到，服务器端对 jsonp 的实现可能不同，所以在&lt;code&gt;options&lt;/code&gt;中，有时候需要声明&lt;code&gt;jsonp&lt;/code&gt;对应的字符串，默认是&lt;code&gt;&amp;quot;callback&amp;quot;&lt;/code&gt;。例如：如果服务器实现 jsonp 是通过&lt;code&gt;http://xxx.xx.com/?jsonpcallback=xxx&lt;/code&gt;，那么就需要在&lt;code&gt;options&lt;/code&gt;中声明&lt;code&gt;jsonp:&amp;#x27;jsonpcallback&amp;#x27;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;原理据说和&lt;code&gt;&amp;lt;script src=&amp;quot;...&amp;quot;&amp;gt;&lt;/code&gt;差不多，我现在还不是很明白=，=&lt;/p&gt;&lt;p&gt;参考
&lt;a href=&quot;http://www.runoob.com/json/json-jsonp.html&quot;&gt;http://www.runoob.com/json/json-jsonp.html&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[谷歌地图 Google Map API 初体验]]></title><description><![CDATA[一直都想把自己去过的地方做个地图标记，然而现在能找到的各种现成的地图产品都不太喜欢，所以就用谷歌地图自己写了一个。
总结以下常见的问题和坑： 自动缩放(auto zoom) 使用场景大多数时候是有很多 marker，想要全部显示这些 marker，同时 zoom…]]></description><link>https://hiitea.io/2016/02/03/experiencing-google-map-js-api/</link><guid isPermaLink="false">https://hiitea.io/2016/02/03/experiencing-google-map-js-api/</guid><pubDate>Wed, 03 Feb 2016 10:32:51 GMT</pubDate><content:encoded>&lt;p&gt;一直都想把自己去过的地方做个地图标记，然而现在能找到的各种现成的地图产品都不太喜欢，所以就用谷歌地图自己写了一个。
总结以下常见的问题和坑：&lt;/p&gt;&lt;h3&gt;自动缩放(auto zoom)&lt;/h3&gt;&lt;p&gt;使用场景大多数时候是有很多 marker，想要全部显示这些 marker，同时 zoom 当然越大越清晰。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先需要一个 marker 的位置列表 &lt;code&gt;markerList&lt;/code&gt;，单个元素长这样&lt;code&gt;{lat:xxx,lng:xxx}&lt;/code&gt;&lt;/li&gt;&lt;li&gt;遍历列表，把元素传入&lt;code&gt;google.maps.LatLngBounds&lt;/code&gt;实例的&lt;code&gt;extend&lt;/code&gt;方法&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var latlngbounds = new google.maps.LatLngBounds();
markerList.forEach(function (item) {
  latlngbounds.extend(item);
});
map.fitBounds(latlngbounds);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然而这有一个很多人提到的问题，就是缩放效果不平滑。(smooth 这个词，我还是百度了 smooth scroll 才写的出字面意思来，我现在中文是有多差…)
这个暂时没什么解决方法，API 本身就是这样的。据说谷歌本身的地图是 h5 的 canvas 绘制的，但通过 API 生成的地图不是同样的原理…谷歌居然自己都不用自己的 API …&lt;/p&gt;&lt;p&gt;另一个问题是，缩放&lt;strong&gt;太大力&lt;/strong&gt;怎么办？答案是，在&lt;code&gt;MapOptions&lt;/code&gt;中设置&lt;code&gt;maxZoom&lt;/code&gt;值&lt;/p&gt;&lt;h3&gt;动画效果切换&lt;/h3&gt;&lt;p&gt;API 提供三种效果：&lt;code&gt;BOUNCE&lt;/code&gt; &lt;code&gt;DROP&lt;/code&gt; &lt;code&gt;NULL&lt;/code&gt;
使用场景大多数时候是在 NULL 和 BOUNCE 之间切换&lt;/p&gt;&lt;p&gt;动画比较坑爹的是，每个动画都要持续 700ms，之后才能改变状态。&lt;/p&gt;&lt;p&gt;比如这样一个例子：有两组 marker，&lt;strong&gt;有交集&lt;/strong&gt;。想要让第一组先 BOUNCE，之后停止第一组，让第二组 BOUNCE。很容易想到的方法是，通过遍历，把第一组的动画全部设置为 NULL，再把第二组动画全部设置为 BOUNCE。然而交集的这一部分只会 BOUNCE 一次然后就停了…因为计算速度很快，从 NULL 到 BOUNCE 不到 700ms，动画其实还处于 NULL 状态。&lt;/p&gt;&lt;p&gt;可以参考官方的这个例子，&lt;a href=&quot;https://developers.google.com/maps/documentation/javascript/examples/marker-animations&quot;&gt;https://developers.google.com/maps/documentation/javascript/examples/marker-animations&lt;/a&gt; ，当你双击 marker 的时候，其实就是模拟了快速切换状态，但动画效果并不如预期…&lt;/p&gt;&lt;p&gt;解决方案：求差集，也就是把交集的部分去掉，在设置动画为 NULL&lt;/p&gt;&lt;h3&gt;自定义地图样式&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://snazzymaps.com/&quot;&gt;https://snazzymaps.com/&lt;/a&gt; 这个网站有很多已经设计好的样式，选喜欢的直接复制代码放到&lt;code&gt;StyledMapType()&lt;/code&gt;方法中即可，然后给这个样式取个名字，下例中我使用了&lt;a href=&quot;https://snazzymaps.com/style/134/light-dream&quot;&gt;light dream&lt;/a&gt; 这个样式&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var mapStyle = new google.maps.StyledMapType([....])
map.mapTypes.set(&amp;#x27;lightDream&amp;#x27;, mapStyle);
map.setMapTypeId(&amp;#x27;lightDream&amp;#x27;);
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;遍历添加 event listener 同时又需要传参数给 &lt;code&gt;google.maps.event.addListener()&lt;/code&gt; 的回调函数&lt;/h3&gt;&lt;p&gt;不太理解 event.addListener 的工作原理，但根据我踩的坑推测这是一个异步的方法（否则为什么有回调函数？！）&lt;/p&gt;&lt;p&gt;这个时候就要用到高大上的&lt;strong&gt;闭包&lt;/strong&gt;。下面这个例子中，如果不把&lt;code&gt;addListener&lt;/code&gt;包起来，每次 cityHandler 收到的 city 都是遍历的最后一个 city。因为遍历速度太快，而回调还没有执行，等回调执行的时候 city 已经遍历到最后一个了…&lt;/p&gt;&lt;p&gt;不用闭包的话，用 promise 应该也能解决这个问题，但是感觉 promise 需要写的 code 会比较多一些。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var cityList=[{marker:googleMapMarker,city:&amp;#x27;Beijing&amp;#x27;},...];
cityList.forEach(function(item){
  (function (marker, city) {
    google.maps.event.addListener(marker, &amp;#x27;click&amp;#x27;, function (e) {
      cityHandler(city);
    });
  })(item.marker, item.city)
})
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;原生 marker 图标&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://mabp.kiev.ua/2010/01/12/google-map-markers/&quot;&gt;http://mabp.kiev.ua/2010/01/12/google-map-markers/&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;
&lt;a href=&quot;https://developers.google.com/maps/documentation/javascript/reference&quot;&gt;https://developers.google.com/maps/documentation/javascript/reference&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[git如何ignore已经track的文件]]></title><description><![CDATA[我也不想中英文混杂的取标题……但我实在翻译无能… _ (:з」∠) _ 基本知识 在 git 中文件有两类，共三种状态： untracked tracked changes not staged for commit changes to be committed…]]></description><link>https://hiitea.io/2016/02/01/git-how-to-ignore-tracked-files/</link><guid isPermaLink="false">https://hiitea.io/2016/02/01/git-how-to-ignore-tracked-files/</guid><pubDate>Mon, 01 Feb 2016 06:01:03 GMT</pubDate><content:encoded>&lt;p&gt;我也不想中英文混杂的取标题……但我实在翻译无能…_(:з」∠)_&lt;/p&gt;&lt;h3&gt;基本知识&lt;/h3&gt;&lt;p&gt;在 git 中文件有两类，共三种状态：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;untracked&lt;/li&gt;&lt;li&gt;tracked&lt;ul&gt;&lt;li&gt;changes not staged for commit&lt;/li&gt;&lt;li&gt;changes to be committed
我们都知道，在&lt;code&gt;.gitignore&lt;/code&gt;文件里添加相应的文件夹或文件就能忽略掉不想被 track 的文件。
但是，&lt;code&gt;.gitignore&lt;/code&gt;文件只能忽略&lt;strong&gt;Untracked files&lt;/strong&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;适用场景&lt;/h3&gt;&lt;p&gt;参考这样一个例子：
一个项目因为一些莫名其妙的原因对&lt;code&gt;node_modules&lt;/code&gt;文件夹进行了 track，然后每次 check out 出来&lt;code&gt;npm install&lt;/code&gt;的时候，很可能这些依赖包就更新了，然后又因为一些莫名其妙的原因，始终没有人把这个文件夹移出 git 的 index，于是你也不好意思删除这个文件夹做一次 commit。然而，每次都有几十上百条&lt;code&gt;modified: node_modules/xxx&lt;/code&gt;，根本找不到自己真正修改和添加的文件…&lt;/p&gt;&lt;p&gt;于是问题来了，怎么样才能把&lt;code&gt;node_module&lt;/code&gt; ignore，但又不 commit 这些 change 呢？&lt;/p&gt;&lt;h3&gt;解决方法&lt;/h3&gt;&lt;p&gt;正常情况，跑以下的命令就能忽略掉已经 track 的&lt;strong&gt;文件夹&lt;/strong&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git ls-files -z node_modules/ | xargs -0 git update-index --assume-unchanged
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果只需要忽略&lt;strong&gt;单个文件&lt;/strong&gt;，则以下命令就能搞定。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git update-index --assume-unchanged &amp;lt;file name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为 update-index 不支持递归&lt;code&gt;-r&lt;/code&gt;，所以只能通过上面提到的方法来实现忽略文件夹
（憋问我为什么不支持…我也不知道）&lt;/p&gt;&lt;h3&gt;另一种情况：将 tracked 文件移出 index，但仍然保留在本地&lt;/h3&gt;&lt;p&gt;终于有一天，大家想通了，决定将&lt;code&gt;node_modules&lt;/code&gt;文件夹移出 git index，但是如果删除了整个文件夹 commit 之后，项目要跑起来，又要重新&lt;code&gt;npm install&lt;/code&gt;，懒癌患者倒地不起…&lt;/p&gt;&lt;p&gt;下面这个命令可以解决上述问题：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git rm --cached -r node_modules
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;吐槽&lt;/h3&gt;&lt;p&gt;我反正是无法理解把诸如 npm 包，bower 包，composer 包等等等的第三方依赖放到 git 里去 track，那么还要 package.json 干啥=，=&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Promise的顺序执行和并行执行]]></title><description><![CDATA[并行和顺序执行的前提当然是，有一堆 promise 等着你去执行……
通常我们把这“一堆”promise 对象放到一个数组里， [promise1, promise2, promise3, ...] 我们都知道想要让 promise 按顺序执行，那就是一个接一个的 then…]]></description><link>https://hiitea.io/2016/01/23/excecute-parallel-promise-and-sequential-promise/</link><guid isPermaLink="false">https://hiitea.io/2016/01/23/excecute-parallel-promise-and-sequential-promise/</guid><pubDate>Sat, 23 Jan 2016 14:52:26 GMT</pubDate><content:encoded>&lt;p&gt;并行和顺序执行的前提当然是，有一堆 promise 等着你去执行……
通常我们把这“一堆”promise 对象放到一个数组里，&lt;code&gt;[promise1, promise2, promise3, ...]&lt;/code&gt;&lt;/p&gt;&lt;p&gt;我们都知道想要让 promise 按顺序执行，那就是一个接一个的 then。然而手写很多 then 太累了，而嵌套的 promise 又是反模式，我之前蠢蠢的&lt;a href=&quot;tech/2016/01/18/sequentialize-promise-by-recursion/&quot;&gt;用递归解决了顺序执行的问题&lt;/a&gt;，后来终于在 udacity 习得了顺序 promise 的正确打开方式！&lt;/p&gt;&lt;h3&gt;场景&lt;/h3&gt;&lt;p&gt;假如我们要去拿 github 按关键字搜索 google, amazon, facebook，每个关键字搜出的第一个用户的第一个 repo 的名字。
单独拿一个，比如 google，过程是这样的：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;请求&lt;a href=&quot;https://api.github.com/search/users?q=google&quot;&gt;https://api.github.com/search/users?q=google&lt;/a&gt; ，得到用户列表，读取第一个用户的 repos_url&lt;/li&gt;&lt;li&gt;请求上一步读取的 repous_url，获得 repo 列表，读取第一个 repo 的名字
显然，第二步是依赖于第一步的执行结果的。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;因此，很容易想到下面几种情况：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;等第一步全部执行完，再执行第二步（并行执行）&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;|--------------------|
google第一步          |------------------|
amazon第一步        google第二步
facebook第一步      amazon第二步
                   facebook第二步
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;对第一步的顺序有要求，必须严格按照 google, amazon, facebook 的顺序执行（顺序执行）&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;|---------|
google1   |---------|
            google2 |---------|
                     amazon1  |---------|
                              amazon2   |---------|
                                        facebook1 |--------|
                                                  facebook2
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;google1 执行完就执行 google1，amazon1 执行完就执行 amazon2，但对 google, amazon, facebook 的顺序没有要求&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;|------------------|
google1            |-------------|
                   google2
|---------|
amazon1   |-----------|
          amazon2
|------------|
facebook1    |-------------|
             facebook2
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Promise 并行执行&lt;/h3&gt;&lt;p&gt;对于场景 1，主要就是用到&lt;code&gt;Promise.all&lt;/code&gt;，因为是数组，所以在处理的过程中通常会用到&lt;code&gt;.map&lt;/code&gt;或&lt;code&gt;.forEach&lt;/code&gt;
&lt;a href=&quot;https://jsfiddle.net/HiiTea/zfjvr4pz/1/embedded/js&quot;&gt;https://jsfiddle.net/HiiTea/zfjvr4pz/1/embedded/js&lt;/a&gt;
&lt;img src=&quot;http://7xow88.com1.z0.glb.clouddn.com/tech-promise1.png&quot; alt=&quot;promise例1网络请求时间线&quot;/&gt;
可以看到 3 个 user 请求是同时进行（并行），3 个 repos 请求也是同时进行（并行），由于使用了&lt;code&gt;Promise.all&lt;/code&gt;，所以 repos 请求等待 users 请求全部完成才开始。&lt;/p&gt;&lt;h3&gt;promise 顺序执行的正确打开方式&lt;/h3&gt;&lt;p&gt;对于场景 2，有一个小技巧，我第一次看到的时候感受是…惊为天人
按照顺序执行，容易想到的有以下几种方法：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;then.then.then，从头 then 到尾…&lt;/li&gt;&lt;li&gt;then(then(then()))，then 的嵌套…&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;promise 链的本质其实就是从头 then 到尾，但是第一种方法怎么用程序来实现，也就是上面提到的小技巧，就是值得学习的地方了。（反正我觉得太巧妙了！！！我自己就想不到…）&lt;/p&gt;&lt;p&gt;大概跟在做求和运算时候的思想一样：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;//求和的时候通常这么做，先定义一个sum，然后依次往里做加法
var sum = 0;
array.forEach(function (item) {
  sum = sum + item;
});
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;//要得到一个then then then的promise链，先定义一个已经resolve了的promise，然后依次往后then…
var sequence = Promise.resolve();
array.forEach(function(item) {
  sequence = sequence.then(...)
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面给出场景 2 的代码：
&lt;a href=&quot;https://jsfiddle.net/HiiTea/sq2aga08/embedded/js&quot;&gt;https://jsfiddle.net/HiiTea/sq2aga08/embedded/js&lt;/a&gt;
&lt;img src=&quot;http://7xow88.com1.z0.glb.clouddn.com/tech-promise2.png&quot; alt=&quot;promise例2网络请求时间线&quot;/&gt;
可以看到请求是按顺序依次发出&lt;/p&gt;&lt;h3&gt;并行执行和顺序执行混用&lt;/h3&gt;&lt;p&gt;场景 3:
&lt;a href=&quot;https://jsfiddle.net/HiiTea/z09xjowq/1/embedded/js&quot;&gt;https://jsfiddle.net/HiiTea/z09xjowq/1/embedded/js&lt;/a&gt;
&lt;img src=&quot;http://7xow88.com1.z0.glb.clouddn.com/tech-promise3.png&quot; alt=&quot;promise例3网络请求时间线&quot;/&gt;
可以看到 users 请求是并行发出，但完成时间不一样，而 repos 请求是在&lt;strong&gt;对应的&lt;/strong&gt;users 请求完成后就立即执行&lt;/p&gt;&lt;h3&gt;混用的另一种情况&lt;/h3&gt;&lt;p&gt;有了以上的知识，很容易写出最后一种混用的情况，users 按顺序执行，等 users 全部执行完之后并发执行 repos。我比较懒…这个我就不写了…&lt;/p&gt;&lt;h3&gt;补充知识：&lt;/h3&gt;&lt;h4&gt;浏览器的 fetch API&lt;/h4&gt;&lt;p&gt;本文跟 fetch 不是充分必要关系，只是我太懒了不想写太多的代码来举例。你可以把它理解为是用 Promise 包住的&lt;code&gt;$.ajax&lt;/code&gt;，也就是 fetch 返回一个 promise 对象。关于 fetch 的详细用法请参考&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;MDN Fetch_ API&lt;/a&gt;&lt;/p&gt;&lt;h4&gt;如何查看请求的发送是并行还是顺序&lt;/h4&gt;&lt;p&gt;打开 chrome，按 F12，选中 Network 选项卡，在 No throttling 这个下拉列表选 GPRS，再运行代码，然后就能清楚的看到各个请求的时间线了。&lt;/p&gt;&lt;p&gt;如果看到的区别不是很明显，很可能是已经缓存了，清空浏览器的缓存在重复上面的步骤就能看到比较明显的区别了。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;[1] &lt;a href=&quot;https://www.udacity.com/course/viewer#!/c-ud898&quot;&gt;https://www.udacity.com/course/viewer#!/c-ud898&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[对浏览器跨域问题的一些理解]]></title><description><![CDATA[问题宝宝 1 移动应用开发 之前用 Ionic 写 mobile app，移动 app 自然是少不了调用 RESTful API 的数据。
开发的时候用浏览器进行调试，然后 console 里不停的出现下面的提示( Access-Control-Allow-Origin…]]></description><link>https://hiitea.io/2016/01/22/understanding-of-CORS/</link><guid isPermaLink="false">https://hiitea.io/2016/01/22/understanding-of-CORS/</guid><pubDate>Fri, 22 Jan 2016 07:08:33 GMT</pubDate><content:encoded>&lt;h3&gt;问题宝宝&lt;/h3&gt;&lt;h4&gt;1 移动应用开发&lt;/h4&gt;&lt;p&gt;之前用 Ionic 写 mobile app，移动 app 自然是少不了调用 RESTful API 的数据。
开发的时候用浏览器进行调试，然后 console 里不停的出现下面的提示(&lt;strong&gt;Access-Control-Allow-Origin&lt;/strong&gt;)：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;XMLHttpRequest cannot load http://samlino.local/cag/get_leads. No &amp;#x27;Access-Control-Allow-Origin&amp;#x27; header is present on the requested resource. Origin &amp;#x27;http://localhost:63342&amp;#x27; is therefore not allowed access.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而我当时的解决方法是，在 chrome 装了一个叫&lt;a href=&quot;https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi&quot;&gt;Allow-Control-Allow-Origin&lt;/a&gt;的扩展，启用之后就不报错了。&lt;/p&gt;&lt;p&gt;也不知道什么什么原理，反正就这么一直用着。（不思进取）&lt;/p&gt;&lt;h4&gt;2 网络应用开发&lt;/h4&gt;&lt;p&gt;后来写单页应用（SPA），静态文件的 js 里调用各大公司的 API， github、facebook 什么的，反正从来没有报过上面的错…
另外还写过用 NodeJS 做中间层，从 NodeJS 去 API 拿数据然后渲染再发到前端，也从来没报过错…&lt;/p&gt;&lt;p&gt;最近的一个 case 是，我们有用 AWS API Gateway, Lambda, DynamoDB 搭建的 API，API 被调用的时候就会 trigger 一系列的任务。然后有个小哥偷懒不想写 PHP，想在前端直接请求 AWS 的 API。于是问题来了…&lt;/p&gt;&lt;ul&gt;&lt;li&gt;浏览器不停的提示 No &amp;#x27;Access-Control-Allow-Origin&amp;#x27;的错误， 拿不到任何返回的数据。&lt;/li&gt;&lt;li&gt;但是！服务器该做的 job 却都做了！&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这根本不科学啊！！！所以？到底是什么鬼？！&lt;/p&gt;&lt;h3&gt;同源策略(Same Origin Policy)&lt;/h3&gt;&lt;p&gt;同源策略就是只有访问的内容来自&lt;strong&gt;相同协议、相同主机、相同端口&lt;/strong&gt;的内容&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;时，才会加载访问得到的内容。&lt;strong&gt;浏览器是同源策略的一种实现&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;协议：&lt;code&gt;location.protocol&lt;/code&gt;，http 和 https 是两种不同的协议&lt;/li&gt;&lt;li&gt;主机：&lt;code&gt;location.host&lt;/code&gt;，不同子域名之间都算跨域，例如&lt;a href=&quot;http://www.baidu.com&quot;&gt;www.baidu.com&lt;/a&gt;, tieba.baidu.com 是两个不同的源&lt;/li&gt;&lt;li&gt;端口：&lt;code&gt;location.port&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;CORS&lt;/h3&gt;&lt;p&gt;之前脑子里大概有个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot;&gt;CORS&lt;/a&gt;的概念，然后一直以为是服务器拒绝从浏览器跨域访问…因为要解决自己 call 自己不同域名下的 API 问题，就是去服务器设置一下 header…但其实是都是浏览器在作怪…&lt;/p&gt;&lt;p&gt;在浏览器中，允许跨域访问的资源的一些例子&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;：
&lt;code&gt;&amp;lt;script src=&amp;quot;...&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;code&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;...&amp;quot;&amp;gt;&lt;/code&gt;
&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;
&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;
&lt;code&gt;@font-face&lt;/code&gt;
&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/p&gt;&lt;h3&gt;Response Headers&lt;/h3&gt;&lt;p&gt;先看看可以在浏览器中跨域请求的别人家(github)的 API 返回的 header：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Credentials:true
Access-Control-Allow-Origin:*
Access-Control-Expose-Headers:ETag, Link, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看看自家 API 返回的 header&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Connection:keep-alive
Content-Encoding:gzip
Content-Type:text/html
Date:Fri, 22 Jan 2016 07:07:01 GMT
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;差别就在于别人家的 API 返回了&lt;strong&gt;Access-Control-Allow-Origin:*&lt;/strong&gt;
浏览器读到这个头部之后，才会加载请求的结果。&lt;/p&gt;&lt;h3&gt;跨域的时候服务器收到请求了吗？&lt;/h3&gt;&lt;p&gt;服务器当然收到请求了，不然怎么能返回头部…而且我上面举的诡异的例子中，请求 trigger 的 job 都完成了。&lt;/p&gt;&lt;p&gt;所以也就是说，服务器其实收到了你的请求，并且给你返回了全部的数据，但是浏览器看到头部就把 body 藏起来了，然后抛出错误提示…&lt;/p&gt;&lt;h3&gt;为什么浏览器不允许跨域访问？&lt;/h3&gt;&lt;p&gt;当然是为了安全……但是这个有点不太好理解，api 拿点数据有什么不安全的？！&lt;/p&gt;&lt;p&gt;下面这个例子比较清楚的说明同源策略是如何避免安全问题的：&lt;sup id=&quot;fnref-3&quot;&gt;&lt;a href=&quot;#fn-3&quot; class=&quot;footnote-ref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;
网站 A：一个看起来跟银行网站几乎一样的假网站
网站 B：真正的银行网站
如果没有同源策略： 1.当用户来到 A 网站，以为是真的银行网站，然后输入自己的账号、密码（此时用户的账号、密码已经被网站 A 获取了） 2.网站 A 利用 ajax 把账号密码发到真正的银行网站 B，然后银行网站返回一个带有 token 的 form 需要用户输入手机验证码。 3.网站 A 获得这个 form 之后显示出来，让用户填入手机验证码……至此，网站 A 获得了账号、密码、手机验证码，已经可以登陆用户的账号了。&lt;/p&gt;&lt;p&gt;而当有同源策略时，到第 2 步的时候，网站 A 根本无法获取银行网站返回的带 token 的 form，所以就算有了账户和密码，也无法操作用户的账户。&lt;/p&gt;&lt;p&gt;当然啦，银行的加密机制肯定没有我描述的这么弱智，不然还要 U 盾之类的东东干嘛，这只是一个为了方便理解安全问题而杜撰的例子…&lt;/p&gt;&lt;h3&gt;好奇宝宝&lt;/h3&gt;&lt;p&gt;不知道 chrome 的这个插件&lt;a href=&quot;https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi&quot;&gt;Allow-Control-Allow-Origin&lt;/a&gt;，是怎么实现允许跨域请求的。
之前发现启用插件的时候，github 上的小图标全都不显示了…&lt;/p&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#Cross-origin_network_access&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#Cross-origin_network_access&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-3&quot;&gt;&lt;a href=&quot;http://stackoverflow.com/questions/9222822/why-do-browser-apis-restrict-cross-domain-requests&quot;&gt;http://stackoverflow.com/questions/9222822/why-do-browser-apis-restrict-cross-domain-requests&lt;/a&gt;&lt;a href=&quot;#fnref-3&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[递归实现按顺序执行Promise]]></title><description><![CDATA[2016-01-24 更新 
我还是觉得嵌套多层的 promise 是反模式，不推荐使用，机智的我学会了另一种不嵌套不递归的方法，请看这里：
 Promise 的顺序执行和并行执行 以下为原文： 之前我一直有个疑问，当我有一堆 promise…]]></description><link>https://hiitea.io/2016/01/18/sequentialize-promise-by-recursion/</link><guid isPermaLink="false">https://hiitea.io/2016/01/18/sequentialize-promise-by-recursion/</guid><pubDate>Mon, 18 Jan 2016 09:23:18 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;2016-01-24 更新&lt;/strong&gt;
我还是觉得嵌套多层的 promise 是反模式，不推荐使用，机智的我学会了另一种不嵌套不递归的方法，请看这里：
&lt;a href=&quot;http://sabrinaluo.github.io/tech/2016/01/23/excecute-parallel-promise-and-sequential-promise/&quot;&gt;Promise 的顺序执行和并行执行&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;以下为原文：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;之前我一直有个疑问，当我有一堆 promise 的时候，怎么按顺序执行它们呢？&lt;/p&gt;&lt;p&gt;网上搜到的大多数教程都是建一个数组&lt;code&gt;array&lt;/code&gt;，把 promise 对象放到数组里，然后数组中的 promise 全部执行完毕时调用&lt;code&gt;Promise.all(array)&lt;/code&gt;。然而这只适用于数组中的&lt;strong&gt;promise 对象不互相依赖&lt;/strong&gt;的情况。&lt;/p&gt;&lt;h3&gt;问题&lt;/h3&gt;&lt;p&gt;我之前提到过一个典型的例子是 Facebook 的 Graph API 中的分页问题（ &lt;a href=&quot;https://developers.facebook.com/docs/graph-api/using-graph-api#paging&quot;&gt;Cursor-based Pagination&lt;/a&gt;），API 的 Response 如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &amp;quot;data&amp;quot;: [
     ... Endpoint data is here
  ],
  &amp;quot;paging&amp;quot;: {
    &amp;quot;cursors&amp;quot;: {
      &amp;quot;after&amp;quot;: &amp;quot;MTAxNTExOTQ1MjAwNzI5NDE=&amp;quot;,
      &amp;quot;before&amp;quot;: &amp;quot;NDMyNzQyODI3OTQw&amp;quot;
    },
    &amp;quot;previous&amp;quot;: &amp;quot;https://graph.facebook.com/me/albums?limit=25&amp;amp;amp;before=NDMyNzQyODI3OTQw&amp;quot;,
    &amp;quot;next&amp;quot;: &amp;quot;https://graph.facebook.com/me/albums?limit=25&amp;amp;amp;after=MTAxNTExOTQ1MjAwNzI5NDE=&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单的一个例子是，当我想要获取一个人的完整好友列表（Friend List），但是这个人好友太多了，分成了很多页。显然这些结果是互相依赖的。我必须先拿到第一页的&lt;code&gt;paging.next&lt;/code&gt;，才能进行下一次请求。（别跟我说改 query string &lt;code&gt;limit&lt;/code&gt;后面的值，limit 是有最大限制的=，=）&lt;/p&gt;&lt;h3&gt;解决方案&lt;/h3&gt;&lt;h5&gt;当知道总共有多少页的时候&lt;/h5&gt;&lt;p&gt;(假设 request 是一个返回 promise 对象的函数,resolve 的是上面的 json)&lt;/p&gt;&lt;ul&gt;&lt;li&gt;普通程序员这么做&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var url = &amp;#x27;http://xxx&amp;#x27;; //first page
request(url)
  .then(function (data) {
    return request(data.next);
  })
  .then(function (data) {
    return request(data.next);
  }); //....then then then...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其实这么一直 then 下去也是可以的…&lt;/p&gt;&lt;ul&gt;&lt;li&gt;二逼程序员这么做
回调函数层层嵌套…Callback Hell。&lt;/li&gt;&lt;/ul&gt;&lt;h5&gt;当不知道总共多少页的时候&lt;/h5&gt;&lt;p&gt;不停 then 的方法就不行了，于是有了文艺的程序员&lt;/p&gt;&lt;ul&gt;&lt;li&gt;文艺程序员这么做
首先要知道的一点是，当没有下一页的时候，返回的&lt;code&gt;next=null&lt;/code&gt;，于是我们就有了递归的终止条件。&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function run(url) {
  if (!url) return;
  while (url) {
    return request(url).then(function (data) {
      run(data.paging.next);
    });
  }
}
var url = &amp;#x27;http://xxx&amp;#x27;; // first page
run(url);
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;瞎扯&lt;/h3&gt;&lt;p&gt;嵌套的 Promise 其实&lt;strong&gt;可能&lt;/strong&gt;是反模式（anti-pattern）&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，但是本文中的情况，如果不递归用嵌套的 promise，我实在想不出别的办法来了（ (๑•́ ₃ •̀)宝宝心里苦，但宝宝不说）&lt;/p&gt;&lt;p&gt;为什么说可能是呢，因为谷歌一搜“promise anti pattern nesting”，总能搜出一大堆关于嵌套 promise 是反模式的文章。然而 bluebird 的 wiki&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;中，并没有提到嵌套的 promise 是反模式。&lt;/p&gt;&lt;p&gt;所以到底是不是反模式，我也不知道=，=大概的想法是，在能不嵌套的时候就不要嵌套，否则还不如用 callback。&lt;/p&gt;&lt;p&gt;能不嵌套的情况是说，then 的都是完全不同的 promise，如果都是 then 类似的 promise，那么，懒人还是递归吧…&lt;/p&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;http://taoofcode.net/promise-anti-patterns/&quot;&gt;http://taoofcode.net/promise-anti-patterns/&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns&quot;&gt;https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[对generator和yield的一些理解]]></title><description><![CDATA[于是也是入了 ES6 的坑，为什么只有 babel 这种 ES6 转 ES5 的工具，而没有 ES5 转 ES6 的工具呢？可能有，但是我不知道。如果有的话，就能把 5 转成 6，起码看起来逼格高了一大截，也能让我这种还不习惯 ES6 的小白假装会写 ES…]]></description><link>https://hiitea.io/2016/01/12/ES6-generator-yield/</link><guid isPermaLink="false">https://hiitea.io/2016/01/12/ES6-generator-yield/</guid><pubDate>Tue, 12 Jan 2016 09:11:28 GMT</pubDate><content:encoded>&lt;p&gt;于是也是入了 ES6 的坑，为什么只有 babel 这种 ES6 转 ES5 的工具，而没有 ES5 转 ES6 的工具呢？可能有，但是我不知道。如果有的话，就能把 5 转成 6，起码看起来逼格高了一大截，也能让我这种还不习惯 ES6 的小白假装会写 ES6…&lt;/p&gt;&lt;p&gt;简单的看了一下相关的概念，觉得还不太理解…就好像最开始看&lt;em&gt;原型链&lt;/em&gt;一样，花了一年多才慢慢理解继承啊什么的，但&lt;code&gt;constructor&lt;/code&gt;和&lt;code&gt;__proto__&lt;/code&gt;之类的东东我也还（4 声）没整明白…真是资质愚钝 QAQ&lt;/p&gt;&lt;h3&gt;generator function&lt;/h3&gt;&lt;p&gt;一个 generator 函数大概长这样：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function* foo() {
  console.log(111);
  yield 123;
  console.log(222);
  yield 456;
  console.log(333);
}

var a = foo(3); //此时函数不会执行
a.next(); //此时函数执行到第一句含有yield的语句时就暂停了，也就是只打印了 111
a.next(); //此时函数执行到第二句含有yield的语句时暂停，打印了 222
a.next(); //已经没有yield语句了，将会打印333，函数执行完毕
a.next(); //已经没有yiedl语句了，什么也不会打印
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;定义的时候多加一个星星号&lt;strong&gt;function*&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;generator 函数中通常都会有 yield，如果没有 yield 那就定义一个普通函数就好了&lt;/li&gt;&lt;li&gt;函数不会立即执行，使用&lt;code&gt;.next()&lt;/code&gt;方法时，函数才会执行；&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;yield&lt;/h3&gt;&lt;p&gt;yield 到底是一个什么东东呢？操作符？对象？还是别的什么，这个我还没搞明白。&lt;/p&gt;&lt;p&gt;看看阮一峰老师的这个例子，有助于理解参数的一些问题：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function* foo(x) {
  var y = 2 * (yield x + 1);
  var z = yield y / 3;
  return x + y + z;
}

var a = foo(5);
a.next(); // Object{value:6, done:false}
a.next(); // Object{value:NaN, done:false}
a.next(); // Object{value:NaN, done:false}

var b = foo(5);
b.next(); // { value:6, done:false } ，此时x=5，var y还没执行
b.next(12); // { value:8, done:false }，此时x=5，y=24，var z还没执行
b.next(13); // { value:42, done:true }，此时x=5，y=24，
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当上面的函数运行&lt;code&gt;b.next(12)&lt;/code&gt;这一句时，x=5，y=24，var z 还没执行，返回对象为&lt;code&gt;{ value:8, done:false }&lt;/code&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Q: 为什么 y=24？
A: 因为第二个 next 方法的参数传给&lt;em&gt;上一个 yield&lt;/em&gt;，也就是第一个 yield，所以 var y = 2 * 12&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;p&gt;Q: 为什么返回对象 value 为 8？
A: 因为第二个 yield 后面跟的表达式是 y/3，y=24，所以返回的对象 value 为 8&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;yield 是一个&lt;strong&gt;暂停的标记&lt;/strong&gt;，使用&lt;code&gt;.next()&lt;/code&gt;方法运行函数时，遇到 yield 就会暂停&lt;/li&gt;&lt;li&gt;yield 用在表达式中必须加括号扩起来，比如这样&lt;code&gt;var a = 1 + (yield 1+1)&lt;/code&gt;&lt;/li&gt;&lt;li&gt;调用&lt;code&gt;.next()&lt;/code&gt;方法时会返回一个对象，长这样：&lt;code&gt;{ value: xxx, done: false }&lt;/code&gt;&lt;ul&gt;&lt;li&gt;有两个 key，一个是 value，一个是 done&lt;/li&gt;&lt;li&gt;value 的值是，该次暂停遇到的这个&lt;code&gt;yield&lt;/code&gt; 后面跟的表达式的值。比如上面的例子中第一次调用&lt;code&gt;b.next()&lt;/code&gt;时，遇到第一个 yield 而暂停，&lt;code&gt;var y = 2 * (yield (x + 1));&lt;/code&gt;，yield 后面跟的表达式是(x+1)，所以返回的对象 value 是 6&lt;/li&gt;&lt;li&gt;当&lt;code&gt;done&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;说明后面没有 yield 了，之后再调用&lt;code&gt;.next()&lt;/code&gt;方法返回的 value 都是&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;&lt;li&gt;如果 generator 函数没有返回值，那么最后一个 yield 之后再调用的&lt;code&gt;.next()&lt;/code&gt;方法返回的就是&lt;code&gt;{ value:undefined, done: true }&lt;/code&gt;&lt;/li&gt;&lt;li&gt;如果 generator 函数有返回值，那么最后一个 yield 之后再调用&lt;code&gt;.next()&lt;/code&gt;方法返回的对象 value 是函数的返回值&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;调用&lt;code&gt;.next()&lt;/code&gt;方法时，可以传入参数&lt;ul&gt;&lt;li&gt;该参数是传给&lt;strong&gt;上一个 yield&lt;/strong&gt;，所以第一次调用&lt;code&gt;.next()&lt;/code&gt;时不能传入参数。&lt;em&gt;可能会报错，也可能参数会被忽略，取决于浏览器是怎么实现的&lt;/em&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;不传入参数时，yield 语句返回的值为&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;瞎扯&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;感觉 yield 像一个“函数”，执行的时候遇到这个函数就会暂停&lt;/li&gt;&lt;li&gt;这个函数返回的值等于&lt;code&gt;.next(xxx)&lt;/code&gt;调用时传入的参数 xxx，如果没有参数，返回值就是&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function* foo() {
  console.log(yield);
  console.log(yield);
}
var a = foo();
a.next(); // 遇到第一个yield暂停，什么也不打印
a.next(); // 遇到第二个yield暂停，打印上一句console.log(yield)，由于没有传入参数，yield返回undefined
a.next(&amp;#x27;hello&amp;#x27;); //后面没有yield了，函数执行完毕，打印第二个console.log，由于传入参数，将会打印出hello
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;yield 用在表达式中必须加括号扩起来，比如这样&lt;code&gt;var a = 1 + (yield 1+1)&lt;/code&gt;，有点类似于把一个函数写到表达式中要用括号括起来&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var a =
  1 +
  (function () {
    return 123;
  })();
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;好奇宝宝&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;往&lt;code&gt;next()&lt;/code&gt;里传入参数的用法，在什么场景下适用？&lt;/li&gt;&lt;li&gt;通常是不是都通过&lt;code&gt;.next().value&lt;/code&gt;来获取当前暂停的&lt;code&gt;yield&lt;/code&gt;后面的表达式？&lt;/li&gt;&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[对JS类和继承的一些理解]]></title><description><![CDATA[本文只总结最常用的实现方法，不具体讨论各种实现方法的优缺点（这些具体可以看 《JavaScript 高级程序设计》 ）。 直到 ES5，JS 也还是一个没有类的语言，虽然 ES6 中可以使用 class 关键字，但据说也只是语法糖。(不知道好不好吃 ԅ(¯﹃¯ԅ…]]></description><link>https://hiitea.io/2015/12/31/understand-js-inheritance/</link><guid isPermaLink="false">https://hiitea.io/2015/12/31/understand-js-inheritance/</guid><pubDate>Thu, 31 Dec 2015 03:36:54 GMT</pubDate><content:encoded>&lt;p&gt;本文只总结最常用的实现方法，不具体讨论各种实现方法的优缺点（这些具体可以看&lt;a href=&quot;http://book.douban.com/subject/10546125/&quot;&gt;《JavaScript 高级程序设计》&lt;/a&gt;）。&lt;/p&gt;&lt;p&gt;直到 ES5，JS 也还是一个没有类的语言，虽然 ES6 中可以使用 class 关键字，但据说也只是语法糖。(不知道好不好吃 ԅ(¯﹃¯ԅ))&lt;/p&gt;&lt;h3&gt;类的实现&lt;/h3&gt;&lt;p&gt;类的两个基本元素就是&lt;strong&gt;属性&lt;/strong&gt;和&lt;strong&gt;方法&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;JS 中类的实现有很多种，构造函数模式、原型模式等等，各有各的优缺点，最常用的是混合了构造函数和原型模式的混合模式。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function Person(name) {
  this.name = name;
}

Person.prototype.sayHi = function () {
  console.log(&amp;#x27;Hi, &amp;#x27; + this.name);
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用构造函数来构造&lt;strong&gt;属性&lt;/strong&gt;，然后往原型对象添加&lt;strong&gt;方法&lt;/strong&gt;。这样的好处是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;每个实例之间不用共享属性，拥有各自独立的属性。也就可以避免当属性为引用类型（数组、对象）时，修改一个实例的属性会影响到其他实例的情况。&lt;/li&gt;&lt;li&gt;每个实例之间共用原型对象上的方法，实现了函数复用。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;继承的实现&lt;/h3&gt;&lt;p&gt;JS 中继承的实现也有很多种，借用构造函数，原型链等等。
子类继承父类，当然继承的就是父类的&lt;strong&gt;属性和方法&lt;/strong&gt;。JS 中继承的实现，最常用的也是混合模式。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function Student(name, age) {
  Person.call(this, name);
  this.age = age;
}

console.log(Student.prototype.constructor); // Student

Student.prototype = new Person();
// 补充！有时候我们也会见到如下方式，具体区别请看下一小节
Student.prototype = Object.create(Person.prototype);

console.log(Student.prototype.constructor); // Person

Student.prototype.constructor = Student; // 重写constructor

Student.prototype.sayAge = function () {
  console.log(&amp;quot;I&amp;#x27;m &amp;quot; + this.age);
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用&lt;strong&gt;借用构造函数&lt;/strong&gt;的方式来继承&lt;strong&gt;属性&lt;/strong&gt;，然后使用&lt;strong&gt;原型链&lt;/strong&gt;来继承&lt;strong&gt;方法&lt;/strong&gt;。通过将子类的原型对象指向父类的实例，子类的实例就可以通过原型链向上查找到父类原型上的方法。&lt;/p&gt;&lt;h4&gt;&lt;code&gt;Object.create&lt;/code&gt; vs &lt;code&gt;new&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;有时候我们也会见到如下的继承方式：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;Student.prototype = Object.create(Person.prototype);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Object.create - 不调用构造函数, 原型 prototype 上不会存在&lt;code&gt;undefined&lt;/code&gt;的属性，（构造函数中的属性不会存在于原型链上，除非原型链上定义了该属性/方法，例如&lt;code&gt;Person.prototype.sayhi = function(){}&lt;/code&gt;）
new - 调用构造函数, 但由于&lt;code&gt;Student.prototype = new Person();&lt;/code&gt;没有传入参数，因此&lt;code&gt;Student.prototype.name === undefined&lt;/code&gt;&lt;/p&gt;&lt;p&gt;举个 🌰
&lt;a href=&quot;https://jsfiddle.net/HiiTea/cfy89tru/embedded/js&quot;&gt;https://jsfiddle.net/HiiTea/cfy89tru/embedded/js&lt;/a&gt;
可以看到，student 的原型链上多了一个&lt;code&gt;age: undefined&lt;/code&gt;属性
&lt;img src=&quot;https://user-images.githubusercontent.com/36024221/46127882-8f360380-c264-11e8-82af-69f214fe66cc.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;&lt;h3&gt;重写子类构造函数的意义&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Student.prototype = new Person();&lt;/code&gt;这一步完全改变了 Student 原型对象的引用，&lt;code&gt;Student.prototype.constructor&lt;/code&gt; 变为了 Person 原型对象的 constructor。
&lt;del&gt;个人觉得重写&lt;code&gt;Student.prototype.constructor = Student;&lt;/code&gt;没有什么实际意义，可能只是&lt;strong&gt;约定俗成的一种潜规则&lt;/strong&gt;。
人们通常可能已经习惯了使用 new 操作符的时候，构造函数的一致性&lt;/del&gt;&lt;/p&gt;&lt;p&gt;== update 2019/07/11 ==
啊，4 年的前的我果然 too simple too naive
重写&lt;code&gt;Student.prototype.constructor = Student;&lt;/code&gt;除了能保持构造函数一致性的问题，还能使&lt;code&gt;instanceof&lt;/code&gt;运算符给出正确的运算结果。&lt;/p&gt;&lt;p&gt;如果没有重写，&lt;code&gt;student instanceof Person&lt;/code&gt; 的结果将会是&lt;code&gt;false&lt;/code&gt;，因为&lt;code&gt;instanceof&lt;/code&gt;的内部机制是，&lt;strong&gt;判断对象的原型链中是否能找到对应的&lt;code&gt;prototype&lt;/code&gt;&lt;/strong&gt;
== update end ==&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// Student.prototype.constructor = Student; 在上面的代码中注释掉这一句
var xiaobai = new Student(&amp;#x27;小白妹妹&amp;#x27;, 10);
xiaobai.constructor; // Person
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当你在代码中遇到上面这种情况，如果不去查看之前的代码的话，肯定会觉得奇怪，为什么明明通过 Student 构造函数 new 了一个 Student 实例，而这个实例，却说自己的构造函数是 Person？！？！WTF？！&lt;/p&gt;&lt;h3&gt;参考&lt;/h3&gt;&lt;p&gt;[1] &lt;a href=&quot;http://stackoverflow.com/questions/4012998/what-it-the-significance-of-the-javascript-constructor-property&quot;&gt;http://stackoverflow.com/questions/4012998/what-it-the-significance-of-the-javascript-constructor-property&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[利用travis自动部署hexo搭建在github的博客]]></title><description><![CDATA[这篇应该属于不务正业系列…
自从知道了持续集成（Continuous Integration）这个概念之后感觉开启了新世界的大门。 Travis 是一套持续集成的服务器解决方案，也就是等于把 jenkins…]]></description><link>https://hiitea.io/2015/12/28/travis-github-hexo/</link><guid isPermaLink="false">https://hiitea.io/2015/12/28/travis-github-hexo/</guid><pubDate>Mon, 28 Dec 2015 04:00:56 GMT</pubDate><content:encoded>&lt;p&gt;这篇应该属于不务正业系列…
自从知道了持续集成（Continuous Integration）这个概念之后感觉开启了新世界的大门。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://travis-ci.org&quot;&gt;Travis&lt;/a&gt;是一套持续集成的服务器解决方案，也就是等于把 jenkins 能够实现的都放在了云端，不用自己搭服务器安装了，懒人的福音～&lt;/p&gt;&lt;p&gt;最初知道 travis 是因为总在 github 商看到这种小图标，虽然不知道是什么东东，但是觉得逼格特别高…
&lt;a href=&quot;https://travis-ci.org/sabrinaluo/tech&quot;&gt;&lt;img src=&quot;https://travis-ci.org/sabrinaluo/tech.svg?branch=master&quot; alt=&quot;Build Status&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;关于 Hexo 和 github page 这里就不讨论了，教程网上一搜一大堆。用 travis 属于进阶内容了，能搜到这篇文章的，应该也都具备了最基础的知识。&lt;/p&gt;&lt;p&gt;为什么需要 travis 来自动部署博客呢，像我这种废话多的人，倾诉欲随时随地会喷发…然后如果当时手边没有电脑，或者有电脑了但不是我的电脑，欲火就被一盆水浇灭了…而有了 travis 之后呢，只要给我一台能上网的电脑，分分钟就能发博客并且更新到自己的网站…&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/&quot;&gt;具体教程（来自 Hexo 的作者 Tommy）&lt;/a&gt;网上已经有一些了，但不是很多，这里主要说一说其中容易遇到的坑。&lt;/p&gt;&lt;h3&gt;Prerequisite&lt;/h3&gt;&lt;p&gt;注册一个 travis 账号，绑定 github，并为相应的 repo 开启 travis 服务
在 repo 中添加&lt;code&gt;.travis.yml&lt;/code&gt;文件，下面是我个人的配置。我是将 source 和 public 放在同一个 repo 的不同分支里，源文件放在 master 分支，生成后的网页放在 gh-pages 分支。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://gist.github.com/d905eeed53d9368fdee6.js&quot;&gt;https://gist.github.com/d905eeed53d9368fdee6.js&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;## 目录结构如下，其中.travis文件夹用于存放github的sshkey加密文件，以及ssh的相关配置
└── blog
    ├── _config.yml
    ├── package.json
    ├── README.md
    ├── scaffolds
    ├── source
    │   └── _posts
    ├── .travis
    │   ├── id_rsa.enc
    │   └── ssh_config
    └── .travis.yml
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;注意事项&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;before_install:
- openssl aes-256-cbc -K $encrypted_e011a6d7eebf_key -iv $encrypted_e011a6d7eebf_iv -in .travis/id_rsa.enc -out ~/.ssh/id_rsa -d
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;\$encrypted_e011a6d7eebf_key&lt;/strong&gt;这一串加密的 key 每个人都不同，请不要直接复制。请使用
&lt;code&gt;$ travis encrypt-file ssh_key --add &lt;/code&gt; 这条命令将相应的 key 写入&lt;code&gt;.travis.yml&lt;/code&gt;中。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;记得检查&lt;code&gt;.travis.yml&lt;/code&gt;文件&lt;/strong&gt;，因为在自动写入文件的过程中很可能出现了&lt;strong&gt;自动换行&lt;/strong&gt;的问题（我是 linuxmint 用 webstorm 遇到了这个问题），如果有换行的问题把换行符删除即可，否则会导致 travis 在命令跑到这里的时候出问题使得 building failed。&lt;/li&gt;&lt;li&gt;另外如果有将相应的文件移到相应的文件夹中，请记得在命令中修改相应的 path&lt;/li&gt;&lt;li&gt;如果你最后 deploy 的不是 master 分支，请在&lt;code&gt;packag.json&lt;/code&gt;中使用下面的依赖&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&amp;quot;hexo-deployer-git&amp;quot;: &amp;quot;hexojs/hexo-deployer-git#495fc6d&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;hexo-deployer-git 在 0.0.4 及之前的版本都是 hardcode 了默认使用 master 分支来 deploy，当使用非 master 分支来进行 deploy 时（本文例子中使用 gh-pages 分支中的内容）则会报错，上述版本修复了该问题。&lt;/p&gt;&lt;h3&gt;&lt;code&gt;.travis.yml&lt;/code&gt;文件解释&lt;/h3&gt;&lt;p&gt;整个配置其实是告诉 travis：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用 node 4.0 版本来 build 我的程序&lt;/li&gt;&lt;li&gt;只有当 master 分支有 commit 的时候才自动部署&lt;/li&gt;&lt;li&gt;在安装之前先解密 ssh key 以便获得 github 的写权限（这样才能 push 到 gh-pages 分支）；全局安装 hexo（这样才能直接执行 hexo 命令）；配置 git 设定（这样才能用 git）&lt;/li&gt;&lt;li&gt;克隆主题&lt;blockquote&gt;&lt;p&gt;（如果想省略这一步，你可以把主题&lt;code&gt;themes&lt;/code&gt;文件夹也放在博客 repo 的 master 分支中）&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;克隆 gh-pages 分支到&lt;code&gt;.deploy_git&lt;/code&gt;文件夹&lt;blockquote&gt;&lt;p&gt;（hexo 默认会将生成的用于 deploy 的文件都放在这个文件夹；如果不需要 gh-pages 分支的相关 commit 记录，这一步可以省略。省略后该分支永远只有最近的一次 commit…）&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;跑一下&lt;code&gt;hexo g&lt;/code&gt;命令，看看是否会有错&lt;blockquote&gt;&lt;p&gt;请注意，这一步并不能保证博客生成的样式问题，只是查看主题是否有错误。如果你每次都是克隆主题，并不能保证你克隆的版本每次都能顺利生成所有文件，可能会存在 bug&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;如果能够顺利生成网页则执行&lt;code&gt;hexo d&lt;/code&gt;，将博客 push 到 gh-pages 分支&lt;/li&gt;&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[git merge commits 如何合并多个提交为一个]]></title><description><![CDATA[因为我是那种经常改一个错别字就忙着要提交一次的人…所以总是会产生很多无意义的提交，于是合并多个提交为一个就成了我的刚性需求。 关于合并多个提交，主要是要搞清楚 rebase 的用法。 查看提交历史，git log 首先你要知道自己想合并的是哪几个提交，可以使用 git log…]]></description><link>https://hiitea.io/2015/12/24/how-to-merge-commits-with-git-rebase/</link><guid isPermaLink="false">https://hiitea.io/2015/12/24/how-to-merge-commits-with-git-rebase/</guid><pubDate>Thu, 24 Dec 2015 07:08:49 GMT</pubDate><content:encoded>&lt;p&gt;因为我是那种经常改一个错别字就忙着要提交一次的人…所以总是会产生很多无意义的提交，于是合并多个提交为一个就成了我的刚性需求。&lt;/p&gt;&lt;p&gt;关于合并多个提交，主要是要搞清楚&lt;code&gt;rebase&lt;/code&gt;的用法。&lt;/p&gt;&lt;h3&gt;查看提交历史，git log&lt;/h3&gt;&lt;p&gt;首先你要知道自己想合并的是哪几个提交，可以使用&lt;code&gt;git log&lt;/code&gt;命令来查看提交历史，假如最近 4 条历史如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;commit ada2cd944fc81cf0051c6b6cac62fad9ae6830d3
commit 0e25f1237eeaf9ae02b5b48b888a844ed288e7e3
commit ddbd8fd1d52aec0bbedc65a1a0add159344d4ae2
commit 2aad0182a613b2e73b44ebbf0d5536126f714cb9
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;历史记录是按照时间排序的，时间近的排在前面。&lt;/p&gt;&lt;h3&gt;git rebase&lt;/h3&gt;&lt;p&gt;想要合并 1-3 条，有两个方法&lt;/p&gt;&lt;ol&gt;&lt;li&gt;从 HEAD 版本开始往过去数 3 个版本&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git rebase -i HEAD~3
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;指名要合并的版本之前的版本号&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git rebase -i 2aad018
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;请注意&lt;strong&gt;2aad018&lt;/strong&gt;这个版本是不参与合并的，可以把它当做一个坐标&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;选取要合并的提交&lt;/h3&gt;&lt;p&gt;执行了 rebase 命令之后，会弹出一个窗口，头几行如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;pick ada2cd9
pick 0e25f12
pick ddbd8fd
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将&lt;code&gt;pick&lt;/code&gt;改为&lt;code&gt;squash&lt;/code&gt;或者&lt;code&gt;s&lt;/code&gt;，之后保存并关闭文本编辑窗口即可。改完之后文本内容如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;s ada2cd9
s 0e25f12
s ddbd8fd
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考：
[1] &lt;a href=&quot;https://git-scm.com/docs/git-rebase&quot;&gt;https://git-scm.com/docs/git-rebase&lt;/a&gt;
[2] &lt;a href=&quot;http://blog.csdn.net/yangcs2009/article/details/47166361&quot;&gt;http://blog.csdn.net/yangcs2009/article/details/47166361&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[git merge repo 如何合并两个仓库]]></title><description><![CDATA[为什么我每天都会有一些奇奇怪怪的需求… 我之前在 github 上用 hexo 搭了一个静态博客，每次 hexo deploy 的时候，就会在 gh-pages 分支提交一个 commit。但是由于 hexo-deployer-git 本身的逻辑是，每次都是强推 push -f…]]></description><link>https://hiitea.io/2015/12/24/how-to-merge-repos-with-git/</link><guid isPermaLink="false">https://hiitea.io/2015/12/24/how-to-merge-repos-with-git/</guid><pubDate>Thu, 24 Dec 2015 06:58:32 GMT</pubDate><content:encoded>&lt;p&gt;为什么我每天都会有一些奇奇怪怪的需求…&lt;/p&gt;&lt;p&gt;我之前在 github 上用 hexo 搭了一个静态博客，每次 hexo deploy 的时候，就会在 gh-pages 分支提交一个 commit。但是由于 hexo-deployer-git 本身的逻辑是，每次都是强推&lt;code&gt;push -f&lt;/code&gt;，于是每当我换电脑（比如从家里换到公司里）的时候，我的 commit 记录就会丢失…但是像我这种虚荣心强的人，一个错别字都要 commit 一次来增加我在 github commit 的次数…所以，我家里的电脑和公司的电脑，两个 repo 的 commit log 都不能丢！！一个都不能少！！&lt;/p&gt;&lt;h3&gt;如何合并两个仓库&lt;/h3&gt;&lt;p&gt;假设现在有两个 repo：repo1，repo2，每个 repo 中都已经有一堆提交记录了，现在想把 repo2 中的记录合并到 repo1 中，命令如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd repo1
git remote add other ../repo2
git fetch other
git checkout -b repo2 other/master
git checkout master
git merge repo2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解释：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;进入 repo1 文件夹&lt;/li&gt;&lt;li&gt;添加 repo2 作为 repo1 的远程仓库，并命名为 other&lt;/li&gt;&lt;li&gt;将 repo2 的内容获取到 repo1&lt;blockquote&gt;&lt;p&gt;注意，使用 fetch 而不是 pull，关于 fetch 和 pull 的区别&lt;a href=&quot;https://stackoverflow.com/questions/292357/what-are-the-differences-between-git-pull-and-git-fetch&quot;&gt;请戳这里&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;在 repo1 中创建名为 repo2 的新分支，同时切换到该分支，并且使用上一步获取的内容中的 master 分支的内容&lt;/li&gt;&lt;li&gt;切换到 repo1 的 master 分支&lt;/li&gt;&lt;li&gt;将 repo2 分支的内容合并到 master 分支&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;一句话总结&lt;/h3&gt;&lt;p&gt;将一个仓库的内容 checkout 到另一个仓库的一个分支，将该分支与 master 分支合并&lt;/p&gt;&lt;p&gt;参考：
[1] &lt;a href=&quot;http://blog.csdn.net/gouboft/article/details/8450696&quot;&gt;http://blog.csdn.net/gouboft/article/details/8450696&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[对Promise中的resolve，reject，catch的理解]]></title><description><![CDATA[对 promise 这个概念之前已经有了一些浅显的理解， 相关文章->戳这里 ，最近又有了一些新的理解。 .then()的时候到底是在 then 什么… 首先要理解…Promise 是一个对象，有 then()方法的对象 then()的入参是一个函数，通常在 promise…]]></description><link>https://hiitea.io/2015/12/22/understand-resolve-reject-catch-of-promise/</link><guid isPermaLink="false">https://hiitea.io/2015/12/22/understand-resolve-reject-catch-of-promise/</guid><pubDate>Tue, 22 Dec 2015 03:36:07 GMT</pubDate><content:encoded>&lt;p&gt;对 promise 这个概念之前已经有了一些浅显的理解，&lt;a href=&quot;http://sabrinaluo.com/tech/2015/12/01/promise/&quot;&gt;相关文章-&amp;gt;戳这里&lt;/a&gt;，最近又有了一些新的理解。&lt;/p&gt;&lt;h3&gt;.then()的时候到底是在 then 什么…&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;首先要理解…Promise 是一个对象，有 then()方法的对象&lt;/li&gt;&lt;li&gt;then()的入参是一个函数，通常在 promise 链中，入参是&lt;strong&gt;一个返回 promise 的函数&lt;/strong&gt;，这句话好像有点拗口，就是说入参是一个函数，这个函数会 return 一个 promise 对象&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;如何破坏 promise 链&lt;/h3&gt;&lt;p&gt;如果有这样一个 promise 链：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;p1()
  .then(p2)
  .then(p3)
  .then(function (data) {
    console.log(&amp;#x27;data: &amp;#x27; + data);
  })
  .catch(function (error) {
    console.log(&amp;#x27;error: &amp;#x27; + error);
  });

function p1() {
  return new Promise(function (resolve, reject) {
    console.log(&amp;#x27;p1 resolved&amp;#x27;);
    resolve(123);
  });
}

function p2() {
  return new Promise(function (resolve, reject) {
    console.log(&amp;#x27;p2 rejected&amp;#x27;);
    reject(456);
  });
}

function p3() {
  return new Promise(function (resolve, reject) {
    console.log(&amp;#x27;p3 resolved&amp;#x27;);
    resolve(789);
  });
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这个例子，你看到的 console.log 会是这样：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;p1 resolved
p2 rejected
error: 456
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并没有看到&lt;code&gt;p3&lt;/code&gt;的 log，而是看到了 error message，也就是说：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;在一个 promise 链中，只要任何一个 promise 被 reject，promise 链就被破坏了，reject 之后的 promise 都不会再执行，而是直接调用&lt;code&gt;.catch&lt;/code&gt;方法&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;这也是为什么在 standard practice 中，一定要在最后加上&lt;code&gt;.catch&lt;/code&gt;的原因。通过&lt;code&gt;.catch&lt;/code&gt;能够清楚的判断出 promise 链在哪个环节出了问题。&lt;/p&gt;&lt;h3&gt;如何按顺序执行已经定义的 promise&lt;/h3&gt;&lt;p&gt;这个情况在什么时候会用到呢？比如你有一个队列，队列里有很多任务，这些任务并不互相依赖执行后返回的结果。每个任务完成的时间都是不确定的，并且计算资源只允许一次执行一个任务。简单的来说，就是&lt;strong&gt;做完 A 之后再去做 B，并且 AB 是相互独立的&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;假如我现在有一堆 promise 对象，大概长这样：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;//p2, p3与p1相似
//当doSomething()执行完毕的时候，调用resolve()
//使得当前promise状态转变为fulfilled即可
var p1 = new Promise(function (resolve, reject) {
  //do something here
  //when do something done
  resolve();
});

p1.then(function () {
  return p2;
})
  .then(function () {
    return p3;
  })
  .catch();
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;请注意，前一部破坏 Promise 链中分定义的 p1 p2 p3 是&lt;strong&gt;函数&lt;/strong&gt;，而此部分定义的 p1 p2 p3 是&lt;strong&gt;对象！对象！对象！&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;如前面提到，promise 是一个有 then 方法的对象，因此 p1 可以直接调用 then
Q:为什么开头调用不是&lt;code&gt;p1().then&lt;/code&gt;？
A: 因为 p1 是一个对象啊！！！对象啊！！！象啊！！！啊！！！&lt;/li&gt;&lt;li&gt;然而 promise 链中 then 方法的入参是&lt;strong&gt;一个返回 promise 对象的函数&lt;/strong&gt;，p2 并不是一个函数，因此不能 then(p2)；&lt;/li&gt;&lt;li&gt;但 p2 是一个 promise 对象，已经满足了 then 方法入参的一半需求，那么写一个函数并且返回 p2，就满足了入参的全部需求&lt;/li&gt;&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[JS变量提升(Hoisting)]]></title><description><![CDATA[写了无数 JS 也依旧没听过变量提升… 变量提升(Hoisting)这个概念，我第一次见到是在万人膜拜的 Airbnb JS 代码风格 中见到。看完这一节大概明白是在说什么，然后觉得非常奇怪，这个概念平时写代码什么情况下用的到呢？ 我写了这么久 JS…]]></description><link>https://hiitea.io/2015/12/21/hoisting/</link><guid isPermaLink="false">https://hiitea.io/2015/12/21/hoisting/</guid><pubDate>Mon, 21 Dec 2015 02:24:02 GMT</pubDate><content:encoded>&lt;p&gt;写了无数 JS 也依旧没听过变量提升…&lt;/p&gt;&lt;p&gt;变量提升(Hoisting)这个概念，我第一次见到是在万人膜拜的&lt;a href=&quot;https://github.com/airbnb/javascript&quot;&gt;Airbnb JS 代码风格&lt;/a&gt;中见到。看完这一节大概明白是在说什么，然后觉得非常奇怪，这个概念平时写代码什么情况下用的到呢？&lt;/p&gt;&lt;p&gt;我写了这么久 JS，从来也不会先用变量后定义的呀，而且别的语言好像根本没有这个概念，难怪我从来没有遇到相关问题，难怪我没听过这个概念。难怪写强类型语言的各大神都是 JS 一生黑…&lt;/p&gt;&lt;p&gt;后来大概问了问各种前辈，纷纷表示，这个概念在面试的时候和检查别人 Bug 的时候才会用到… (︶︿︶)&lt;/p&gt;&lt;p&gt;解释器是什么东东我还没搞明白…但是变量提升其实可以转换成另一个问题：
当你在定义一个变量的时候，解释器是怎么解析的？&lt;/p&gt;&lt;p&gt;先看一个例子：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function test() {
  console.log(a);
  var a = 123;
}
test(); //调用这个函数，你会看到console中输出的是undefined
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function test() {
  var a = 123;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码，解释器是这么理解的：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function test() {
  var a;
  a = 123;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而最开始的例子中，解释器是这么理解的：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function test() {
  var a;
  console.log(a);
  a = 123;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一句话总结：变量提升就是 JS 解释器在解析 JS 的时候会把所有变量的&lt;strong&gt;声明&lt;/strong&gt;提升到该变量作用域的最顶端。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;请注意：&lt;strong&gt;只提升声明，不提升赋值&lt;/strong&gt;！&lt;/p&gt;&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[对JS闭包(Closure)的一些理解]]></title><description><![CDATA[昨天无聊在 github 上看代码，看到如下片段，反正看不太懂这是在干啥，但这就是传说中的闭包了… 以上来自目测是个阿里女神的 repo:  utilx 很久之前就听过 闭包 这个概念，看了一些相关的资料，依旧无法明白到底是个什么东东。各种作用域 scope，看得我头都大了。…]]></description><link>https://hiitea.io/2015/12/19/understand-js-closure/</link><guid isPermaLink="false">https://hiitea.io/2015/12/19/understand-js-closure/</guid><pubDate>Sat, 19 Dec 2015 11:22:27 GMT</pubDate><content:encoded>&lt;p&gt;昨天无聊在 github 上看代码，看到如下片段，反正看不太懂这是在干啥，但这就是传说中的闭包了…&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function isType(type) {
  return function (obj) {
    return {}.toString.call(obj) === &amp;#x27;[object &amp;#x27; + type + &amp;#x27;]&amp;#x27;;
  };
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;以上来自目测是个阿里女神的 repo: &lt;a href=&quot;https://github.com/fool2fish/utilx/blob/master/lib/index.js&quot;&gt;utilx&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;很久之前就听过&lt;strong&gt;闭包&lt;/strong&gt;这个概念，看了一些相关的资料，依旧无法明白到底是个什么东东。各种作用域 scope，看得我头都大了。_(:з」∠)_&lt;/p&gt;&lt;p&gt;我在这里呢，也不会讲继续什么变量作用域，什么从外部读取局部变量之类的！@#￥%…的东东，我试图用最简单粗暴连隔壁卖红薯的大妈都能理解的方法，来说说我对闭包的理解。&lt;/p&gt;&lt;p&gt;###闭包长什么样子？&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function bibao(a) {
  return function (b) {
    return a + b;
  };
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的例子就是一个闭包。
我的理解是，闭包有这么几个元素：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;最外层是一个有名字的函数，通常都需要传入参数或者在这一层定义一些变量。&lt;/li&gt;&lt;li&gt;这个有名字的函数返回一个匿名函数，通常都需要传入参数或者定义一些变量。&lt;/li&gt;&lt;li&gt;这个匿名函数返回的值通常跟上面两点中的入参或者变量有关。&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;如何使用闭包？&lt;/h3&gt;&lt;p&gt;这个问题其实也就是说，当你调用闭包的时候你其实是在调用什么？
我觉得搞清楚这个问题对于简单粗暴的理解闭包非常有用。&lt;/p&gt;&lt;p&gt;用上面的闭包作为例子，通常闭包是这么用的：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;//例1，分两次传入参数
var hello = bibao(&amp;#x27;你好&amp;#x27;)；
var text = hello(&amp;#x27;小白妹妹&amp;#x27;);
console.log(text); //你会看到 你好小白妹妹
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这个例子，其实就是：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;//例2，一次传入两个参数
var text = bibao(&amp;#x27;你好&amp;#x27;)(&amp;#x27;小白妹妹&amp;#x27;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以基本上可以理解为，有这么一个函数&lt;code&gt;bibao(a)(b)&lt;/code&gt;，调用的时候需要传入两个参数&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;，你可以&lt;strong&gt;分开传&lt;/strong&gt;，也可以&lt;strong&gt;一起传&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;大多数情况下，都是像例 1 一样，分开两次传入参数的。当你分开传的时候，第一次传入参数&lt;code&gt;a&lt;/code&gt;，也就是&lt;code&gt;var hello = bibao(&amp;#x27;你好&amp;#x27;);&lt;/code&gt;其实等于：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var hello = function (b) {
  return &amp;#x27;你好&amp;#x27; + b;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以当你给&lt;code&gt;hello()&lt;/code&gt;传入参数&lt;code&gt;b&lt;/code&gt;的时候，&lt;code&gt;var text = hello(&amp;#x27;小白妹妹&amp;#x27;)&lt;/code&gt;，返回的是“你好小白妹妹”。也就等于说，当你在调用&lt;code&gt;hello()&lt;/code&gt;这个函数的时候，其实访问到了 bibao()这个函数中的变量&lt;code&gt;a&lt;/code&gt;，值为&amp;#x27;你好&amp;#x27;。&lt;/p&gt;&lt;p&gt;闭包中&lt;code&gt;a&lt;/code&gt;是定义在匿名函数外部的，这就是传说中的：&lt;strong&gt;内部函数可以访问外部函数的变量&lt;/strong&gt;。&lt;/p&gt;&lt;h3&gt;为什么要使用闭包？使用闭包有什么好处？&lt;/h3&gt;&lt;p&gt;我有一个强烈的感觉闭包是一个懒人发明的…（当然我是瞎说的_(:з」∠)_）
假如我的老板认识了一大堆妹子，要我写个程序跟她们每个人说早安、午安、晚安，并告诉他们昨天是几号，最后还要问候他的老婆，“吃饭了吗？亲爱的”
通常我会这么实现：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function yesterday() {
  return new Date().getDate() - 1;
}
function goodmorning(name) {
  return &amp;#x27;早安&amp;#x27; + name + &amp;#x27;昨天是&amp;#x27; + yesterday() + &amp;#x27;号&amp;#x27;;
}
function goodafternoon(name) {
  return &amp;#x27;午安&amp;#x27; + name + &amp;#x27;昨天是&amp;#x27; + yesterday() + &amp;#x27;号&amp;#x27;;
}
function goodnight(name) {
  return &amp;#x27;晚安&amp;#x27; + name + &amp;#x27;昨天是&amp;#x27; + yesterday() + &amp;#x27;号&amp;#x27;;
}
//eating()这个函数不一定非要定义，可以直接console.log()也能满足需求，
//但是想到老板将来又会去问候其他的人，吃饭了吗？xxx，
//所以定义了一个函数，以便将来可以偷懒
function eating(name) {
  return &amp;#x27;吃饭了吗？&amp;#x27; + name;
}
var list = [&amp;#x27;小白妹妹&amp;#x27;, &amp;#x27;小红妹妹&amp;#x27;, &amp;#x27;小黑妹妹&amp;#x27;, &amp;#x27;小灰妹妹&amp;#x27;];
list.forEach(function (item) {
  console.log(goodmorning(item));
  console.log(goodafternoon(item));
  console.log(goodnight(item));
});
console.log(eating(&amp;#x27;亲爱的&amp;#x27;));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用闭包这么实现：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function yesterday() {
  return new Date().getDate() - 1;
}
function bibao(greeting) {
  return function (name) {
    return greeting + name + &amp;#x27;昨天是&amp;#x27; + yesterday() + &amp;#x27;号&amp;#x27;;
  };
}
var goodmorning = bibao(&amp;#x27;早安&amp;#x27;);
var goodafternoon = bibao(&amp;#x27;午安&amp;#x27;);
var goodnight = bibao(&amp;#x27;晚安&amp;#x27;);
var list = [&amp;#x27;小白妹妹&amp;#x27;, &amp;#x27;小红妹妹&amp;#x27;, &amp;#x27;小黑妹妹&amp;#x27;, &amp;#x27;小灰妹妹&amp;#x27;];
list.forEach(function (item) {
  console.log(goodmorning(item));
  console.log(goodafternoon(item));
  console.log(goodnight(item));
});
var eating = bibao(&amp;#x27;吃饭了吗？&amp;#x27;);
console.log(eating(&amp;#x27;亲爱的&amp;#x27;));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，使用了闭包就不用重复定义&lt;strong&gt;行为类似&lt;/strong&gt;的函数，&lt;code&gt;+ name +&amp;#x27;昨天是&amp;#x27; + yesterday() + &amp;#x27;号&amp;#x27;;&lt;/code&gt;这个也只用写一遍就可以了，免去了很多重复劳动，看起来简洁了很多，最重要是…显得逼格高…&lt;/p&gt;&lt;h3&gt;什么时候用闭包？&lt;/h3&gt;&lt;p&gt;我自己的感觉是，当你需要定义很多行为类似的函数的，重复写很多基本类似的内容的时候，就可以考虑用闭包来让整个代码的结构更加简洁。（总觉得使用闭包，可读性就不那么强了，毕竟我这种小白还是不太一眼就看得出来一个闭包到底输入啥返回啥的…）&lt;/p&gt;&lt;p&gt;另外就也不太清楚具体的使用场景了，反正我平时很少用到…少用到的可能有这么几个：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;对闭包的理解不够深入，其实还是不太知道这个东东到底干啥用的&lt;/li&gt;&lt;li&gt;通常用别的简单粗暴的方法来代替闭包实现的功能，简单的来说比如一个人不知道 switch，但是知道 if else，于是用 if else 来实现跟 switch 一样的功能&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我不知道有没有什么情况是除了闭包就没办法解决的…如果没有…那么用其他方法代替实现就可以了，实在搞不明白也没什么关系…&lt;/p&gt;&lt;h3&gt;使用闭包的坏处？&lt;/h3&gt;&lt;p&gt;据说是可能出现内存泄露的问题&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，这个就更高深了…以后有了深入的理解再来补充吧&lt;/p&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript#内存泄露&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[对module.exports和exports的一些理解]]></title><description><![CDATA[可能是有史以来最简单通俗易懂的有关 Module.exports 和 exports 区别的文章了。 module.exports 和 exports 的区别就是 var a={}; var b=a; ，a 和 b…]]></description><link>https://hiitea.io/2015/12/16/difference-between-Module-exports-with-exports-in-NodeJS/</link><guid isPermaLink="false">https://hiitea.io/2015/12/16/difference-between-Module-exports-with-exports-in-NodeJS/</guid><pubDate>Wed, 16 Dec 2015 03:00:27 GMT</pubDate><content:encoded>&lt;p&gt;可能是有史以来最简单通俗易懂的有关 Module.exports 和 exports 区别的文章了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;module.exports&lt;/code&gt;和&lt;code&gt;exports&lt;/code&gt;的区别就是&lt;code&gt;var a={}; var b=a;&lt;/code&gt;，a 和 b 的区别&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;看起来木有什么太大区别，但实际用起来的时候却又有区别，这是为啥呢，请听我细细道来&lt;/p&gt;&lt;p&gt;关于 Module.exports 和 exports 有什么区别，网上一搜一大把，但是说的都太复杂了…
听说 exports 是 Module.exports 对象的一个引用(reference)&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，什么是引用？！…_(:з」∠)_&lt;/p&gt;&lt;p&gt;当然啦，如果要彻底理解这两个导出的区别，最好肯定是去看源码，看看都是怎么封装的，功力深厚的童鞋应该一看就懂了。不过，源码我也是看不懂的…(ಥ_ಥ)&lt;/p&gt;&lt;p&gt;但是最近感觉杂七杂八看了好多文章做了好多实验之后，像是打开了任督二脉，机智的我好像有点上道了…&lt;/p&gt;&lt;h1&gt;module&lt;/h1&gt;&lt;p&gt;首先要明确的一点，module 是一个&lt;strong&gt;对象&lt;/strong&gt; &lt;code&gt;{Object}&lt;/code&gt;。
当你新建一个文件，比如 mo.js，文件内容如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;console.log(module);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在 CMD 里执行这个文件&lt;code&gt;node mo.js&lt;/code&gt;，就能看到 module 其实是一个 Module 实例，你可以这么理解，NodeJS 中定义了一个 Module 类，这个类中有很多属性和方法，exports 是其中的一个属性：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;function Module {
  id : &amp;#x27;blabla&amp;#x27;,
  exports : {},
  blabla...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当每个 js 文件在执行或被 require 的时候，NodeJS 其实创建了一个新的实例&lt;code&gt;var module = new Module()&lt;/code&gt;，这个实例名叫&lt;code&gt;module&lt;/code&gt;。
&lt;strong&gt;这也就是为什么你并没有定义&lt;code&gt;module&lt;/code&gt;这个变量，却能 console.log 出来而不会报错的原因&lt;/strong&gt;。&lt;/p&gt;&lt;h1&gt;module.exports&lt;/h1&gt;&lt;p&gt;假设我有一个 JS 文件内容如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;console.log(module); //你会看到Module中的exports为空对象{}
module.exports = {
  print: function () {
    console.log(12345);
  },
};
console.log(module); //你会看到Module中的exports对象已经有了print()方法
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有了上面的基础，很容易理解&lt;code&gt;module.export&lt;/code&gt;其实是&lt;strong&gt;给 Module 实例中的 exports 对象中添加方法/属性&lt;/strong&gt;。&lt;/p&gt;&lt;h1&gt;exports&lt;/h1&gt;&lt;p&gt;通常使用 exports 的时候，是这么用的：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;exports.print = function () {
  console.log(12345);
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假设我有一个 JS 文件内容如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;console.log(module); //你会看到Module中的exports为空对象{}
console.log(exports); //你会看到Module中的exports为空对象{}
module.exports = {
  print: function () {
    console.log(12345);
  },
};
console.log(module); //你会看到Module中的exports对象有了print()方法
exports.name = &amp;#x27;小白妹妹&amp;#x27;;
console.log(module); //你会看到Module中的exports对象不仅有了print()方法，还有了name属性
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由此也能看出，传说中的&lt;strong&gt;&lt;code&gt;exports&lt;/code&gt;其实是&lt;code&gt;module.exports&lt;/code&gt;的引用&lt;/strong&gt;，你可以这么理解，NodeJS 在你的代码&lt;strong&gt;之前&lt;/strong&gt;悄悄的加了以下代码：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;var module = new Module();
var exports = module.exports;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;这也就是为什么你并没有定义&lt;code&gt;exports&lt;/code&gt;这个变量，却能 console.log 出来而不会报错的原因&lt;/strong&gt;。&lt;/p&gt;&lt;h1&gt;require&lt;/h1&gt;&lt;p&gt;当你从外部调用某个模块，require 其实是在 require 什么？&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;
require 的时候 NodeJS 会&lt;del&gt;到处&lt;/del&gt;去找有没有这个模块，如果有，return 的就是 module.exports 里的东东。&lt;/p&gt;&lt;h1&gt;DOs &amp;amp; DONTs&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;√ 你可以这样：&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;module.exports.name = &amp;#x27;小白妹妹&amp;#x27;;
exports.age = 10;
module.exports.print = function () {
  console.log(12345);
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果只是使用&lt;code&gt;.&lt;/code&gt;来添加属性和方法，&lt;code&gt;module.exports&lt;/code&gt;和&lt;code&gt;exports&lt;/code&gt;混用是完全可以的，这种情况下，感觉&lt;code&gt;exports&lt;/code&gt;就是给懒人用的…毕竟能少写几个 7 个字符呢！&lt;/p&gt;&lt;ul&gt;&lt;li&gt;√ 也可以这样：&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;module.exports = {
  name = &amp;#x27;小白妹妹&amp;#x27;;
};
exports.age = 10;
module.exports.print = function(){console.log(12345)};
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;× 但不可以这样&lt;/strong&gt;：&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;module.exports = {
  name = &amp;#x27;小白妹妹&amp;#x27;;
};
exports = {age:10}; // exports现在是{age:10}这个对象的引用，不再是module.exports的引用了
console.log(module); //你会看到Module的exports中只有name属性！！！
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;× 也不可以这样&lt;/strong&gt;：&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;exports.age = 10;
console.log(module); //你会看到Module的exports中多了age属性
module.exports = {
  name = &amp;#x27;小白妹妹&amp;#x27;;
};
console.log(module); //你会看到Module的exports中还是只有name属性！！！
&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;总结&lt;/h1&gt;&lt;p&gt;还是那一句话，&lt;code&gt;module.exports&lt;/code&gt;和&lt;code&gt;exports&lt;/code&gt;的区别就是&lt;code&gt;var a={}; var b=a;&lt;/code&gt;，a 和 b 的区别&lt;/p&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;改变&lt;code&gt;exports&lt;/code&gt;的指向后所添加的&lt;code&gt;exports.xxx&lt;/code&gt;都是无效的。因为 require 返回的只会是&lt;code&gt;module.exports&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;ul&gt;&lt;li&gt;不能在使用了&lt;code&gt;exports.xxx&lt;/code&gt;之后，改变&lt;code&gt;module.exports&lt;/code&gt;的指向。因为&lt;code&gt;exports.xxx&lt;/code&gt;添加的属性和方法并不存在于&lt;code&gt;module.exports&lt;/code&gt;所指向的新对象中。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;感觉自己说的还是挺清楚哒～
不管你清不清楚，我反正是清楚了。_(:з」∠)_
&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;: &lt;a href=&quot;https://nodejs.org/dist/latest-v4.x/docs/api/modules.html#modules_exports_alias&quot;&gt;https://nodejs.org/dist/latest-v4.x/docs/api/modules.html#modules_exports_alias&lt;/a&gt;
&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;: &lt;a href=&quot;https://nodejs.org/dist/latest-v4.x/docs/api/modules.html#modules_module_require_id&quot;&gt;https://nodejs.org/dist/latest-v4.x/docs/api/modules.html#modules_module_require_id&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[AWS API Gateway与AWS Lambda的整合及开发/测试/生产环境的设置]]></title><description><![CDATA[本文 不是 介绍  AWS API Gateway  和  AWS Lambda 的基本用法的…=(:з」∠) _ 简单的来说，有了 AWS 的 API Gateway 和 Lambda 这两样东东，再加一个数据库（ 最好当然是用 AWS DynamoDB 啦，或者 AWS EC…]]></description><link>https://hiitea.io/2015/12/15/Setup-DEV-QA-PROD-Environments-forAWS-Api-Gateway-AWS-Lambda/</link><guid isPermaLink="false">https://hiitea.io/2015/12/15/Setup-DEV-QA-PROD-Environments-forAWS-Api-Gateway-AWS-Lambda/</guid><pubDate>Tue, 15 Dec 2015 02:55:13 GMT</pubDate><content:encoded>&lt;p&gt;本文&lt;strong&gt;不是&lt;/strong&gt;介绍 &lt;a href=&quot;https://aws.amazon.com/api-gateway/&quot;&gt;AWS API Gateway&lt;/a&gt; 和 &lt;a href=&quot;https://aws.amazon.com/lambda/&quot;&gt;AWS Lambda&lt;/a&gt;的基本用法的…=(:з」∠)_&lt;/p&gt;&lt;p&gt;简单的来说，有了 AWS 的 API Gateway 和 Lambda 这两样东东，再加一个数据库（&lt;em&gt;最好当然是用 AWS DynamoDB 啦，或者 AWS EC2 上装 mysql，不用 AWS 也可以，但是访问速度可能会有一定影响，毕竟如果都用 AWS 的话算是走内网会快一些？！&lt;/em&gt;），不需要任何网络应用的框架你就能开发出非常 RESTful 的 API 了，简直是中小型公司提高开发效率的神器！&lt;/p&gt;&lt;p&gt;再简单的来说，API Gateway 给你提供一个 URL，当这个 url 被访问的时候，就会调用你设置的某个 Lambda 函数，这个函数执行完了之后就会返回你设定的数据。也就是说，以前你在服务器端收到一个请求，然后&lt;strong&gt;“做一堆事”&lt;/strong&gt;完了之后发出响应 Response 的这个“做一堆事”和 Response，写在一个 Lambda 函数里就可以了。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;通常如果浏览器端使用 ajax 访问这个 URL 都会存在跨域的问题，API Gateway 当然很贴心的提供了 enable CORS 选项！&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;AWS Lambda 目前支持 python，JAVA，NodeJS。这个 Lambda 函数呢，只是叫 Lambda 而已，实际写起来跟函数式编程也没有太大的关系，以前怎么写现在也还是一样的写…神奇的是，Lambda 之间可以相互调用，另外除了 API Gateway 之外，很多别的跟 API Gateway 无关的事件 event 也可以作为 trigger（&lt;em&gt;比如当 DynamoDB 的某个 Table 新增一条用户记录的时候，调用一个名称为&lt;code&gt;sendWelcomeEmailToUser()&lt;/code&gt;的 Lambda 函数，给用户发欢迎邮件&lt;/em&gt;）&lt;/p&gt;&lt;p&gt;那么，问题来了…&lt;del&gt;挖掘机技术哪家强&lt;/del&gt;
如何设置 AWS API Gateway 和 AWS Lambda 来实现开发/测试/生产环境的需求呢？难道要同一个功能的 API 建 3 个、同一个功能的 lambda 建 3 个？！&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;以下所有内容都是在 AWS 的 WEB UI 中进行设置的。&lt;em&gt;（除了在 UI 中设置，还可以写 Shell 脚本去批量执行这些设置，当然啦，这个我还没学会…）&lt;/em&gt;&lt;/p&gt;&lt;p&gt;哦，忘了说…首先你要有个…API，然后你还要有个 Lambda。
假设：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;API endpoint 是 /stageTest，方法是&lt;code&gt;GET&lt;/code&gt;。&lt;/strong&gt; &lt;em&gt;（成就 GET√ =(:з」∠)_）&lt;/em&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Lambda 名为 stageTest。&lt;/strong&gt; &lt;em&gt;（endpoint 的名字和 lambda 名字可以不同…原谅我是取名无能星人…）&lt;/em&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;DEV / QA / PROD 环境的设置&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;为 API Gateway 创建不同的 stage&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，假设创建了 3 个分别是 dev，qa，prod。&lt;/strong&gt; &lt;em&gt;（教程是官方英文的，点引用的链接就可以看到，憋让我翻译，我懒…我知道还有 pre-prod，多加一个下面的解释就得多写好多字(ಥ&lt;/em&gt;ಥ)）_&lt;blockquote&gt;&lt;p&gt;设置了 stage 之后你的 api endpoin 看起来大概长这样：&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;aws-apiID&amp;gt;.execute-api.&amp;lt;aws-region&amp;gt;.amazonaws.com/dev&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;&amp;lt;aws-apiID&amp;gt;.execute-api.&amp;lt;aws-region&amp;gt;.amazonaws.com/qa&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;&amp;lt;aws-apiID&amp;gt;.execute-api.&amp;lt;aws-region&amp;gt;.amazonaws.com/prod&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;strong&gt;为每个的 Stage 设置 stageVariables&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;，假设为每个 Stage 都设置了一个名为 env 的变量&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;dev 这个 stage 中 env 变量的值为 DEV&lt;/li&gt;&lt;li&gt;qa 这个 stage 中 env 变量的值为 QA&lt;/li&gt;&lt;li&gt;prod 这个 stage 中 env 变量的值为 PROD&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;strong&gt;Lambda stageTest()函数创建不同的 alias&lt;sup id=&quot;fnref-3&quot;&gt;&lt;a href=&quot;#fn-3&quot; class=&quot;footnote-ref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&quot;fnref-4&quot;&gt;&lt;a href=&quot;#fn-4&quot; class=&quot;footnote-ref&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;，假设创建了 3 个分别是 DEV，QA，PROD，分别指向不同的版本。&lt;/strong&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;在每次 deploy 后，都是\$LATEST 版本，点 action&amp;gt;publish new version 发布不同的版本&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;建议 DEV 指向\$LATEST 版本，QA 和 PROD 指向其他稳定的版本&lt;/li&gt;&lt;li&gt;为 Lambda 创建了 alias 之后，其实这个 lambda 访问的名称就有了以下四种：&lt;code&gt;stageTest&lt;/code&gt;，&lt;code&gt;stageTest:DEV&lt;/code&gt;，&lt;code&gt;stageTest:QA&lt;/code&gt;，&lt;code&gt;stageTest:PROD&lt;/code&gt;，其中&lt;code&gt;stageTest&lt;/code&gt;永远指向\$LATEST 版本，其他指向之前设置的各个版本&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;&lt;strong&gt;整合 API /stageTest 的 GET 方法与 Lambda stageTest()&lt;sup id=&quot;fnref-5&quot;&gt;&lt;a href=&quot;#fn-5&quot; class=&quot;footnote-ref&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;首先在 API Gateway 的界面中设置每个 API 方法的&lt;strong&gt;Integration Request&lt;/strong&gt;：Integration Type 选择 Lambda Function；Lambda Function 填&lt;code&gt;stageTest:${stageVariables.env}&lt;/code&gt;，&lt;strong&gt;&lt;code&gt;${stageVariables.env}&lt;/code&gt;&lt;/strong&gt;就是第 2 步中，设置的变量。&lt;/li&gt;&lt;li&gt;设置 Lambda Function 名称的时候一定要记得点旁边的 √ 保存，保存的时候，AWS 会弹出一个对话框，需要给函数加上权限才能使用 stageVariables 变量。加的时候记得要执行三次命令，也就是在 AWS 给出的命令的对应的位置改成 &lt;code&gt;stageTest:DEV&lt;/code&gt;，&lt;code&gt;stageTest:QA&lt;/code&gt;，&lt;code&gt;stageTest:PROD&lt;/code&gt; 每个执行一次。&lt;/li&gt;&lt;li&gt;执行以上命令之前，你必须：&lt;ul&gt;&lt;li&gt;安装 AWS CLI&lt;/li&gt;&lt;li&gt;执行命令&lt;code&gt;aws configure&lt;/code&gt;，填写你的 AWS ID 和 key，设施 default region 为你的 lambda function 所在的 region&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;那么，问题又来了…&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果你已经部署了很多 lambda 和 api 却没有使用 stage 的话…似乎是不太可能手动去 AWS 界面上一个一个设置的&lt;/li&gt;&lt;li&gt;就算你已经在使用 stage 了，似乎也不太可能每次都手动去 AWS 界面上一个一个 deploy 最新的版本以及改变 alias 指向的版本的…&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这个时候，你就必须研究&lt;a href=&quot;https://aws.amazon.com/cli/&quot;&gt;AWS CLI&lt;/a&gt;，然后写 shell 以及借助其他工具来进行自动化部署了…&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Reference&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://docs.aws.amazon.com/apigateway/latest/developerguide/stage-variables.html&quot;&gt;http://docs.aws.amazon.com/apigateway/latest/developerguide/stage-variables.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#stagevariables-template-reference&quot;&gt;http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#stagevariables-template-reference&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;http://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-set-stage-variables-aws-console.html&quot;&gt;http://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-set-stage-variables-aws-console.html&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;http://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-set-stage-variables-aws-console.html&quot;&gt;http://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-set-stage-variables-aws-console.html&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-3&quot;&gt;&lt;a href=&quot;http://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html&quot;&gt;http://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html&lt;/a&gt;&lt;a href=&quot;#fnref-3&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-4&quot;&gt;&lt;a href=&quot;http://docs.aws.amazon.com/lambda/latest/dg/aliases-intro.html&quot;&gt;http://docs.aws.amazon.com/lambda/latest/dg/aliases-intro.html&lt;/a&gt;&lt;a href=&quot;#fnref-4&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-5&quot;&gt;&lt;a href=&quot;http://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started.html&quot;&gt;http://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started.html&lt;/a&gt;&lt;a href=&quot;#fnref-5&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[AWS DynamoDB的本地安装及环境配置]]></title><description><![CDATA[DynamoDB 是亚马逊 AWS 云服务提供的一个 NoSQL 的数据库… 在这里我必须安利一下 Amazon 家的服务真是业界良心：前不久，可能是因为我自己蠢，英文不好没看懂免费用一年的各种限制，也不知道写了什么奇怪的东东用自己的账号测试 dynamoDB…]]></description><link>https://hiitea.io/2015/12/14/how-to-setup-dynamodb-at-local/</link><guid isPermaLink="false">https://hiitea.io/2015/12/14/how-to-setup-dynamodb-at-local/</guid><pubDate>Mon, 14 Dec 2015 06:39:35 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html&quot;&gt;DynamoDB&lt;/a&gt;是亚马逊 AWS 云服务提供的一个 NoSQL 的数据库…&lt;/p&gt;&lt;p&gt;在这里我必须安利一下 Amazon 家的服务真是业界良心：前不久，可能是因为我自己蠢，英文不好没看懂免费用一年的各种限制，也不知道写了什么奇怪的东东用自己的账号测试 dynamoDB 被扣了几刀，写邮件去投诉说你们不是免费吗为啥扣费，然后就得到回复解释了一下为啥扣钱，说我用超过限制了，然后表示个人账号里扣了的钱会&lt;strong&gt;退退退&lt;/strong&gt;！（我说明了之后会用公司账号测试，请帮我关了我的个人账户）&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;本文是 Linux 环境下的安装和配置，windows 下我还不会…&lt;/p&gt;&lt;ol&gt;&lt;li&gt;安装 JAVA SDK&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;$ sudo add-apt-repository ppa:webupd8team/java
$ sudo apt-get update
$ sudo apt-get install oracle-java8-installer
$ sudo apt-get install oracle-java8-set-default
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;安装 dynamodb-local&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;下载 daynamodb-local：&lt;a href=&quot;http://dynamodb-local.s3-website-us-west-2.amazonaws.com/dynamodb_local_latest.tar.gz&quot;&gt;点这里下载&lt;/a&gt;&lt;/li&gt;&lt;li&gt;解压文件&lt;/li&gt;&lt;li&gt;进入文件目录执行以下命令：&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;java -Djava.library.path=./DynamoDBLocal_lib -jar DynamoDBLocal.jar -sharedDb
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;安装 awscli，执行以下命令：&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;pip install awscli
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;配置环境变量，执行以下命令：&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;aws configure
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;这时会让你输入 AWS_ACCESS_KEY_ID 和 AWS_SECRET_ACCESS_KEY，这两个值需要&lt;strong&gt;成功注册 AWS 服务&lt;/strong&gt;之后在 AWS 的网站上会看到&lt;/li&gt;&lt;li&gt;AWS_DEFAULT_REGION，根据需要设置，也就是你的数据库打算放在 AWS 的那个区就设为哪个区，如果只是测试一下，懒得去看有什么区域，那么好吧，你可以设为&lt;code&gt;us-east-1&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;启动 dynamodb，进入 dynamodb 目录（也就是你解压 dynamodb 的地方），执行以下命令：&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;java -Djava.library.path=./DynamoDBLocal_lib -jar DynamoDBLocal.jar -sharedDb
&lt;/code&gt;&lt;/pre&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;
[1] &lt;a href=&quot;http://tecadmin.net/install-oracle-java-8-jdk-8-ubuntu-via-ppa/&quot;&gt;http://tecadmin.net/install-oracle-java-8-jdk-8-ubuntu-via-ppa/&lt;/a&gt;
[2][DynamoDBLocal Downloading And Running](&lt;a href=&quot;http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tools.DynamoDBLocal.html#Tools.DynamoDBLocal.DownloadingAndRunning&quot;&gt;http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tools.DynamoDBLocal.html#Tools.DynamoDBLocal.DownloadingAndRunning&lt;/a&gt;)
[3] &lt;a href=&quot;http://aws.amazon.com/cli/&quot;&gt;http://aws.amazon.com/cli/&lt;/a&gt;
[4] &lt;a href=&quot;http://boto3.readthedocs.org/en/latest/guide/configuration.html&quot;&gt;http://boto3.readthedocs.org/en/latest/guide/configuration.html&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[JS注释中的感叹号是干什么用的/*! */]]></title><description><![CDATA[前几天看了一个帖子 我招不到想要的程序员 ，里面有一点是说 非极端情况下，一本以下的不要 。本来学历这种事情大家都无所谓，毕竟我所认识的大多数都是 985、211 的本硕博。只有当进入了另一个不同的世界，才觉得学历还挺重要的…
我的 JS…]]></description><link>https://hiitea.io/2015/12/14/JS-important-comment/</link><guid isPermaLink="false">https://hiitea.io/2015/12/14/JS-important-comment/</guid><pubDate>Mon, 14 Dec 2015 06:15:06 GMT</pubDate><content:encoded>&lt;p&gt;前几天看了一个帖子&lt;a href=&quot;http://www.jianshu.com/p/fdae559d1ed5&quot;&gt;我招不到想要的程序员&lt;/a&gt;，里面有一点是说&lt;strong&gt;非极端情况下，一本以下的不要&lt;/strong&gt;。本来学历这种事情大家都无所谓，毕竟我所认识的大多数都是 985、211 的本硕博。只有当进入了另一个不同的世界，才觉得学历还挺重要的…
我的 JS 基本都是靠自学，我的大神同学们都是搞后端强类型语言的，所以我只能上网搜搜，买点书看看，加几个参差不齐的 QQ 群问一问。然而我这种月亮处女座的强迫症细节好奇宝宝常常会有奇奇怪怪找不到答案的问题……
有一天我看代码的时候发现很多规范的 JS 都会有这样的注释：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;/*!
 * EJS
 * Copyright(c) 2012 TJ Holowaychuk &amp;lt;tj@vision-media.ca&amp;gt;
 * MIT Licensed
 */

/**
 * Module dependencies.
 */
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上来自我的男神&lt;a href=&quot;https://github.com/tj/ejs/blob/master/ejs.js&quot;&gt;TJ 写的 EJS 模板引擎&lt;/a&gt;&lt;/p&gt;&lt;p&gt;我就在 QQ 群里问了这样一个问题：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;第一个注释中的感叹号是什么意思，为什么第一个有感叹号，第二个没有？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;然后似乎没有人知道，并且我到的回答基本都是诸如：那就是行注释没什么特别的意思、在意注释干嘛反正注释也没什么用……&lt;/p&gt;&lt;p&gt;然后我就忽然有点明白了为什么一本以下的不要…&lt;/p&gt;&lt;p&gt;类似这样的问题，为什么在网上很难找答案？可能是因为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;搜索引擎对于特殊符号的处理导致难以按照符号来搜索
包括 google 和 stackoverflow 中输入&lt;code&gt;/*!&lt;/code&gt;并不能搜到结果&lt;/li&gt;&lt;li&gt;因为缺乏经验而无法正确的描述问题，无法命中问题的关键字&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;像我这样比较懒的人，最希望的就是能有一个在现实生活中认识的经验丰富的大神，这种弱鸡问题，一问就有答案了。然而我并不认识这样的大神。(ಥ_ಥ)&lt;/p&gt;&lt;p&gt;直到后来无意中看到&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/06/sass.html&quot;&gt;阮一峰老师的 SASS 教程&lt;/a&gt;，提到&lt;strong&gt;重要注释&lt;/strong&gt;这个概念，受到一点启发，然后机智的我想到把感叹号直接翻译成英文，以&amp;#x27;exclamation js comment&amp;#x27;作为关键字来搜索，果然我不是一个人…（嗯，我变成了一条狗）
&lt;a href=&quot;http://stackoverflow.com/questions/11248363/the-purpose-of-starting-an-initial-comment-with-in-javascript-and-css-files&quot;&gt;http://stackoverflow.com/questions/11248363/the-purpose-of-starting-an-initial-comment-with-in-javascript-and-css-files&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;我不是为了输赢，我就是认真 --罗永浩&lt;/p&gt;&lt;/blockquote&gt;&lt;hr/&gt;&lt;p&gt;对前端工程化稍微有点知识的，就会知道在最后 deploy 之前会有一个步骤是 minify / uglify，这个过程中注释都会被删除，而这个以&lt;code&gt;/*!&lt;/code&gt;开头的重要注释则会被保留，通常重要注释是用来注释版权之类的信息&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://zoompf.com/blog/2009/11/jsmin-important-comments-and-copyright-violations&quot;&gt;https://zoompf.com/blog/2009/11/jsmin-important-comments-and-copyright-violations&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[GitHub Page如何绑定域名]]></title><description><![CDATA[本文假设你已经在 github 建立了一个 yourname.github.io 的网站，为了看起来逼格更高，更好记，更 professional，所以要绑定域名？！
我本来的 github page 是 sabrinaluo.github.io…]]></description><link>https://hiitea.io/2015/12/12/set-a-custom-domain-for-github-page/</link><guid isPermaLink="false">https://hiitea.io/2015/12/12/set-a-custom-domain-for-github-page/</guid><pubDate>Sat, 12 Dec 2015 16:34:42 GMT</pubDate><content:encoded>&lt;p&gt;本文假设你已经在 github 建立了一个 yourname.github.io 的网站，为了看起来逼格更高，更好记，更 professional，所以要绑定域名？！
我本来的 github page 是&lt;a href=&quot;http://sabrinaluo.github.io&quot;&gt;sabrinaluo.github.io&lt;/a&gt;，花了一百多大洋把这个域名变成&lt;a href=&quot;http://sabrinaluo.com&quot;&gt;sabrinaluo.com&lt;/a&gt;，github.io 到.com，为了省 6 个字符，居然要花一百多大洋 QAQ&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;del&gt;只讨论一级域名的绑定，不讨论二级域名的绑定（因为我不会呀）&lt;/del&gt;
&lt;strong&gt;先讨论一级域名的绑定，假设是&lt;a href=&quot;http://www.abc.com&quot;&gt;www.abc.com&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;首先…你要有一个&lt;del&gt;男盆友&lt;/del&gt;域名…没有的话就去 godaddy 买一个；&lt;/li&gt;&lt;li&gt;然后打开你的 cmd console，ping 一下你的 github page，也就是输入&lt;code&gt;ping yourname.github.io&lt;/code&gt;，你会看到你的页面所在的主机的 IP 地址，下面的例子 IP 是 103.245.222.133，不知道是不是所有人的 IP 都一样呢。&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;C:\&amp;gt;ping yourname.github.io
正在 Ping github.map.fastly.net [103.245.222.133] 具有 32 字节的数据:
来自 103.245.222.133 的回复: 字节=32 时间=5ms TTL=58
来自 103.245.222.133 的回复: 字节=32 时间=6ms TTL=58
来自 103.245.222.133 的回复: 字节=32 时间=8ms TTL=58
来自 103.245.222.133 的回复: 字节=32 时间=12ms TTL=58
103.245.222.133 的 Ping 统计信息:
数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，
往返行程的估计时间(以毫秒为单位):
最短 = 5ms，最长 = 12ms，平均 = 7ms
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;登录你的 godday 账号，设置一下 DNS 的 A 记录：&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;找到你的 domain，点 manage DNS&lt;/li&gt;&lt;li&gt;进入 DNS 设置页面后点 Add Record，在弹出的对话框选 A(Host)&lt;blockquote&gt;&lt;p&gt;RECORD TYPE: A(Host)
HOST: 这里填你在 godday 买的域名，例如 abc.com
POINTS TO: 这里填第三步获取到的 IP 地址
TTL: 生效的时间，不知道最短是多久，我反正是选 custom 之后填了 600，也就是 10 分钟&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;然后就等等等，等 10 分钟左右，在浏览器里访问一下你新买的域名，如果看到 github 的 404 页面，就说明 DNS 的设置已经成功了&lt;/li&gt;&lt;li&gt;最后，在你的 yourname.github.io 这个 repo 创建一个名为&lt;code&gt;CNAME&lt;/code&gt;的文件，没有后缀名。文件内容如下：&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;abc.com
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;是的，你没看错，就是辣么简单！&lt;/p&gt;&lt;p&gt;&lt;strong&gt;二级域名的设置&lt;/strong&gt;
假如你有两个 github page，一个是 blog，一个是 news，那你的两个二级域名分别就是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;blog.abc.com&lt;/li&gt;&lt;li&gt;news.abc.com&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;到 godday 设置两条&lt;strong&gt;A 记录&lt;/strong&gt;，分别设置 blog 及 news 指向 github page 的 IP&lt;/li&gt;&lt;li&gt;到对应的 git repo 下面添加对应的 CNAME 文件，例如在 blog 这个 repo 下的 CNAME 是&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;blog.abc.com
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;整个过程其实做的事情大概可以理解为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;告诉 godday，当别人访问我的域名 abc.com 的时候，请带他们去 github&lt;/li&gt;&lt;li&gt;告诉你的 github page，当别人是被 abc.com 带来 github 的时候，没错他们都是我派来的，请接收他们的访问&lt;/li&gt;&lt;li&gt;告诉你的 github page，当别人直接访问 github page，也就是 yourname.github.io 的时候，请穿上花了一百多大洋买的马甲 abc.com…（这其实是说，当你添加了 cname 记录之后，访问 yourname.github.io，你在浏览器里看到的域名会自动变成 abc.com）&lt;/li&gt;&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[X-WSSE验证中关于SHA1编码方式的一些坑]]></title><description><![CDATA[不知道为什么，关于 X-WSSE 验证的中文资料很少，英文资料也不是很多，能搜到的资料年代都非常久远，最早可追溯到 2003 年 ，可能这种验证方式太古老而且存在什么弊端，所以在随后的很多年里人们发现、发明了其他更常用的验证方式？ 关于 HTTP…]]></description><link>https://hiitea.io/2015/12/11/x-wsse/</link><guid isPermaLink="false">https://hiitea.io/2015/12/11/x-wsse/</guid><pubDate>Fri, 11 Dec 2015 09:08:38 GMT</pubDate><content:encoded>&lt;p&gt;不知道为什么，关于 X-WSSE 验证的中文资料很少，英文资料也不是很多，能搜到的资料年代都非常久远，最早可追溯到 2003 年&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，可能这种验证方式太古老而且存在什么弊端，所以在随后的很多年里人们发现、发明了其他更常用的验证方式？&lt;/p&gt;&lt;p&gt;关于 HTTP 的各种验证方式我其实一种都不知道…X-WSSE 这一种奇怪的方式是我在整合 Emarsys 的 API 时了解到的。由于自身比较懒，就到 Github 上搜搜有没有现成的能够生成 UsernameToken 的包可以用，以省去重复发明轮子的功夫，然而掉进了坑里，与&lt;a href=&quot;https://github.com/bouzuya/node-wsse&quot;&gt;node-wsse&lt;/a&gt;的作者大战了好几个回合…&lt;/p&gt;&lt;p&gt;此文章不讨论验证的原理，只讨论 X-WSSE UsernameToken 的生成方式，其中主要是生成&lt;strong&gt;passwordDigest&lt;/strong&gt;。
验证嘛，用户名 username，密码 password 肯定是少不了的，此外还需要 nonce，timeStamp，有了这几样再按照下面的步骤一步步就可以生成符合 WSSE 标准的 token 了。&lt;/p&gt;&lt;p&gt;UsernameToken 的生成一共需要&lt;strong&gt;5 个步骤&lt;/strong&gt;：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;生成一个随机字符串 nonce。不同公司的 API 对这个 nonce 的要求可能会不同，有一些要求采用&lt;code&gt;base64&lt;/code&gt;编码方式，比如&lt;a href=&quot;http://symfony.com/doc/current/cookbook/security/custom_authentication_provider.html#the-authentication-provider&quot;&gt;symfony 给出的例子&lt;/a&gt;；&lt;/li&gt;&lt;li&gt;时间戳（timeStamp）。对于时间戳，统一采用&lt;a href=&quot;http://baike.baidu.com/view/931641.htm&quot;&gt;ISO-8601&lt;/a&gt;格式的字符串，但是不同公司的 API 对时区（timezone）的要求可能会不同，比如 Emarsys 要求 UTC，Adobe 要求 GMT；&lt;/li&gt;&lt;li&gt;把 nonce，timeStamp，password 这三个字符串按顺序连接起来形成一个新的字符串，并将这个字符串按照&lt;a href=&quot;http://baike.baidu.com/view/1228622.htm&quot;&gt;SHA1&lt;/a&gt;方法加密。
&lt;strong&gt;坑来啦，坑来啦，坑来啦！！！&lt;/strong&gt;
一个字符串通常加密之后密码摘要默认是 binary 的，比如 Adobe&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;，但有些公司可能要求以 hex 方式生成摘要…比如万恶的 Emarsys&lt;sup id=&quot;fnref-3&quot;&gt;&lt;a href=&quot;#fn-3&quot; class=&quot;footnote-ref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;…而关于这个摘要到底应该是 binary 还是 hex，据说业界也是模糊不清的，只能由着各家公司按自身情况使用两种方式中的某一种来实现验证&lt;sup id=&quot;fnref-4&quot;&gt;&lt;a href=&quot;#fn-4&quot; class=&quot;footnote-ref&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;；&lt;/li&gt;&lt;li&gt;把上一步得到的密码摘要按照&lt;code&gt;base64&lt;/code&gt;进行编码，就能得到 passwordDigest；&lt;/li&gt;&lt;li&gt;按照以下方式拼接字符串，把各个双引号内换成上面步骤所提到的值，即可得到 UsernameToken，看起来长这样：&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;UsernameToken Username=&amp;quot;username&amp;quot;, PasswordDigest=&amp;quot;passwordDigest&amp;quot;, Nonce=&amp;quot;nonce&amp;quot;, Created=&amp;quot;timeStamp&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;http://www.xml.com/pub/a/2003/12/17/dive.html&quot;&gt;http://www.xml.com/pub/a/2003/12/17/dive.html&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;https://marketing.adobe.com/developer/cn/documentation/authentication-1/wsse-authentication-2&quot;&gt;https://marketing.adobe.com/developer/cn/documentation/authentication-1/wsse-authentication-2&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-3&quot;&gt;&lt;a href=&quot;http://documentation.emarsys.com/resource/developers/api/getting-started/authentication/&quot;&gt;http://documentation.emarsys.com/resource/developers/api/getting-started/authentication/&lt;/a&gt;&lt;a href=&quot;#fnref-3&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-4&quot;&gt;&lt;a href=&quot;http://book.soundonair.ru/web/web2apps-CHP-11-SECT-1.html#web2apps-CHP-11-SECT-1.8&quot;&gt;http://book.soundonair.ru/web/web2apps-CHP-11-SECT-1.html#web2apps-CHP-11-SECT-1.8&lt;/a&gt;&lt;a href=&quot;#fnref-4&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[版本控制及git常用基本命令]]></title><description><![CDATA[（此文章适合听说过 git，大概知道 git 是什么东东，但是又不会 git 命令的童鞋阅读。
时间充裕的童鞋可以到 codecademy 跟着教程一步步走） Git 是一个分布式的版本管理( Version Control…]]></description><link>https://hiitea.io/2015/12/04/git-basic/</link><guid isPermaLink="false">https://hiitea.io/2015/12/04/git-basic/</guid><pubDate>Fri, 04 Dec 2015 03:40:04 GMT</pubDate><content:encoded>&lt;p&gt;（此文章适合听说过 git，大概知道 git 是什么东东，但是又不会 git 命令的童鞋阅读。
时间充裕的童鞋可以到&lt;a href=&quot;https://www.codecademy.com/learn/learn-git&quot;&gt;codecademy&lt;/a&gt;跟着教程一步步走）&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://git-scm.com/&quot;&gt;Git&lt;/a&gt;是一个分布式的版本管理(&lt;a href=&quot;https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control&quot;&gt;Version Control&lt;/a&gt;)工具。&lt;/p&gt;&lt;p&gt;版本管理这个概念很多童鞋可能不是很清楚，但其实在代码创作的过程中很可能已经使用过了一些传统的方法，比如我初中高中的时候创作博客模板的时候，对同一个模板想做一些不同的调整，同时又担心调整后原来的功能啊显示啊的会受到影响，那时候还不知道 github 之类的东东，于是&lt;del&gt;机智地&lt;/del&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;ol&gt;&lt;li&gt;创建了很多文件夹来放不同的模板&lt;/li&gt;&lt;li&gt;不停的备份&lt;/li&gt;&lt;li&gt;如果调整后正常运行和显示，那就使用最新的版本&lt;/li&gt;&lt;li&gt;如果调整后不能正常运行同时又找不出问题所在，就是用备份的上一个版本来重新创作&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;以上对应到版本控制系统分别是：&lt;/p&gt;&lt;blockquote&gt;&lt;ol&gt;&lt;li&gt;创建分支(branch)&lt;/li&gt;&lt;li&gt;提交代码(commit)&lt;/li&gt;&lt;li&gt;合并分支(merge)&lt;/li&gt;&lt;li&gt;版本回滚(checkout)&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;关于 git 的概念及使用流程这里不详细讨论，暂时只讨论一些最基本的常用的 git 命令&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;git init&lt;/code&gt; 初始化一个 git 仓库，生成&lt;code&gt;.git&lt;/code&gt;隐藏文件&lt;/li&gt;&lt;li&gt;&lt;code&gt;git status&lt;/code&gt; 查看 git 仓库的状态，将会返回&lt;strong&gt;当前分支&lt;/strong&gt;, &lt;strong&gt;文件状态&lt;/strong&gt;等信息，可以使用&lt;code&gt;-s&lt;/code&gt;参数查看只有文件状态的简洁版信息&lt;/li&gt;&lt;li&gt;&lt;code&gt;git clone &amp;lt;repo location&amp;gt; &amp;lt;repo name&amp;gt;&lt;/code&gt; 将远程分支克隆到本地，&lt;code&gt;&amp;lt;repo name&amp;gt;&lt;/code&gt;参数可选，为本地 repo 命名，若省略，则本地 repo 与远程同名&lt;/li&gt;&lt;li&gt;&lt;code&gt;git add &amp;lt;file name&amp;gt;&lt;/code&gt; 将文件变为 staged 状态，也就是告诉 git 哪些新的文件和修改过的文件是之后要提交的；文件名支持正则表达式&lt;/li&gt;&lt;li&gt;&lt;code&gt;git rm &amp;lt;file name&amp;gt;&lt;/code&gt; 将文件删除同时告诉 git 从 git 仓库中删除文件，可以使用 &lt;code&gt;--cached&lt;/code&gt; 参数实现只从 git 仓库中删除而不删除本地文件&lt;/li&gt;&lt;li&gt;&lt;code&gt;git diff &amp;lt;file name&amp;gt;&lt;/code&gt; 查看 git 仓库文件与本地文件的区别&lt;/li&gt;&lt;li&gt;&lt;code&gt;git commit -m &amp;quot;some comment&amp;quot;&lt;/code&gt; 将修改提交到 git 仓库&lt;/li&gt;&lt;li&gt;&lt;code&gt;git show HEAD&lt;/code&gt; 显示 HEAD 版本的相关信息，包括&lt;strong&gt;author&lt;/strong&gt;，&lt;strong&gt;date&lt;/strong&gt;，&lt;strong&gt;comment&lt;/strong&gt;，&lt;strong&gt;diff&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;git log&lt;/code&gt; 查看提交记录，包括提交的时间、作者、评论&lt;/li&gt;&lt;li&gt;&lt;code&gt;git reset SHA&lt;/code&gt; 将本地 git 仓库回退到某个版本，其中&lt;code&gt;SHA&lt;/code&gt;为版本 log 中 commit 后的一长串字符的前 7 位字符&lt;/li&gt;&lt;li&gt;&lt;code&gt;git reset HEAD &amp;lt;file name&amp;gt;&lt;/code&gt; 将本地 git 仓库中的某个文件重置为 git 仓库的 HEAD 版本&lt;/li&gt;&lt;li&gt;&lt;code&gt;git checkout HEAD&lt;/code&gt; 使用 git 仓库中的文件覆盖当前的整个 working copy，可以在修改了某些文件但想舍弃这些修改的时候使用这个命令&lt;blockquote&gt;&lt;p&gt;需要注意&lt;code&gt;reset&lt;/code&gt;是针对本地的 git 仓库，也就是你每次 commit 后，文件就会保存到的仓库。
而&lt;code&gt;checkout&lt;/code&gt;是针对本地的工作副本，也就是你直接编辑的那些文件，会被 overwrite&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;git branch&lt;/code&gt; 查看分支信息，使用&lt;code&gt;-r&lt;/code&gt;参数查看远程分支信息，使用-&lt;code&gt;a&lt;/code&gt;参数查看所有分支信息&lt;/li&gt;&lt;li&gt;&lt;code&gt;git branch &amp;lt;branch name&amp;gt;&lt;/code&gt; 添加新的分支&lt;/li&gt;&lt;li&gt;&lt;code&gt;git branch -d &amp;lt;branch name&amp;gt;&lt;/code&gt; 删除分支&lt;/li&gt;&lt;li&gt;&lt;code&gt;git checkout &amp;lt;branch name&amp;gt; &amp;lt;remote branch&amp;gt;&lt;/code&gt; 切换分支，可以使用&lt;code&gt;-b&lt;/code&gt;参数，创建新分支并切换到新分支；省略&lt;code&gt;&amp;lt;remote branch&amp;gt;&lt;/code&gt;，则从当前分支创建新分支&lt;/li&gt;&lt;li&gt;&lt;code&gt;git fetch&lt;/code&gt; 获取远程 origin/master 分支最新版本，需要手动与本地文件 merge&lt;/li&gt;&lt;li&gt;&lt;code&gt;git pull&lt;/code&gt; 获取远程的最新版本并与本地 merge&lt;blockquote&gt;&lt;p&gt;需要注意 &lt;code&gt;git fetch&lt;/code&gt; 与 &lt;code&gt;git pull&lt;/code&gt; 的不同，通常如果本地文件有改动，则应该先 fetch 在 &lt;code&gt;git merge origin/master&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;git stash&lt;/code&gt; 将本地的工作副本暂时存起来&lt;/li&gt;&lt;li&gt;&lt;code&gt;git pop&lt;/code&gt; 将存起来的工作副本放出来…&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;git stash&lt;/code&gt; 和 &lt;code&gt;git pop&lt;/code&gt; 通常在&lt;code&gt;git pull&lt;/code&gt;或&lt;code&gt;git merge&lt;/code&gt;的时候如果有冲突(conflict)的时候使用，&lt;code&gt;pop&lt;/code&gt;之后有冲突的工作副本会变成如下的样子，冲突的 resolve 就是选取最终的内容，然后删除多余的内容，包括&lt;code&gt;&amp;lt;&amp;lt;&amp;lt; ===&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;这些行也要删除，让代码看起来和正常的代码一样。&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// git pop之后的冲突文件看起来长这样：
 &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; their code
 var a = 123;
 =======
 var a = 456;
 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; my code
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// 冲突解决后，看起来应该长这样：
var a = 123;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;git merge &amp;lt;branch name&amp;gt;&lt;/code&gt; 合并分支，将指定分支与当前分支合并&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;origin/master&lt;/code&gt;分支为远程主分支&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;git push origin &amp;lt;branch name&amp;gt;&lt;/code&gt; 把分支推送到远程&lt;/li&gt;&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[我所理解的Promise]]></title><description><![CDATA[异步模式 （嫌我话多的可以直接看分割线之后的部分…）
以前高中的时候自己捣腾博客，一直也就只会用 JQuery 写点按钮事件什么的，连表单提交都没写过，后来误打误撞做了前端码农旧觉得 JS 的异步模式实在是太坑爹，当你搞清楚异步回调的时候，又会发现 回调地狱(Callback…]]></description><link>https://hiitea.io/2015/12/01/promise/</link><guid isPermaLink="false">https://hiitea.io/2015/12/01/promise/</guid><pubDate>Tue, 01 Dec 2015 10:46:26 GMT</pubDate><content:encoded>&lt;h2&gt;异步模式&lt;/h2&gt;&lt;p&gt;（嫌我话多的可以直接看分割线之后的部分…）
以前高中的时候自己捣腾博客，一直也就只会用 JQuery 写点按钮事件什么的，连表单提交都没写过，后来误打误撞做了前端码农旧觉得 JS 的异步模式实在是太坑爹，当你搞清楚异步回调的时候，又会发现&lt;a href=&quot;http://callbackhell.com/&quot;&gt;回调地狱(Callback Hell)&lt;/a&gt;太坑爹…
为什么觉得异步坑爹？看看下面这个例子：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;//以下用setTimeout()模拟一个请求
function getName() {
  return &amp;#x27;小白妹妹&amp;#x27;;
}

function greeting(name) {
  console.log(&amp;#x27;你好，&amp;#x27; + name);
}

//生成一个0到1000的随机数，模拟不确定的等待时间0-1秒
var randomTime = function () {
  return Math.random() * 1000;
};

var name = &amp;#x27;&amp;#x27;;
//1秒之内给name赋值为 小白妹妹，但不知道具体时间
setTimeout(function () {
  name = getName();
}, randomTime());

greeting(name); //以为得到name之后就可以开心的去打招呼啦，然而…
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;回调地狱&lt;/h3&gt;&lt;p&gt;可能很多新手都犯过这个错误，错的时候还不知道为啥错了…深究原因的话跟 JS 的机制有关，长篇大论的就不在这里多说了（其实是我说不清楚…）&lt;/p&gt;&lt;p&gt;再有点经验，就会知道，应该把 &lt;code&gt;greeting(name)&lt;/code&gt; 写在回调函数里，这样就能保证在得到数据之后才运行 &lt;code&gt;greeting()&lt;/code&gt; 函数，于是…当你有多个请求并且之间是有这种依赖关系的时候，可怕的回调地狱就出现了！
而解决回调地狱其中一个很优雅的方法，就是使用传说中的 promise！&lt;/p&gt;&lt;h2&gt;Promise 的使用&lt;/h2&gt;&lt;p&gt;关于 promise 这个概念我前前后后看了有一年了，周围也没有认识的人可以给我讲，只能自己看看网上的文章，然而…&lt;del&gt;并没有什么卵用&lt;/del&gt;…网上的文章都是众说纷纭，有一上来就 defer 的&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，也有一上来就说如果你还在用 defer 你就理解错了 Promise 的&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;，就所以我到现在也不知道究竟什么样的理解才是对的…&lt;/p&gt;&lt;p&gt;关于&lt;a href=&quot;http://segmentfault.com/a/1190000002452115&quot;&gt;Promise 以及 A+规范&lt;/a&gt;就不在此详述了，那些概念的东东，我也还没完全理解。我想做的是让跟我一样的小白都能明白 Promise 最基本的用法。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;举个栗子…
有一个第三方提供的 API，访问 API 能够得到一些用户数据（每访问一次得到一页，假设由于某些限制一页只返回 3 个用户）以及下一页的 index；除了第一页之外，其他的页面都需要下一页的 index 参数才能访问到。（先不管这个 API 设计的合不合理…Facebook 就有这样的 API）
&lt;a href=&quot;http://example.com/user&quot;&gt;http://example.com/user&lt;/a&gt; &lt;em&gt;--&amp;gt;访问第一页的用户数据&lt;/em&gt;
&lt;a href=&quot;http://example.com/user?next=xzmca&quot;&gt;http://example.com/user?next=xzmca&lt;/a&gt; &lt;em&gt;--&amp;gt;访问第二页的用户数据&lt;/em&gt;
请求第一页时返回结果如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
&amp;quot;items&amp;quot; : [{
  &amp;quot;name&amp;quot; : &amp;quot;小白妹妹&amp;quot;,
   &amp;quot;age&amp;quot; : 10
  },
  {...},
  {...}],
&amp;quot;nextPage&amp;quot; : &amp;quot;xzmca&amp;quot;,
&amp;quot;lastPage&amp;quot; : null
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可能会有这样的需求：你的 APP 一次需要显示 6 个甚至更多个的用户数据。而根据之前的 API，一次只能拿到 3 个数据，那么就只能发出两次请求，并且&lt;strong&gt;第二次请求依赖于第一次请求的结果&lt;/strong&gt;，由于异步的原因我们并不知道第一个请求什么时候才完成，&lt;del&gt;而我最初入坑时是让程序发完第一个请求后强制等 2 秒再发第二个请求我会告诉你们吗…&lt;/del&gt;&lt;/p&gt;&lt;p&gt;下面为了方便，使用&lt;code&gt;setTimeout()&lt;/code&gt;函数和&lt;a href=&quot;http://bluebirdjs.com/&quot;&gt;bluebird&lt;/a&gt;库进行说明:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;//生成一个0到3000的随机数，模拟不确定的等待时间0-3秒
var randomTime = function () {
  return Math.random() * 3000;
};

//只考虑最简单的情况promise被resolve，暂时不考虑promise被reject的情况
function req1() {
  return new Promise(function (resolve) {
    //使用setTimeout()来模拟发送请求，data为请求得到的数据
    setTimeout(function () {
      var data = {
        items: [
          {
            name: &amp;#x27;小白妹妹&amp;#x27;,
            age: 10,
          },
          {
            name: &amp;#x27;小白&amp;#x27;,
            age: 100,
          },
          {
            name: &amp;#x27;妹妹&amp;#x27;,
            age: 111,
          },
        ],
        nextPage: &amp;#x27;asdfa&amp;#x27;,
        lastPage: null,
      };
      resolve(data);
      console.log(&amp;#x27;请求1完成&amp;#x27;);
    }, randomTime());
  });
}

function req2(dataFromReq1) {
  return new Promise(function (resolve) {
    setTimeout(function () {
      var data = {
        items: [
          {
            name: &amp;#x27;小黑姐姐&amp;#x27;,
            age: 20,
          },
          {
            name: &amp;#x27;小黑&amp;#x27;,
            age: 233,
          },
          {
            name: &amp;#x27;姐姐&amp;#x27;,
            age: 250,
          },
        ],
        nextPage: &amp;#x27;gwdfx&amp;#x27;,
        lastPage: &amp;#x27;asdfa&amp;#x27;,
      };
      console.log(dataFromReq1);
      var finalUserData = dataFromReq1.items.concat(data.items); //将两次得到的用户数据合并
      resolve(finalUserData);
      console.log(&amp;#x27;请求2完成&amp;#x27;);
    }, randomTime());
  });
}

//让数据在promise链上欢快的传递吧～
req1()
  .then(req2)
  .then(function (data) {
    console.log(data);
  });
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Q&amp;amp;A&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Q: 什么时候需要返回一个 promise 呢？
A: 当你的需求逻辑是，XXX 的执行需要依赖 OOO 的结果，此时 OOO 就应该返回一个 promise&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Q: 为什么 req1 要打括号，而 req2 不打括号？
A:这个我也没太搞清楚 XD，我的理解是，&lt;code&gt;req1()&lt;/code&gt;打括号执行后才会返回 promise，不打括号就只是一个没有执行的函数，&lt;code&gt;req2&lt;/code&gt;不打括号是因为 then 的入参只能是一个&lt;strong&gt;函数&lt;/strong&gt;，如果打了括号执行后就不是函数了。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Q: 最后一个 then 的 function(data) data 是哪里来的？
A: &lt;code&gt;req2&lt;/code&gt;的定义中，有一句&lt;code&gt;resolve(finalUserData)&lt;/code&gt;，在 Promise Chain 中，每个 then 的入参的入参也就是 function(data)中的 data 都是由前一个 promise resolve 时传递而来的&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn-1&quot;&gt;&lt;a href=&quot;https://github.com/alsotang/node-lessons/tree/master/lesson17&quot;&gt;https://github.com/alsotang/node-lessons/tree/master/lesson17&lt;/a&gt;&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn-2&quot;&gt;&lt;a href=&quot;http://web.jobbole.com/82601/&quot;&gt;http://web.jobbole.com/82601/&lt;/a&gt;&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content:encoded></item></channel></rss>